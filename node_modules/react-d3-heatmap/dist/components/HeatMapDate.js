"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _d = require("d3");

var d3 = _interopRequireWildcard(_d);

var _d3Tip = require("d3-tip");

var _d3Tip2 = _interopRequireDefault(_d3Tip);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Component that display a heatmap to visualize data through date.
 * Each square is a day.
 */
var HeatMapDate = function (_PureComponent) {
	_inherits(HeatMapDate, _PureComponent);

	/**
  * Props type checking
  */
	function HeatMapDate(props) {
		_classCallCheck(this, HeatMapDate);

		var _this = _possibleConstructorReturn(this, (HeatMapDate.__proto__ || Object.getPrototypeOf(HeatMapDate)).call(this, props));

		_this.state = {
			svgElem: undefined,
			svgLegend: undefined,
			firstRender: true
		};

		_this.ID = Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 32);
		_this.IDLegend = Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 32);
		return _this;
	}

	/**
  * Set a default value to unrequired props
  */


	_createClass(HeatMapDate, [{
		key: "componentDidUpdate",
		value: function componentDidUpdate() {
			var _this2 = this;

			// I use a setTimeout to prevent a component update that stop the transition.
			setTimeout(function () {
				if (_this2.props.transition > 0 && _this2.state.firstRender && _this2.state.svgElem) {
					_this2.setState({ firstRender: false });
				}
			}, this.props.transition);
		}
	}, {
		key: "render",
		value: function render() {
			var _this3 = this;

			var _props = this.props,
			    startDate = _props.startDate,
			    endDate = _props.endDate,
			    data = _props.data,
			    colors = _props.colors,
			    defaultColor = _props.defaultColor,
			    rectWidth = _props.rectWidth,
			    marginRight = _props.marginRight,
			    marginBottom = _props.marginBottom,
			    displayLegend = _props.displayLegend,
			    transition = _props.transition,
			    backgroundColor = _props.backgroundColor,
			    textColor = _props.textColor,
			    radius = _props.radius,
			    classnames = _props.classnames,
			    displayYear = _props.displayYear,
			    onClick = _props.onClick,
			    onMouseEnter = _props.onMouseEnter,
			    onMouseLeave = _props.onMouseLeave,
			    textDefaultColor = _props.textDefaultColor;
			var _state = this.state,
			    svgElem = _state.svgElem,
			    svgLegend = _state.svgLegend,
			    firstRender = _state.firstRender;
			// Array of months for x axis

			var monthsName = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "July", "Aug", "Sep", "Oct", "Nov", "Dec"];
			// Array of days for y axis
			var daysName = ["Sun", "Tue", "Thu", "Sat"];
			var dataset = [];
			var t = null;
			if (transition > 0 && firstRender) {
				t = d3.transition().duration(transition);
			}

			// This is a possible workaround about tooltips that do not want to hide when data change
			// See https://github.com/Caged/d3-tip/issues/133
			d3.select(".d3-tip." + this.ID).remove();
			d3.select(".d3-tip." + this.IDLegend).remove();

			var svg = d3.select(svgElem);
			// We remove all elemnts (rect + text) to properly update the svg
			svg.selectAll("*").remove();
			var tmpBufferDate = new Date(startDate);
			var startDateYesterday = new Date(startDate);
			// When want to display month on first column if difference between
			// startDate and endDate less than 1 month
			var noMonthName = startDate.getMonth() === endDate.getMonth() && startDate.getFullYear() === endDate.getFullYear() || startDate.getMonth() == 11 && endDate.getMonth() === 0 && endDate.getFullYear() - startDate.getFullYear() === 1;
			startDateYesterday.setDate(startDateYesterday.getDate() - 1);
			// We set bufferDate to the previous Sunday of startDate.
			tmpBufferDate.setDate(tmpBufferDate.getDate() - startDateYesterday.getDay());
			var bufferDate = new Date(tmpBufferDate);
			bufferDate.setHours(0, 0, 0, 0);
			// Number of day from bufferDate to endDate
			var nbDayDiff = (endDate.getTime() - bufferDate.getTime()) / 1000 / 60 / 60 / 24;
			var svgWidth = (rectWidth + marginRight) * (nbDayDiff / 7) + 70;
			svg.attr("width", svgWidth).attr("height", (rectWidth + marginBottom) * 7 + 50);

			if (noMonthName) {
				var prefix = displayYear ? new Date(bufferDate).getFullYear().toString().substring(2, 4) + "/" : "";
				var prefixWidth = displayYear ? 25 : 0;
				svg.append("text").text(prefix + monthsName[startDate.getMonth()]).attr("x", function () {
					return Math.floor(0 / 7) * (rectWidth + marginRight) + 32 - prefixWidth;
				}).attr("y", 18).attr("font-size", 18).attr("fill", textColor);
			}

			var _loop = function _loop(i) {
				var prefix = displayYear ? new Date(bufferDate).getFullYear().toString().substring(2, 4) + "/" : "";
				var prefixWidth = displayYear ? 25 : 0;
				if (i == 0 || i === 2 || i === 4 || i === 6) {
					// Display day name as y axis
					svg.append("text").text(daysName[i / 2]).attr("y", i % 7 * (rectWidth + marginBottom) + rectWidth / 6 + 32).attr("x", 0).attr("fill", textColor);
				}
				// Find the first data that match with current bufferDate
				var objMatch = data.find(function (obj) {
					var dateTmp = new Date(obj.date);
					dateTmp.setHours(0, 0, 0, 0);
					bufferDate.setHours(0, 0, 0, 0);
					return dateTmp.getTime() === bufferDate.getTime();
				});
				// If bufferDate < (startDate - 1 day) we set the square color like background to make that 'invisible'
				var finalColor = backgroundColor;
				var maxCount = null;
				// If there is no match we set the default color
				if (objMatch === undefined && bufferDate.getTime() >= startDateYesterday.getTime()) {
					finalColor = defaultColor;
				} else if (bufferDate.getTime() >= startDateYesterday.getTime()) {
					finalColor = colors.filter(function (c) {
						return c.count <= objMatch.count;
					});
					if (finalColor.length === 0) {
						finalColor = defaultColor;
					} else {
						finalColor = finalColor[finalColor.length - 1].color;
					}
				}
				var today = new Date(bufferDate.getTime());
				// Finally, we push it to an Array that will be used by d3
				dataset.push({ date: today, count: objMatch ? objMatch.count : maxCount || 0, color: finalColor, i: i });

				if (bufferDate.getDate() === 1 && !noMonthName) {
					// Display month name
					svg.append("text").text(prefix + monthsName[bufferDate.getMonth()]).attr("x", function () {
						return Math.floor(i / 7) * (rectWidth + marginRight) + 32 - prefixWidth;
					}).attr("y", 18).attr("font-size", 18).attr("fill", textColor);
				}
				bufferDate.setDate(bufferDate.getDate() + 1);
			};

			for (var i = 0; i < nbDayDiff; i++) {
				_loop(i);
			}

			if (dataset.length > 0) {
				// I added an ID the tooltip because it's a workaround to prevent the tooltip won't hide when the component is updating
				var tip = (0, _d3Tip2.default)().attr("class", "d3-tip " + this.ID).offset([-8, 0]).html(function (d) {
					if (d.color !== backgroundColor) {
						return "<div style={{ fontSize: '15' }}>" + d.date.getFullYear() + "/" + (d.date.getMonth() + 1) + "/" + d.date.getDate() + " : " + d.count + "</div>";
					} else return null;
				});
				svg.call(tip);
				// Display all data squares
				var rects = svg.selectAll("rect").data(dataset).enter().append("rect").attr("fill-opacity", t !== null ? 0 : 1).attr("width", rectWidth).attr("height", rectWidth).attr("class", "dayRect").attr("x", function (d) {
					return Math.floor(d.i / 7) * (rectWidth + marginRight) + 32;
				}).attr("y", function (d) {
					return d.i % 7 * (rectWidth + marginBottom) + 24;
				}).attr("fill", function (d) {
					return d.color;
				}).attr("rx", radius).attr("ry", radius).on("mouseover", function (d, i) {
					if (d.color !== backgroundColor) {
						tip.show(d, this);
						d3.select(this).attr("stroke", "black");
					}
					onMouseEnter(d, i);
				}).on("mouseout", function (d, i) {
					tip.hide(d, _this3);
					d3.selectAll("rect").attr("stroke", "none");
					onMouseLeave(d, i);
				}).on("click", function (d, i) {
					onClick(d, i);
				});

				if (t !== null) rects.transition(t).attr("fill-opacity", 1);
			}

			var legendWidth = 0;

			if (displayLegend) {
				var svgLegendD3 = d3.select(svgLegend);
				svgLegendD3.selectAll("*").remove();
				legendWidth = (rectWidth + marginRight) * colors.length + 90 + 50;
				svgLegendD3.attr("width", legendWidth).attr("height", 30);
				svgLegendD3.append("text").text("Legend :").attr("x", 0).attr("y", 20).attr("font-size", 18).attr("fill", textColor);

				var _tip = (0, _d3Tip2.default)().attr("class", "d3-tip " + this.IDLegend).offset([-8, 0]).html(function (d) {
					var displ = d.text ? d.text : d.count.toString();
					return "<div style={{ fontSize: '15' }}>" + displ + "</div>";
				});
				svgLegendD3.call(_tip);
				svgLegendD3.selectAll("rect").data([{
					color: defaultColor,
					count: 0,
					text: textDefaultColor ? textDefaultColor : "0"
				}].concat(colors)).enter().append("rect").attr("width", rectWidth).attr("height", rectWidth).attr("x", function (d, i) {
					return (rectWidth + marginRight) * i + 80;
				}).attr("y", 15 - rectWidth / 2).attr("rx", radius).attr("ry", radius).attr("fill", function (d) {
					return d.color;
				}).on("mouseover", function (d) {
					if (d.color !== backgroundColor) {
						_tip.show(d, this);
						d3.select(this).attr("stroke", textColor);
					}
				}).on("mouseout", function (d) {
					_tip.hide(d, _this3);
					d3.selectAll("rect").attr("stroke", "none");
				});
			} else {
				var _svgLegendD = d3.select(svgLegend);
				_svgLegendD.attr("width", 0).attr("height", 0);
			}

			return _react2.default.createElement(
				"div",
				{
					className: classnames,
					style: {
						width: legendWidth > svgWidth ? legendWidth : svgWidth + "px",
						height: "auto",
						backgroundColor: backgroundColor
					},
					id: "react-d3-heatMap" },
				_react2.default.createElement("svg", {
					style: { display: "block" },
					ref: function ref(elem) {
						if (!_this3.state.svgElem) _this3.setState({ svgElem: elem });
					}
				}),
				_react2.default.createElement("svg", {
					ref: function ref(elem) {
						if (!_this3.state.svgLegend) _this3.setState({ svgLegend: elem });
					}
				})
			);
		}
	}]);

	return HeatMapDate;
}(_react.PureComponent);

HeatMapDate.propTypes = {
	// The 'visible' heatmap will start this date
	startDate: _propTypes2.default.instanceOf(Date).isRequired,
	// The 'visible' heatmap will end this date
	endDate: _propTypes2.default.instanceOf(Date).isRequired,
	// The data that fill the heatmap. Must be an Array[{data: Date, count: Number}]
	data: _propTypes2.default.instanceOf(Array).isRequired,
	// Colors that apply a color on squares. Must be an Array[{count: Number, color: String}]
	colors: _propTypes2.default.instanceOf(Array).isRequired,
	// Apply a default color for dates whose count are too low to apply a color from 'colors'
	defaultColor: _propTypes2.default.string,
	// Custom text for default color in tooltip legend
	textDefaultColor: _propTypes2.default.string,
	// Define a width and height for square
	rectWidth: _propTypes2.default.number,
	// Define a margin between two squares on x axis
	marginRight: _propTypes2.default.number,
	// Define a margin between two squares on y axis
	marginBottom: _propTypes2.default.number,
	// Display a legend or not
	displayLegend: _propTypes2.default.bool,
	// Apply a transition when heatmap is rendering for the first time
	transition: _propTypes2.default.number,
	// Apply a background color
	backgroundColor: _propTypes2.default.string,
	// Apply a text color (unavailable on tooltip)
	textColor: _propTypes2.default.string,
	// Apply a radius on square
	radius: _propTypes2.default.number,
	// Class attributes,
	classnames: _propTypes2.default.string,
	// Display year near each month
	displayYear: _propTypes2.default.bool,
	// Handle onClick in container callback
	onClick: _propTypes2.default.func,
	// Handle onMouseEnter on each square callback
	onMouseEnter: _propTypes2.default.func,
	// Handle onMouseLeave on each square callback
	onMouseLeave: _propTypes2.default.func };
HeatMapDate.defaultProps = {
	marginRight: 4,
	marginBottom: 4,
	displayLegend: true,
	rectWidth: 10,
	defaultColor: "#cdcdcd",
	transition: -1,
	backgroundColor: "#fff",
	textColor: "#000",
	radius: 0,
	classnames: "",
	onClick: function onClick() {},
	onMouseLeave: function onMouseLeave() {},
	onMouseEnter: function onMouseEnter() {}
};
exports.default = HeatMapDate;