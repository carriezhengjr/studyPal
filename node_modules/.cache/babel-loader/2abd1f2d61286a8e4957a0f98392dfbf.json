{"ast":null,"code":"import { jsx as t, jsxs as e } from \"react/jsx-runtime\";\nimport { scaleLinear as i } from \"d3-scale\";\nimport { getValueFormatter as n, useTheme as o, degreesToRadians as r } from \"@nivo/core\";\nimport { computeContinuousColorScaleColorStops as l } from \"@nivo/colors\";\nimport * as a from \"react\";\nimport { Fragment as c, useState as s, useCallback as d, useMemo as h } from \"react\";\nimport g from \"prop-types\";\n\nvar m = function m(e) {\n  var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      s = void 0 === c ? 0 : c,\n      d = e.borderColor;\n  return t(\"circle\", {\n    r: o / 2,\n    cx: i + o / 2,\n    cy: n + o / 2,\n    fill: r,\n    opacity: a,\n    strokeWidth: s,\n    stroke: void 0 === d ? \"transparent\" : d,\n    style: {\n      pointerEvents: \"none\"\n    }\n  });\n},\n    f = function f(e) {\n  var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      s = void 0 === c ? 0 : c,\n      d = e.borderColor;\n  return t(\"g\", {\n    transform: \"translate(\" + i + \",\" + n + \")\",\n    children: t(\"path\", {\n      d: \"\\n                    M\" + o / 2 + \" 0\\n                    L\" + .8 * o + \" \" + o / 2 + \"\\n                    L\" + o / 2 + \" \" + o + \"\\n                    L\" + .2 * o + \" \" + o / 2 + \"\\n                    L\" + o / 2 + \" 0\\n                \",\n      fill: r,\n      opacity: a,\n      strokeWidth: s,\n      stroke: void 0 === d ? \"transparent\" : d,\n      style: {\n        pointerEvents: \"none\"\n      }\n    })\n  });\n},\n    u = function u(e) {\n  var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      s = void 0 === c ? 0 : c,\n      d = e.borderColor;\n  return t(\"rect\", {\n    x: i,\n    y: n,\n    fill: r,\n    opacity: a,\n    strokeWidth: s,\n    stroke: void 0 === d ? \"transparent\" : d,\n    width: o,\n    height: o,\n    style: {\n      pointerEvents: \"none\"\n    }\n  });\n},\n    v = function v(e) {\n  var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      s = void 0 === c ? 0 : c,\n      d = e.borderColor;\n  return t(\"g\", {\n    transform: \"translate(\" + i + \",\" + n + \")\",\n    children: t(\"path\", {\n      d: \"\\n                M\" + o / 2 + \" 0\\n                L\" + o + \" \" + o + \"\\n                L0 \" + o + \"\\n                L\" + o / 2 + \" 0\\n            \",\n      fill: r,\n      opacity: a,\n      strokeWidth: s,\n      stroke: void 0 === d ? \"transparent\" : d,\n      style: {\n        pointerEvents: \"none\"\n      }\n    })\n  });\n};\n\nfunction p() {\n  return p = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i = arguments[e];\n\n      for (var n in i) {\n        Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);\n      }\n    }\n\n    return t;\n  }, p.apply(this, arguments);\n}\n\nvar y = {\n  length: 200,\n  thickness: 16,\n  direction: \"row\",\n  tickPosition: \"after\",\n  tickSize: 4,\n  tickSpacing: 3,\n  tickOverlap: !1,\n  tickFormat: function tickFormat(t) {\n    return \"\" + t;\n  },\n  titleAlign: \"start\",\n  titleOffset: 4\n},\n    b = {\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0\n},\n    k = function k(t) {\n  var e,\n      i = t.direction,\n      n = t.itemsSpacing,\n      o = t.padding,\n      r = t.itemCount,\n      l = t.itemWidth,\n      a = t.itemHeight;\n  if (\"number\" != typeof o && (\"object\" != typeof (e = o) || Array.isArray(e) || null === e)) throw new Error(\"Invalid property padding, must be one of: number, object\");\n  var c = \"number\" == typeof o ? {\n    top: o,\n    right: o,\n    bottom: o,\n    left: o\n  } : p({}, b, o),\n      s = c.left + c.right,\n      d = c.top + c.bottom,\n      h = l + s,\n      g = a + d,\n      m = (r - 1) * n;\n  return \"row\" === i ? h = l * r + m + s : \"column\" === i && (g = a * r + m + d), {\n    width: h,\n    height: g,\n    padding: c\n  };\n},\n    x = function x(t) {\n  var e = t.anchor,\n      i = t.translateX,\n      n = t.translateY,\n      o = t.containerWidth,\n      r = t.containerHeight,\n      l = t.width,\n      a = t.height,\n      c = i,\n      s = n;\n\n  switch (e) {\n    case \"top\":\n      c += (o - l) / 2;\n      break;\n\n    case \"top-right\":\n      c += o - l;\n      break;\n\n    case \"right\":\n      c += o - l, s += (r - a) / 2;\n      break;\n\n    case \"bottom-right\":\n      c += o - l, s += r - a;\n      break;\n\n    case \"bottom\":\n      c += (o - l) / 2, s += r - a;\n      break;\n\n    case \"bottom-left\":\n      s += r - a;\n      break;\n\n    case \"left\":\n      s += (r - a) / 2;\n      break;\n\n    case \"center\":\n      c += (o - l) / 2, s += (r - a) / 2;\n  }\n\n  return {\n    x: c,\n    y: s\n  };\n},\n    S = function S(t) {\n  var e,\n      i,\n      n,\n      o,\n      r,\n      l,\n      a = t.direction,\n      c = t.justify,\n      s = t.symbolSize,\n      d = t.symbolSpacing,\n      h = t.width,\n      g = t.height;\n\n  switch (a) {\n    case \"left-to-right\":\n      e = 0, i = (g - s) / 2, o = g / 2, l = \"central\", c ? (n = h, r = \"end\") : (n = s + d, r = \"start\");\n      break;\n\n    case \"right-to-left\":\n      e = h - s, i = (g - s) / 2, o = g / 2, l = \"central\", c ? (n = 0, r = \"start\") : (n = h - s - d, r = \"end\");\n      break;\n\n    case \"top-to-bottom\":\n      e = (h - s) / 2, i = 0, n = h / 2, r = \"middle\", c ? (o = g, l = \"alphabetic\") : (o = s + d, l = \"text-before-edge\");\n      break;\n\n    case \"bottom-to-top\":\n      e = (h - s) / 2, i = g - s, n = h / 2, r = \"middle\", c ? (o = 0, l = \"text-before-edge\") : (o = g - s - d, l = \"alphabetic\");\n  }\n\n  return {\n    symbolX: e,\n    symbolY: i,\n    labelX: n,\n    labelY: o,\n    labelAnchor: r,\n    labelAlignment: l\n  };\n},\n    A = function A(t) {\n  var e,\n      o = t.scale,\n      r = t.ticks,\n      a = t.length,\n      c = void 0 === a ? y.length : a,\n      s = t.thickness,\n      d = void 0 === s ? y.thickness : s,\n      h = t.direction,\n      g = void 0 === h ? y.direction : h,\n      m = t.tickPosition,\n      f = void 0 === m ? y.tickPosition : m,\n      u = t.tickSize,\n      v = void 0 === u ? y.tickSize : u,\n      p = t.tickSpacing,\n      b = void 0 === p ? y.tickSpacing : p,\n      k = t.tickOverlap,\n      x = void 0 === k ? y.tickOverlap : k,\n      S = t.tickFormat,\n      A = void 0 === S ? y.tickFormat : S,\n      W = t.title,\n      z = t.titleAlign,\n      C = void 0 === z ? y.titleAlign : z,\n      O = t.titleOffset,\n      B = void 0 === O ? y.titleOffset : O,\n      w = \"column\" === g ? [].concat(o.domain()).reverse() : o.domain(),\n      X = i().domain(w);\n  2 === w.length ? X.range([0, c]) : 3 === w.length && X.range([0, c / 2, c]), e = \"thresholds\" in o ? [w[0]].concat(o.thresholds(), [w[1]]) : Array.isArray(r) ? r : o.ticks(r);\n  var Y,\n      H,\n      E,\n      j,\n      T,\n      L,\n      M = l(o, 32),\n      F = n(A),\n      P = [],\n      R = 0,\n      q = 0;\n\n  if (\"row\" === g) {\n    var V, D, G;\n    Y = c, H = d, q = 1;\n    var I;\n    T = 0, E = \"start\" === C ? 0 : \"middle\" === C ? c / 2 : c, \"before\" === f ? (V = -v, D = x ? d : 0, G = -v - b, I = \"alphabetic\", j = d + B, L = \"hanging\") : (V = x ? 0 : d, G = (D = d + v) + b, I = \"hanging\", j = -B, L = \"alphabetic\"), e.forEach(function (t) {\n      var e = X(t);\n      P.push({\n        x1: e,\n        y1: V,\n        x2: e,\n        y2: D,\n        text: F(t),\n        textX: e,\n        textY: G,\n        textHorizontalAlign: \"middle\",\n        textVerticalAlign: I\n      });\n    });\n  } else {\n    var N, _, J, K;\n\n    Y = d, H = c, R = 1;\n    T = -90, j = \"start\" === C ? c : \"middle\" === C ? c / 2 : 0, \"before\" === f ? (_ = x ? d : 0, J = (N = -v) - b, K = \"end\", E = d + B, L = \"hanging\") : (N = x ? 0 : d, J = (_ = d + v) + b, K = \"start\", E = -B, L = \"alphabetic\"), e.forEach(function (t) {\n      var e = X(t);\n      P.push({\n        x1: N,\n        y1: e,\n        x2: _,\n        y2: e,\n        text: F(t),\n        textX: J,\n        textY: e,\n        textHorizontalAlign: K,\n        textVerticalAlign: \"central\"\n      });\n    });\n  }\n\n  return {\n    width: Y,\n    height: H,\n    gradientX1: 0,\n    gradientY1: R,\n    gradientX2: q,\n    gradientY2: 0,\n    colorStops: M,\n    ticks: P,\n    titleText: W,\n    titleX: E,\n    titleY: j,\n    titleRotation: T,\n    titleHorizontalAlign: C,\n    titleVerticalAlign: L\n  };\n},\n    W = function W(i) {\n  var n = i.scale,\n      r = i.ticks,\n      l = i.length,\n      a = void 0 === l ? y.length : l,\n      s = i.thickness,\n      d = void 0 === s ? y.thickness : s,\n      h = i.direction,\n      g = void 0 === h ? y.direction : h,\n      m = i.tickPosition,\n      f = void 0 === m ? y.tickPosition : m,\n      u = i.tickSize,\n      v = void 0 === u ? y.tickSize : u,\n      b = i.tickSpacing,\n      k = void 0 === b ? y.tickSpacing : b,\n      x = i.tickOverlap,\n      S = void 0 === x ? y.tickOverlap : x,\n      W = i.tickFormat,\n      z = void 0 === W ? y.tickFormat : W,\n      C = i.title,\n      O = i.titleAlign,\n      B = void 0 === O ? y.titleAlign : O,\n      w = i.titleOffset,\n      X = A({\n    scale: n,\n    ticks: r,\n    length: a,\n    thickness: d,\n    direction: g,\n    tickPosition: f,\n    tickSize: v,\n    tickSpacing: k,\n    tickOverlap: S,\n    tickFormat: z,\n    title: C,\n    titleAlign: B,\n    titleOffset: void 0 === w ? y.titleOffset : w\n  }),\n      Y = X.width,\n      H = X.height,\n      E = X.gradientX1,\n      j = X.gradientY1,\n      T = X.gradientX2,\n      L = X.gradientY2,\n      M = X.ticks,\n      F = X.colorStops,\n      P = X.titleText,\n      R = X.titleX,\n      q = X.titleY,\n      V = X.titleRotation,\n      D = X.titleVerticalAlign,\n      G = X.titleHorizontalAlign,\n      I = o(),\n      N = \"ContinuousColorsLegendSvgGradient.\" + g + \".\" + F.map(function (t) {\n    return t.offset;\n  }).join(\"_\");\n  return e(\"g\", {\n    children: [t(\"defs\", {\n      children: t(\"linearGradient\", {\n        id: N,\n        x1: E,\n        y1: j,\n        x2: T,\n        y2: L,\n        children: F.map(function (e) {\n          return t(\"stop\", p({}, e));\n        })\n      })\n    }), P && t(\"text\", {\n      transform: \"translate(\" + R + \", \" + q + \") rotate(\" + V + \")\",\n      textAnchor: G,\n      dominantBaseline: D,\n      style: I.legends.title.text,\n      children: P\n    }), t(\"rect\", {\n      width: Y,\n      height: H,\n      fill: \"url(#\" + N\n    }), M.map(function (i, n) {\n      return e(c, {\n        children: [t(\"line\", {\n          x1: i.x1,\n          y1: i.y1,\n          x2: i.x2,\n          y2: i.y2,\n          style: I.legends.ticks.line\n        }), t(\"text\", {\n          x: i.textX,\n          y: i.textY,\n          textAnchor: i.textHorizontalAlign,\n          dominantBaseline: i.textVerticalAlign,\n          style: I.legends.ticks.text,\n          children: i.text\n        })]\n      }, n);\n    })]\n  });\n},\n    z = [\"containerWidth\", \"containerHeight\", \"anchor\", \"translateX\", \"translateY\", \"length\", \"thickness\", \"direction\"],\n    C = function C(e) {\n  var i,\n      n,\n      o = e.containerWidth,\n      r = e.containerHeight,\n      l = e.anchor,\n      a = e.translateX,\n      c = void 0 === a ? 0 : a,\n      s = e.translateY,\n      d = void 0 === s ? 0 : s,\n      h = e.length,\n      g = void 0 === h ? y.length : h,\n      m = e.thickness,\n      f = void 0 === m ? y.thickness : m,\n      u = e.direction,\n      v = void 0 === u ? y.direction : u,\n      b = function (t, e) {\n    if (null == t) return {};\n    var i,\n        n,\n        o = {},\n        r = Object.keys(t);\n\n    for (n = 0; n < r.length; n++) {\n      i = r[n], e.indexOf(i) >= 0 || (o[i] = t[i]);\n    }\n\n    return o;\n  }(e, z);\n\n  \"row\" === v ? (i = g, n = f) : (i = f, n = g);\n  var k = x({\n    anchor: l,\n    translateX: c,\n    translateY: d,\n    containerWidth: o,\n    containerHeight: r,\n    width: i,\n    height: n\n  }),\n      S = k.x,\n      A = k.y;\n  return t(\"g\", {\n    transform: \"translate(\" + S + \", \" + A + \")\",\n    children: t(W, p({\n      length: g,\n      thickness: f,\n      direction: v\n    }, b))\n  });\n},\n    O = {\n  circle: m,\n  diamond: f,\n  square: u,\n  triangle: v\n},\n    B = function B(i) {\n  var n,\n      r,\n      l,\n      c,\n      h,\n      g,\n      m,\n      f,\n      u,\n      v,\n      y,\n      b = i.x,\n      k = i.y,\n      x = i.width,\n      A = i.height,\n      W = i.data,\n      z = i.direction,\n      C = void 0 === z ? \"left-to-right\" : z,\n      B = i.justify,\n      w = void 0 !== B && B,\n      X = i.textColor,\n      Y = i.background,\n      H = void 0 === Y ? \"transparent\" : Y,\n      E = i.opacity,\n      j = void 0 === E ? 1 : E,\n      T = i.symbolShape,\n      L = void 0 === T ? \"square\" : T,\n      M = i.symbolSize,\n      F = void 0 === M ? 16 : M,\n      P = i.symbolSpacing,\n      R = void 0 === P ? 8 : P,\n      q = i.symbolBorderWidth,\n      V = void 0 === q ? 0 : q,\n      D = i.symbolBorderColor,\n      G = void 0 === D ? \"transparent\" : D,\n      I = i.onClick,\n      N = i.onMouseEnter,\n      _ = i.onMouseLeave,\n      J = i.toggleSerie,\n      K = i.effects,\n      Q = s({}),\n      U = Q[0],\n      Z = Q[1],\n      $ = o(),\n      tt = d(function (t) {\n    if (K) {\n      var e = K.filter(function (t) {\n        return \"hover\" === t.on;\n      }).reduce(function (t, e) {\n        return p({}, t, e.style);\n      }, {});\n      Z(e);\n    }\n\n    null == N || N(W, t);\n  }, [N, W, K]),\n      et = d(function (t) {\n    if (K) {\n      var e = K.filter(function (t) {\n        return \"hover\" !== t.on;\n      }).reduce(function (t, e) {\n        return p({}, t, e.style);\n      }, {});\n      Z(e);\n    }\n\n    null == _ || _(W, t);\n  }, [_, W, K]),\n      it = S({\n    direction: C,\n    justify: w,\n    symbolSize: null != (n = U.symbolSize) ? n : F,\n    symbolSpacing: R,\n    width: x,\n    height: A\n  }),\n      nt = it.symbolX,\n      ot = it.symbolY,\n      rt = it.labelX,\n      lt = it.labelY,\n      at = it.labelAnchor,\n      ct = it.labelAlignment,\n      st = [I, N, _, J].some(function (t) {\n    return void 0 !== t;\n  }),\n      dt = \"function\" == typeof L ? L : O[L];\n  return e(\"g\", {\n    transform: \"translate(\" + b + \",\" + k + \")\",\n    style: {\n      opacity: null != (r = U.itemOpacity) ? r : j\n    },\n    children: [t(\"rect\", {\n      width: x,\n      height: A,\n      fill: null != (l = U.itemBackground) ? l : H,\n      style: {\n        cursor: st ? \"pointer\" : \"auto\"\n      },\n      onClick: function onClick(t) {\n        null == I || I(W, t), null == J || J(W.id);\n      },\n      onMouseEnter: tt,\n      onMouseLeave: et\n    }), a.createElement(dt, p({\n      id: W.id,\n      x: nt,\n      y: ot,\n      size: null != (c = U.symbolSize) ? c : F,\n      fill: null != (h = null != (g = W.fill) ? g : W.color) ? h : \"black\",\n      borderWidth: null != (m = U.symbolBorderWidth) ? m : V,\n      borderColor: null != (f = U.symbolBorderColor) ? f : G\n    }, W.hidden ? $.legends.hidden.symbol : void 0)), t(\"text\", {\n      textAnchor: at,\n      style: p({}, $.legends.text, {\n        fill: null != (u = null != (v = null != (y = U.itemTextColor) ? y : X) ? v : $.legends.text.fill) ? u : \"black\",\n        dominantBaseline: ct,\n        pointerEvents: \"none\",\n        userSelect: \"none\"\n      }, W.hidden ? $.legends.hidden.text : void 0),\n      x: rt,\n      y: lt,\n      children: W.label\n    })]\n  });\n},\n    w = function w(e) {\n  var i = e.data,\n      n = e.x,\n      o = e.y,\n      r = e.direction,\n      l = e.padding,\n      a = void 0 === l ? 0 : l,\n      c = e.justify,\n      s = e.effects,\n      d = e.itemWidth,\n      h = e.itemHeight,\n      g = e.itemDirection,\n      m = void 0 === g ? \"left-to-right\" : g,\n      f = e.itemsSpacing,\n      u = void 0 === f ? 0 : f,\n      v = e.itemTextColor,\n      p = e.itemBackground,\n      y = void 0 === p ? \"transparent\" : p,\n      b = e.itemOpacity,\n      x = void 0 === b ? 1 : b,\n      S = e.symbolShape,\n      A = e.symbolSize,\n      W = e.symbolSpacing,\n      z = e.symbolBorderWidth,\n      C = e.symbolBorderColor,\n      O = e.onClick,\n      w = e.onMouseEnter,\n      X = e.onMouseLeave,\n      Y = e.toggleSerie,\n      H = k({\n    itemCount: i.length,\n    itemWidth: d,\n    itemHeight: h,\n    itemsSpacing: u,\n    direction: r,\n    padding: a\n  }).padding,\n      E = \"row\" === r ? d + u : 0,\n      j = \"column\" === r ? h + u : 0;\n  return t(\"g\", {\n    transform: \"translate(\" + n + \",\" + o + \")\",\n    children: i.map(function (e, i) {\n      return t(B, {\n        data: e,\n        x: i * E + H.left,\n        y: i * j + H.top,\n        width: d,\n        height: h,\n        direction: m,\n        justify: c,\n        effects: s,\n        textColor: v,\n        background: y,\n        opacity: x,\n        symbolShape: S,\n        symbolSize: A,\n        symbolSpacing: W,\n        symbolBorderWidth: z,\n        symbolBorderColor: C,\n        onClick: O,\n        onMouseEnter: w,\n        onMouseLeave: X,\n        toggleSerie: Y\n      }, i);\n    })\n  });\n},\n    X = function X(e) {\n  var i = e.data,\n      n = e.containerWidth,\n      o = e.containerHeight,\n      r = e.translateX,\n      l = void 0 === r ? 0 : r,\n      a = e.translateY,\n      c = void 0 === a ? 0 : a,\n      s = e.anchor,\n      d = e.direction,\n      h = e.padding,\n      g = void 0 === h ? 0 : h,\n      m = e.justify,\n      f = e.itemsSpacing,\n      u = void 0 === f ? 0 : f,\n      v = e.itemWidth,\n      p = e.itemHeight,\n      y = e.itemDirection,\n      b = e.itemTextColor,\n      S = e.itemBackground,\n      A = e.itemOpacity,\n      W = e.symbolShape,\n      z = e.symbolSize,\n      C = e.symbolSpacing,\n      O = e.symbolBorderWidth,\n      B = e.symbolBorderColor,\n      X = e.onClick,\n      Y = e.onMouseEnter,\n      H = e.onMouseLeave,\n      E = e.toggleSerie,\n      j = e.effects,\n      T = k({\n    itemCount: i.length,\n    itemsSpacing: u,\n    itemWidth: v,\n    itemHeight: p,\n    direction: d,\n    padding: g\n  }),\n      L = T.width,\n      M = T.height,\n      F = x({\n    anchor: s,\n    translateX: l,\n    translateY: c,\n    containerWidth: n,\n    containerHeight: o,\n    width: L,\n    height: M\n  }),\n      P = F.x,\n      R = F.y;\n  return t(w, {\n    data: i,\n    x: P,\n    y: R,\n    direction: d,\n    padding: g,\n    justify: m,\n    effects: j,\n    itemsSpacing: u,\n    itemWidth: v,\n    itemHeight: p,\n    itemDirection: y,\n    itemTextColor: b,\n    itemBackground: S,\n    itemOpacity: A,\n    symbolShape: W,\n    symbolSize: z,\n    symbolSpacing: C,\n    symbolBorderWidth: O,\n    symbolBorderColor: B,\n    onClick: X,\n    onMouseEnter: Y,\n    onMouseLeave: H,\n    toggleSerie: \"boolean\" == typeof E ? void 0 : E\n  });\n},\n    Y = {\n  start: \"left\",\n  middle: \"center\",\n  end: \"right\"\n},\n    H = function H(t, e) {\n  var i = e.data,\n      n = e.containerWidth,\n      o = e.containerHeight,\n      r = e.translateX,\n      l = void 0 === r ? 0 : r,\n      a = e.translateY,\n      c = void 0 === a ? 0 : a,\n      s = e.anchor,\n      d = e.direction,\n      h = e.padding,\n      g = void 0 === h ? 0 : h,\n      m = e.justify,\n      f = void 0 !== m && m,\n      u = e.itemsSpacing,\n      v = void 0 === u ? 0 : u,\n      p = e.itemWidth,\n      y = e.itemHeight,\n      b = e.itemDirection,\n      A = void 0 === b ? \"left-to-right\" : b,\n      W = e.itemTextColor,\n      z = e.symbolSize,\n      C = void 0 === z ? 16 : z,\n      O = e.symbolSpacing,\n      B = void 0 === O ? 8 : O,\n      w = e.theme,\n      X = k({\n    itemCount: i.length,\n    itemWidth: p,\n    itemHeight: y,\n    itemsSpacing: v,\n    direction: d,\n    padding: g\n  }),\n      H = X.width,\n      E = X.height,\n      j = X.padding,\n      T = x({\n    anchor: s,\n    translateX: l,\n    translateY: c,\n    containerWidth: n,\n    containerHeight: o,\n    width: H,\n    height: E\n  }),\n      L = T.x,\n      M = T.y,\n      F = \"row\" === d ? p + v : 0,\n      P = \"column\" === d ? y + v : 0;\n  t.save(), t.translate(L, M), t.font = w.legends.text.fontSize + \"px \" + (w.legends.text.fontFamily || \"sans-serif\"), i.forEach(function (e, i) {\n    var n,\n        o,\n        r = i * F + j.left,\n        l = i * P + j.top,\n        a = S({\n      direction: A,\n      justify: f,\n      symbolSize: C,\n      symbolSpacing: B,\n      width: p,\n      height: y\n    }),\n        c = a.symbolX,\n        s = a.symbolY,\n        d = a.labelX,\n        h = a.labelY,\n        g = a.labelAnchor,\n        m = a.labelAlignment;\n    t.fillStyle = null != (n = e.color) ? n : \"black\", t.fillRect(r + c, l + s, C, C), t.textAlign = Y[g], \"central\" === m && (t.textBaseline = \"middle\"), t.fillStyle = null != (o = null != W ? W : w.legends.text.fill) ? o : \"black\", t.fillText(String(e.label), r + d, l + h);\n  }), t.restore();\n},\n    E = function E(t, e) {\n  var i = e.containerWidth,\n      n = e.containerHeight,\n      o = e.anchor,\n      l = e.translateX,\n      a = void 0 === l ? 0 : l,\n      c = e.translateY,\n      s = void 0 === c ? 0 : c,\n      d = e.scale,\n      h = e.length,\n      g = void 0 === h ? y.length : h,\n      m = e.thickness,\n      f = void 0 === m ? y.thickness : m,\n      u = e.direction,\n      v = void 0 === u ? y.direction : u,\n      p = e.ticks,\n      b = e.tickPosition,\n      k = void 0 === b ? y.tickPosition : b,\n      S = e.tickSize,\n      W = void 0 === S ? y.tickSize : S,\n      z = e.tickSpacing,\n      C = void 0 === z ? y.tickSpacing : z,\n      O = e.tickOverlap,\n      B = void 0 === O ? y.tickOverlap : O,\n      w = e.tickFormat,\n      X = void 0 === w ? y.tickFormat : w,\n      Y = e.title,\n      H = e.titleAlign,\n      E = void 0 === H ? y.titleAlign : H,\n      j = e.titleOffset,\n      T = void 0 === j ? y.titleOffset : j,\n      L = e.theme,\n      M = A({\n    scale: d,\n    ticks: p,\n    length: g,\n    thickness: f,\n    direction: v,\n    tickPosition: k,\n    tickSize: W,\n    tickSpacing: C,\n    tickOverlap: B,\n    tickFormat: X,\n    title: Y,\n    titleAlign: E,\n    titleOffset: T\n  }),\n      F = M.width,\n      P = M.height,\n      R = M.gradientX1,\n      q = M.gradientY1,\n      V = M.gradientX2,\n      D = M.gradientY2,\n      G = M.colorStops,\n      I = M.ticks,\n      N = M.titleText,\n      _ = M.titleX,\n      J = M.titleY,\n      K = M.titleRotation,\n      Q = M.titleVerticalAlign,\n      U = M.titleHorizontalAlign,\n      Z = x({\n    anchor: o,\n    translateX: a,\n    translateY: s,\n    containerWidth: i,\n    containerHeight: n,\n    width: F,\n    height: P\n  }),\n      $ = Z.x,\n      tt = Z.y,\n      et = {\n    font: t.font,\n    textAlign: t.textAlign,\n    textBaseline: t.textBaseline\n  };\n  t.save(), t.translate($, tt);\n  var it = t.createLinearGradient(R * F, q * P, V * F, D * P);\n  G.forEach(function (t) {\n    it.addColorStop(t.offset, t.stopColor);\n  }), t.fillStyle = it, t.fillRect(0, 0, F, P), t.font = (L.legends.ticks.text.fontWeight ? L.legends.ticks.text.fontWeight + \" \" : \"\") + L.legends.ticks.text.fontSize + \"px \" + L.legends.ticks.text.fontFamily, I.forEach(function (e) {\n    var i;\n    (null != (i = L.legends.ticks.line.strokeWidth) ? i : 0) > 0 && (t.lineWidth = Number(L.axis.ticks.line.strokeWidth), L.axis.ticks.line.stroke && (t.strokeStyle = L.axis.ticks.line.stroke), t.lineCap = \"square\", t.beginPath(), t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2), t.stroke()), L.legends.ticks.text.fill && (t.fillStyle = L.legends.ticks.text.fill), t.textAlign = \"middle\" === e.textHorizontalAlign ? \"center\" : e.textHorizontalAlign, t.textBaseline = \"central\" === e.textVerticalAlign ? \"middle\" : e.textVerticalAlign, t.fillText(e.text, e.textX, e.textY);\n  }), N && (t.save(), t.translate(_, J), t.rotate(r(K)), t.font = (L.legends.title.text.fontWeight ? L.legends.title.text.fontWeight + \" \" : \"\") + L.legends.title.text.fontSize + \"px \" + L.legends.title.text.fontFamily, L.legends.title.text.fill && (t.fillStyle = L.legends.title.text.fill), t.textAlign = \"middle\" === U ? \"center\" : U, t.textBaseline = Q, t.fillText(N, 0, 0), t.restore()), t.restore(), t.font = et.font, t.textAlign = et.textAlign, t.textBaseline = et.textBaseline;\n},\n    j = function j(t) {\n  var e = t.scale,\n      i = t.domain,\n      n = t.reverse,\n      o = void 0 !== n && n,\n      r = t.valueFormat,\n      l = void 0 === r ? function (t) {\n    return t;\n  } : r,\n      a = t.separator,\n      c = void 0 === a ? \" - \" : a;\n  return h(function () {\n    var t = (null != i ? i : e.range()).map(function (t, i) {\n      var n = e.invertExtent(t),\n          o = n[0],\n          r = n[1];\n      return {\n        id: t,\n        index: i,\n        extent: [o, r],\n        label: \"\" + l(o) + c + l(r),\n        value: e(o),\n        color: t\n      };\n    });\n    return o && t.reverse(), t;\n  }, [i, e, o, c, l]);\n},\n    T = {\n  data: g.arrayOf(g.object),\n  anchor: g.oneOf([\"top\", \"top-right\", \"right\", \"bottom-right\", \"bottom\", \"bottom-left\", \"left\", \"top-left\", \"center\"]).isRequired,\n  translateX: g.number,\n  translateY: g.number,\n  direction: g.oneOf([\"row\", \"column\"]).isRequired,\n  itemsSpacing: g.number,\n  itemWidth: g.number.isRequired,\n  itemHeight: g.number.isRequired,\n  itemDirection: g.oneOf([\"left-to-right\", \"right-to-left\", \"top-to-bottom\", \"bottom-to-top\"]),\n  itemTextColor: g.string,\n  itemBackground: g.string,\n  itemOpacity: g.number,\n  symbolShape: g.oneOfType([g.oneOf([\"circle\", \"diamond\", \"square\", \"triangle\"]), g.func]),\n  symbolSize: g.number,\n  symbolSpacing: g.number,\n  symbolBorderWidth: g.number,\n  symbolBorderColor: g.string,\n  onClick: g.func,\n  onMouseEnter: g.func,\n  onMouseLeave: g.func,\n  effects: g.arrayOf(g.shape({\n    on: g.oneOfType([g.oneOf([\"hover\"])]).isRequired,\n    style: g.shape({\n      itemTextColor: g.string,\n      itemBackground: g.string,\n      itemOpacity: g.number,\n      symbolSize: g.number,\n      symbolBorderWidth: g.number,\n      symbolBorderColor: g.string\n    }).isRequired\n  }))\n};\n\nexport { C as AnchoredContinuousColorsLegendSvg, X as BoxLegendSvg, W as ContinuousColorsLegendSvg, T as LegendPropShape, w as LegendSvg, B as LegendSvgItem, m as SymbolCircle, f as SymbolDiamond, u as SymbolSquare, v as SymbolTriangle, A as computeContinuousColorsLegend, k as computeDimensions, S as computeItemLayout, x as computePositionFromAnchor, y as continuousColorsLegendDefaults, E as renderContinuousColorLegendToCanvas, H as renderLegendToCanvas, j as useQuantizeColorScaleLegendData };","map":null,"metadata":{},"sourceType":"module"}