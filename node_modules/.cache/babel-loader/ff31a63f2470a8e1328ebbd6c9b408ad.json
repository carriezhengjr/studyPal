{"ast":null,"code":"var _toConsumableArray = require(\"/Users/ongyongen/Desktop/studyPal-local/studyPal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/ongyongen/Desktop/studyPal-local/studyPal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _defineProperty = require(\"/Users/ongyongen/Desktop/studyPal-local/studyPal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/ongyongen/Desktop/studyPal-local/studyPal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ongyongen/Desktop/studyPal-local/studyPal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/ongyongen/Desktop/studyPal-local/studyPal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/ongyongen/Desktop/studyPal-local/studyPal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/ongyongen/Desktop/studyPal-local/studyPal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e3) { throw _e3; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e4) { didErr = true; err = _e4; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react/jsx-runtime'), require('react'), require('rdk'), require('ellipsize'), require('d3-array'), require('calculate-size'), require('d3-scale'), require('memoize-bind'), require('transformation-matrix'), require('classnames'), require('react-cool-dimensions'), require('big-integer'), require('human-format'), require('d3-shape'), require('chroma-js'), require('realayers'), require('memoize-one'), require('react-fast-compare'), require('framer-motion'), require('d3-interpolate'), require('d3-geo'), require('d3-sankey'), require('@upsetjs/venn.js'), require('invert-color'), require('d3-hierarchy')) : typeof define === 'function' && define.amd ? define(['exports', 'react/jsx-runtime', 'react', 'rdk', 'ellipsize', 'd3-array', 'calculate-size', 'd3-scale', 'memoize-bind', 'transformation-matrix', 'classnames', 'react-cool-dimensions', 'big-integer', 'human-format', 'd3-shape', 'chroma-js', 'realayers', 'memoize-one', 'react-fast-compare', 'framer-motion', 'd3-interpolate', 'd3-geo', 'd3-sankey', '@upsetjs/venn.js', 'invert-color', 'd3-hierarchy'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.reaviz = {}, global.jsxRuntime, global.react, global.rdk, global.ellipsize, global.d3Array, global.calculateSize, global.d3Scale, global.bind, global.transformationMatrix, global.classNames, global.useDimensions, global.bigInt, global.humanFormat, global.d3Shape, global.chroma, global.realayers, global.memoize, global.isEqual, global.framerMotion, global.d3Interpolate, global.d3Geo, global.d3Sankey, global.venn_js, global.invert, global.d3Hierarchy));\n})(this, function (exports, jsxRuntime, react, rdk, ellipsize, d3Array, calculateSize, d3Scale, bind, transformationMatrix, classNames, useDimensions, bigInt, humanFormat, d3Shape, chroma, realayers, memoize, isEqual, framerMotion, d3Interpolate, d3Geo, d3Sankey, venn_js, invert, d3Hierarchy) {\n  'use strict';\n\n  function _interopDefaultLegacy(e) {\n    return e && typeof e === 'object' && 'default' in e ? e : {\n      'default': e\n    };\n  }\n\n  var ellipsize__default = /*#__PURE__*/_interopDefaultLegacy(ellipsize);\n\n  var calculateSize__default = /*#__PURE__*/_interopDefaultLegacy(calculateSize);\n\n  var bind__default = /*#__PURE__*/_interopDefaultLegacy(bind);\n\n  var classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);\n\n  var useDimensions__default = /*#__PURE__*/_interopDefaultLegacy(useDimensions);\n\n  var bigInt__default = /*#__PURE__*/_interopDefaultLegacy(bigInt);\n\n  var humanFormat__default = /*#__PURE__*/_interopDefaultLegacy(humanFormat);\n\n  var chroma__default = /*#__PURE__*/_interopDefaultLegacy(chroma);\n\n  var memoize__default = /*#__PURE__*/_interopDefaultLegacy(memoize);\n\n  var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);\n\n  var invert__default = /*#__PURE__*/_interopDefaultLegacy(invert);\n\n  var LinearAxisTickLabel = /*#__PURE__*/function (_react$Component) {\n    _inherits(LinearAxisTickLabel, _react$Component);\n\n    function LinearAxisTickLabel() {\n      _classCallCheck(this, LinearAxisTickLabel);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(LinearAxisTickLabel).apply(this, arguments));\n    }\n\n    _createClass(LinearAxisTickLabel, [{\n      key: \"getAlign\",\n      value: function getAlign() {\n        var _this$props = this.props,\n            align = _this$props.align,\n            half = _this$props.half;\n\n        if ((align === 'inside' || align === 'outside') && half === 'center') {\n          return 'center';\n        }\n\n        if (align === 'inside') {\n          return half === 'start' ? 'end' : 'start';\n        }\n\n        if (align === 'outside') {\n          return half === 'start' ? 'start' : 'end';\n        }\n\n        return align;\n      }\n    }, {\n      key: \"getTickLineSpacing\",\n      value: function getTickLineSpacing() {\n        var line = this.props.line;\n\n        if (!line) {\n          return [0, 0];\n        }\n\n        var size = line.props.size;\n        var position = line.props.position;\n\n        if (position === 'start') {\n          return [size * -1, 0];\n        } else if (position === 'end') {\n          return [0, size];\n        } else {\n          return [size * -0.5, size * 0.5];\n        }\n      }\n    }, {\n      key: \"getOffset\",\n      value: function getOffset() {\n        var _ref;\n\n        var _this$props2 = this.props,\n            padding = _this$props2.padding,\n            position = _this$props2.position,\n            rotation = _this$props2.rotation,\n            orientation = _this$props2.orientation;\n        var adjustedPadding = typeof padding === 'number' ? {\n          fromAxis: padding,\n          alongAxis: padding\n        } : padding;\n        var spacing = this.getTickLineSpacing();\n        var offset1 = position === 'start' ? spacing[0] - adjustedPadding.fromAxis : position === 'end' ? spacing[1] + adjustedPadding.fromAxis : 0;\n        var align = this.getAlign();\n        var offset2 = rotation === true ? -5 : 0;\n        offset2 += align === 'center' ? 0 : align === 'start' ? -adjustedPadding.alongAxis : adjustedPadding.alongAxis;\n        var horz = orientation === 'horizontal';\n        return _ref = {}, _defineProperty(_ref, horz ? 'x' : 'y', offset2), _defineProperty(_ref, horz ? 'y' : 'x', offset1), _ref;\n      }\n    }, {\n      key: \"getTextPosition\",\n      value: function getTextPosition() {\n        var _this$props3 = this.props,\n            angle = _this$props3.angle,\n            orientation = _this$props3.orientation,\n            position = _this$props3.position;\n        var transform = '';\n        var textAnchor = '';\n        var alignmentBaseline = 'middle';\n\n        if (angle !== 0) {\n          transform = \"rotate(\".concat(angle, \")\");\n          textAnchor = 'end';\n        } else {\n          var align = this.getAlign();\n\n          if (orientation === 'horizontal') {\n            textAnchor = align === 'center' ? 'middle' : align === 'start' ? 'end' : 'start';\n\n            if (position === 'start') {\n              alignmentBaseline = 'baseline';\n            } else if (position === 'end') {\n              alignmentBaseline = 'hanging';\n            }\n          } else {\n            alignmentBaseline = align === 'center' ? 'middle' : align === 'start' ? 'baseline' : 'hanging';\n\n            if (position === 'start') {\n              textAnchor = 'end';\n            } else if (position === 'end') {\n              textAnchor = 'start';\n            } else {\n              textAnchor = 'middle';\n            }\n          }\n        }\n\n        return {\n          transform: transform,\n          textAnchor: this.props.textAnchor || textAnchor,\n          alignmentBaseline: alignmentBaseline\n        };\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props4 = this.props,\n            fill = _this$props4.fill,\n            text = _this$props4.text,\n            fullText = _this$props4.fullText,\n            fontSize = _this$props4.fontSize,\n            fontFamily = _this$props4.fontFamily,\n            className = _this$props4.className;\n\n        var _this$getOffset = this.getOffset(),\n            x = _this$getOffset.x,\n            y = _this$getOffset.y;\n\n        var textPosition = this.getTextPosition();\n        return jsxRuntime.jsxs(\"g\", Object.assign({\n          transform: \"translate(\".concat(x, \", \").concat(y, \")\"),\n          fontSize: fontSize,\n          fontFamily: fontFamily\n        }, {\n          children: [jsxRuntime.jsx(\"title\", {\n            children: fullText\n          }, void 0), jsxRuntime.jsx(\"text\", Object.assign({}, textPosition, {\n            fill: fill,\n            className: className\n          }, {\n            children: text\n          }), void 0)]\n        }), void 0);\n      }\n    }]);\n\n    return LinearAxisTickLabel;\n  }(react.Component);\n\n  LinearAxisTickLabel.defaultProps = {\n    fill: '#8F979F',\n    fontSize: 11,\n    fontFamily: 'sans-serif',\n    rotation: true,\n    padding: 0,\n    align: 'center'\n  };\n\n  var LinearAxisTickLine = /*#__PURE__*/function (_react$PureComponent) {\n    _inherits(LinearAxisTickLine, _react$PureComponent);\n\n    function LinearAxisTickLine() {\n      _classCallCheck(this, LinearAxisTickLine);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(LinearAxisTickLine).apply(this, arguments));\n    }\n\n    _createClass(LinearAxisTickLine, [{\n      key: \"positionTick\",\n      value: function positionTick() {\n        var _this$props5 = this.props,\n            size = _this$props5.size,\n            position = _this$props5.position,\n            orientation = _this$props5.orientation;\n        var isVertical = orientation === 'vertical';\n        var tickSize = size || 0;\n        var start = position === 'start' ? tickSize * -1 : position === 'center' ? tickSize * -0.5 : 0;\n        var end = start + tickSize;\n        return {\n          x1: isVertical ? end : 0,\n          x2: isVertical ? start : 0,\n          y1: isVertical ? 0 : start,\n          y2: isVertical ? 0 : end\n        };\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props6 = this.props,\n            strokeColor = _this$props6.strokeColor,\n            strokeWidth = _this$props6.strokeWidth,\n            className = _this$props6.className;\n        var path = this.positionTick();\n        return jsxRuntime.jsx(\"line\", Object.assign({\n          className: className,\n          strokeWidth: strokeWidth,\n          stroke: strokeColor\n        }, path), void 0);\n      }\n    }]);\n\n    return LinearAxisTickLine;\n  }(react.PureComponent);\n\n  LinearAxisTickLine.defaultProps = {\n    strokeColor: '#8F979F',\n    strokeWidth: 1,\n    size: 5\n  }; // https://stackoverflow.com/questions/673905/best-way-to-determine-users-locale-within-browser\n\n  var getNavigatorLanguage = function getNavigatorLanguage() {\n    if (typeof window === 'undefined') {\n      return 'en';\n    }\n\n    if (navigator.languages && navigator.languages.length) {\n      return navigator.languages[0];\n    }\n\n    if (navigator.userLanguage || navigator.language || navigator.browserLanguage) {\n      return 'en';\n    }\n  };\n\n  var locale = getNavigatorLanguage();\n  var options = {\n    year: 'numeric',\n    month: 'numeric',\n    day: 'numeric',\n    hour12: true,\n    formatMatcher: 'best fit'\n  };\n  /**\r\n   * Format a value based on type.\r\n   */\n\n  function formatValue(value) {\n    if (value !== undefined) {\n      if (value instanceof Date) {\n        return value.toLocaleDateString(locale, options);\n      } else if (typeof value === 'number') {\n        return value.toLocaleString();\n      }\n\n      return value;\n    }\n\n    return 'No value';\n  }\n\n  var ONE_DAY = 60 * 60 * 24;\n  var DURATION_TICK_STEPS = [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5, 10, 15, 60, 60 * 15, 60 * 30, 60 * 60, 60 * 60 * 2, 60 * 60 * 4, 60 * 60 * 6, 60 * 60 * 8, 60 * 60 * 12, ONE_DAY // 24 h\n  ];\n  /**\r\n   * Reduce the ticks to the max number of ticks.\r\n   */\n\n  function reduceTicks(ticks, maxTicks) {\n    if (ticks.length > maxTicks) {\n      var reduced = [];\n      var modulus = Math.floor(ticks.length / maxTicks);\n\n      for (var i = 0; i < ticks.length; i++) {\n        if (i % modulus === 0) {\n          reduced.push(ticks[i]);\n        }\n      }\n\n      ticks = reduced;\n    }\n\n    return ticks;\n  }\n  /**\r\n   * Determine the max ticks for the available width.\r\n   */\n\n\n  function getMaxTicks(size, dimension) {\n    var tickWidth = Math.max(size, 0);\n    return Math.floor(dimension / tickWidth);\n  }\n  /**\r\n   * Formats the ticks in a duration format.\r\n   */\n\n\n  function getDurationTicks(domain, maxTicks) {\n    var domainWidth = domain[1] - domain[0];\n    var tickStep = null;\n\n    var _iterator = _createForOfIteratorHelper(DURATION_TICK_STEPS),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var s = _step.value;\n\n        if (domainWidth / s < maxTicks) {\n          tickStep = s;\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (tickStep === null) {\n      var numDayTicks = domainWidth / ONE_DAY;\n      var dayStep = Math.ceil(numDayTicks / maxTicks);\n      tickStep = ONE_DAY * dayStep;\n    }\n\n    var ticks = [domain[0]];\n\n    while (ticks[ticks.length - 1] + tickStep <= domain[1]) {\n      ticks.push(ticks[ticks.length - 1] + tickStep);\n    }\n\n    return ticks;\n  }\n  /**\r\n   * Get the tick values from the scale.\r\n   */\n\n\n  function _getTicks(scale, tickValues, type) {\n    var maxTicks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n    var interval = arguments.length > 4 ? arguments[4] : undefined;\n    var result;\n\n    if (tickValues) {\n      result = tickValues;\n    } else {\n      if (scale.ticks) {\n        if (type === 'duration') {\n          result = getDurationTicks(scale.domain(), maxTicks);\n        } else if (interval) {\n          result = scale.ticks(interval);\n        } else {\n          if (type === 'time') {\n            // If its time, we need to handle the time count\n            // manually because d3 does this odd rounding\n            result = scale.ticks();\n            result = reduceTicks(result, maxTicks);\n          } else {\n            result = scale.ticks(maxTicks);\n          }\n        }\n      } else {\n        tickValues = scale.domain();\n        result = reduceTicks(tickValues, maxTicks);\n      }\n    }\n\n    return result;\n  }\n\n  var calculateDimensions = function calculateDimensions(text, fontFamily, fontSize) {\n    // SSR Rendering doesn't support canvas measurements\n    // we have to make a guess in this case...\n    if (typeof document === 'undefined') {\n      return {\n        width: text.length * 8,\n        height: 25\n      };\n    }\n\n    return calculateSize__default['default'](text, {\n      font: fontFamily,\n      fontSize: \"\".concat(fontSize, \"px\")\n    });\n  };\n\n  var LinearAxisTickSeries = /*#__PURE__*/function (_react$Component2) {\n    _inherits(LinearAxisTickSeries, _react$Component2);\n\n    function LinearAxisTickSeries() {\n      _classCallCheck(this, LinearAxisTickSeries);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(LinearAxisTickSeries).apply(this, arguments));\n    }\n\n    _createClass(LinearAxisTickSeries, [{\n      key: \"getAdjustedScale\",\n\n      /**\r\n       * Gets the adjusted scale given offsets.\r\n       */\n      value: function getAdjustedScale() {\n        var scale = this.props.scale;\n\n        if (scale.bandwidth) {\n          var offset = scale.bandwidth() / 2;\n\n          if (scale.round()) {\n            offset = Math.round(offset);\n          }\n\n          return function (d) {\n            return +scale(d) + offset;\n          };\n        } else {\n          return function (d) {\n            return +scale(d);\n          };\n        }\n      }\n      /**\r\n       * Gets the x/y position for a given tick.\r\n       */\n\n    }, {\n      key: \"getPosition\",\n      value: function getPosition(scaledTick) {\n        var orientation = this.props.orientation;\n\n        if (orientation === 'horizontal') {\n          return {\n            x: scaledTick,\n            y: 0\n          };\n        } else {\n          return {\n            x: 0,\n            y: scaledTick\n          };\n        }\n      }\n      /**\r\n       * Gets the dimension (height/width) this axis is calculating on.\r\n       */\n\n    }, {\n      key: \"getDimension\",\n      value: function getDimension() {\n        var _this$props7 = this.props,\n            height = _this$props7.height,\n            width = _this$props7.width,\n            orientation = _this$props7.orientation;\n        return orientation === 'vertical' ? height : width;\n      }\n      /**\r\n       * Calculates the rotation angle that the ticks need to be shifted to.\r\n       * This equation will measure the length of the text in a external canvas\r\n       * object and determine what the longest label is and rotate until they fit.\r\n       */\n\n    }, {\n      key: \"getRotationAngle\",\n      value: function getRotationAngle(ticks) {\n        if (!this.props.label) {\n          return 0;\n        }\n\n        var label = this.props.label.props;\n        var dimension = this.getDimension();\n        var maxTicksLength = d3Array.max(ticks, function (tick) {\n          return tick.width;\n        });\n        var angle = 0;\n\n        if (label.rotation) {\n          if (label.rotation === true) {\n            var baseWidth = maxTicksLength;\n            var maxBaseWidth = Math.floor(dimension / ticks.length);\n\n            while (baseWidth > maxBaseWidth && angle > -90) {\n              angle -= 30;\n              baseWidth = Math.cos(angle * (Math.PI / 180)) * maxTicksLength;\n            }\n          } else {\n            angle = label.rotation;\n          }\n        }\n\n        return angle;\n      }\n      /**\r\n       * Gets the formatted label of the tick.\r\n       */\n\n    }, {\n      key: \"getLabelFormat\",\n      value: function getLabelFormat() {\n        var _this$props8 = this.props,\n            label = _this$props8.label,\n            scale = _this$props8.scale;\n\n        if (label && label.props.format) {\n          return label.props.format;\n        } else if (scale.tickFormat) {\n          return scale.tickFormat.apply(scale, [5]);\n        } else {\n          return function (v) {\n            return formatValue(v);\n          };\n        }\n      }\n      /**\r\n       * Gets the ticks given the dimensions and scales and returns\r\n       * the text and position.\r\n       */\n\n    }, {\n      key: \"getTicks\",\n      value: function getTicks() {\n        var _this = this;\n\n        var _this$props9 = this.props,\n            scale = _this$props9.scale,\n            tickSize = _this$props9.tickSize,\n            tickValues = _this$props9.tickValues,\n            interval = _this$props9.interval,\n            axis = _this$props9.axis,\n            label = _this$props9.label;\n        var dimension = this.getDimension();\n        var maxTicks = getMaxTicks(tickSize, dimension);\n\n        var ticks = _getTicks(scale, tickValues, axis.type, maxTicks, interval);\n\n        var adjustedScale = this.getAdjustedScale();\n        var format = this.getLabelFormat();\n        var midpoint = dimension / 2;\n        return ticks.map(function (tick) {\n          var fullText = format(tick);\n          var scaledTick = adjustedScale(tick);\n\n          var position = _this.getPosition(scaledTick);\n\n          var text = ellipsize__default['default'](fullText, 18);\n          var size = label ? calculateDimensions(text, label.props.fontFamily, label.props.fontSize.toString()) : {};\n          return Object.assign(Object.assign(Object.assign({}, position), size), {\n            text: text,\n            fullText: fullText,\n            half: scaledTick === midpoint ? 'center' : scaledTick < midpoint ? 'start' : 'end'\n          });\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props10 = this.props,\n            label = _this$props10.label,\n            line = _this$props10.line,\n            height = _this$props10.height,\n            width = _this$props10.width,\n            orientation = _this$props10.orientation;\n        var ticks = this.getTicks();\n        var angle = this.getRotationAngle(ticks);\n        return jsxRuntime.jsx(react.Fragment, {\n          children: ticks.map(function (tick, i) {\n            return jsxRuntime.jsxs(\"g\", Object.assign({\n              transform: \"translate(\".concat(tick.x, \", \").concat(tick.y, \")\")\n            }, {\n              children: [line && jsxRuntime.jsx(rdk.CloneElement, {\n                element: line,\n                height: height,\n                width: width,\n                orientation: orientation\n              }, void 0), label && jsxRuntime.jsx(rdk.CloneElement, {\n                element: label,\n                text: tick.text,\n                fullText: tick.fullText,\n                half: tick.half,\n                angle: angle,\n                orientation: orientation,\n                line: line\n              }, void 0)]\n            }), i);\n          })\n        }, void 0);\n      }\n    }]);\n\n    return LinearAxisTickSeries;\n  }(react.Component);\n\n  LinearAxisTickSeries.defaultProps = {\n    line: jsxRuntime.jsx(LinearAxisTickLine, {}, void 0),\n    label: jsxRuntime.jsx(LinearAxisTickLabel, {}, void 0),\n    tickSize: 30\n  };\n\n  var LinearAxisLine = function LinearAxisLine(_ref2) {\n    var strokeColor = _ref2.strokeColor,\n        strokeWidth = _ref2.strokeWidth,\n        strokeGradient = _ref2.strokeGradient,\n        scale = _ref2.scale,\n        orientation = _ref2.orientation,\n        className = _ref2.className;\n    var id = rdk.useId();\n\n    var _scale$range = scale.range(),\n        _scale$range2 = _slicedToArray(_scale$range, 2),\n        range0 = _scale$range2[0],\n        range1 = _scale$range2[1];\n\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [jsxRuntime.jsx(\"line\", {\n        className: className,\n        x1: orientation === 'vertical' ? 0 : range0,\n        // Workaround for a Chrome/Firefox bug where it won't render gradients for straight lines\n        x2: orientation === 'vertical' ? 0.00001 : range1,\n        y1: orientation === 'vertical' ? range0 : 0,\n        y2: orientation === 'vertical' ? range1 : 0.00001,\n        strokeWidth: strokeWidth,\n        stroke: strokeGradient ? \"url(#axis-gradient-\".concat(id, \")\") : strokeColor\n      }, void 0), strokeGradient && jsxRuntime.jsx(rdk.CloneElement, {\n        element: strokeGradient,\n        id: \"axis-gradient-\".concat(id)\n      }, void 0)]\n    }, void 0);\n  };\n\n  LinearAxisLine.defaultProps = {\n    strokeColor: '#8F979F',\n    strokeWidth: 1\n  };\n\n  var LinearAxis = /*#__PURE__*/function (_react$Component3) {\n    _inherits(LinearAxis, _react$Component3);\n\n    function LinearAxis(props) {\n      var _this2;\n\n      _classCallCheck(this, LinearAxis);\n\n      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(LinearAxis).call(this, props));\n      _this2.ref = react.createRef();\n      _this2.state = {\n        height: props.height,\n        width: props.width\n      };\n      return _this2;\n    }\n\n    _createClass(LinearAxis, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        this.updateDimensions();\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        var _this$props11 = this.props,\n            height = _this$props11.height,\n            width = _this$props11.width,\n            scale = _this$props11.scale;\n\n        if (width !== prevProps.width || height !== prevProps.height || scale !== prevProps.scale) {\n          this.updateDimensions();\n        }\n      }\n    }, {\n      key: \"updateDimensions\",\n      value: function updateDimensions() {\n        var _this$props12 = this.props,\n            onDimensionsChange = _this$props12.onDimensionsChange,\n            orientation = _this$props12.orientation,\n            position = _this$props12.position;\n        var shouldOffset = position !== 'center';\n        var height;\n        var width;\n\n        if (shouldOffset) {\n          var dims = this.ref.current.getBoundingClientRect();\n          width = Math.floor(dims.width);\n          height = Math.floor(dims.height);\n        }\n\n        if (orientation === 'vertical') {\n          if (this.state.width !== width) {\n            this.setState({\n              width: width\n            });\n            onDimensionsChange({\n              width: width\n            });\n          }\n        } else {\n          if (this.state.height !== height) {\n            this.setState({\n              height: height\n            });\n            onDimensionsChange({\n              height: height\n            });\n          }\n        }\n      }\n    }, {\n      key: \"getPosition\",\n      value: function getPosition() {\n        var _this$props13 = this.props,\n            position = _this$props13.position,\n            width = _this$props13.width,\n            height = _this$props13.height,\n            orientation = _this$props13.orientation;\n        var translateY = 0;\n        var translateX = 0;\n\n        if (position === 'end' && orientation === 'horizontal') {\n          translateY = height;\n        } else if (position === 'center' && orientation === 'horizontal') {\n          translateY = height / 2;\n        } else if (position === 'end' && orientation === 'vertical') {\n          translateX = width;\n        } else if (position === 'center' && orientation === 'vertical') {\n          translateX = width / 2;\n        }\n\n        return {\n          translateX: translateX,\n          translateY: translateY\n        };\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props14 = this.props,\n            scale = _this$props14.scale,\n            height = _this$props14.height,\n            width = _this$props14.width,\n            orientation = _this$props14.orientation,\n            axisLine = _this$props14.axisLine,\n            tickSeries = _this$props14.tickSeries;\n\n        var _this$getPosition = this.getPosition(),\n            translateX = _this$getPosition.translateX,\n            translateY = _this$getPosition.translateY;\n\n        return jsxRuntime.jsxs(\"g\", Object.assign({\n          transform: \"translate(\".concat(translateX, \", \").concat(translateY, \")\"),\n          ref: this.ref\n        }, {\n          children: [axisLine && jsxRuntime.jsx(rdk.CloneElement, {\n            element: axisLine,\n            height: height,\n            width: width,\n            scale: scale,\n            orientation: orientation\n          }, void 0), (tickSeries.props.line || tickSeries.props.label) && jsxRuntime.jsx(rdk.CloneElement, {\n            element: tickSeries,\n            height: height,\n            width: width,\n            scale: scale,\n            orientation: orientation,\n            axis: this.props\n          }, void 0)]\n        }), void 0);\n      }\n    }]);\n\n    return LinearAxis;\n  }(react.Component);\n\n  LinearAxis.defaultProps = {\n    axisLine: jsxRuntime.jsx(LinearAxisLine, {}, void 0),\n    tickSeries: jsxRuntime.jsx(LinearAxisTickSeries, {}, void 0),\n    scaled: false,\n    roundDomains: false,\n    onDimensionsChange: function onDimensionsChange() {\n      return undefined;\n    }\n  };\n\n  var LinearXAxisTickLabel = /*#__PURE__*/function (_react$Component4) {\n    _inherits(LinearXAxisTickLabel, _react$Component4);\n\n    function LinearXAxisTickLabel() {\n      _classCallCheck(this, LinearXAxisTickLabel);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(LinearXAxisTickLabel).apply(this, arguments));\n    }\n\n    _createClass(LinearXAxisTickLabel, [{\n      key: \"render\",\n      value: function render() {\n        return jsxRuntime.jsx(LinearAxisTickLabel, Object.assign({}, this.props), void 0);\n      }\n    }]);\n\n    return LinearXAxisTickLabel;\n  }(react.Component);\n\n  LinearXAxisTickLabel.defaultProps = Object.assign(Object.assign({}, LinearAxisTickLabel.defaultProps), {\n    rotation: true,\n    position: 'end',\n    align: 'center'\n  });\n\n  var LinearXAxisTickLine = /*#__PURE__*/function (_react$Component5) {\n    _inherits(LinearXAxisTickLine, _react$Component5);\n\n    function LinearXAxisTickLine() {\n      _classCallCheck(this, LinearXAxisTickLine);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(LinearXAxisTickLine).apply(this, arguments));\n    }\n\n    _createClass(LinearXAxisTickLine, [{\n      key: \"render\",\n      value: function render() {\n        return jsxRuntime.jsx(LinearAxisTickLine, Object.assign({}, this.props), void 0);\n      }\n    }]);\n\n    return LinearXAxisTickLine;\n  }(react.Component);\n\n  LinearXAxisTickLine.defaultProps = Object.assign(Object.assign({}, LinearAxisTickLine.defaultProps), {\n    position: 'end'\n  });\n\n  var LinearXAxisTickSeries = /*#__PURE__*/function (_react$Component6) {\n    _inherits(LinearXAxisTickSeries, _react$Component6);\n\n    function LinearXAxisTickSeries() {\n      _classCallCheck(this, LinearXAxisTickSeries);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(LinearXAxisTickSeries).apply(this, arguments));\n    }\n\n    _createClass(LinearXAxisTickSeries, [{\n      key: \"render\",\n      value: function render() {\n        return jsxRuntime.jsx(LinearAxisTickSeries, Object.assign({}, this.props), void 0);\n      }\n    }]);\n\n    return LinearXAxisTickSeries;\n  }(react.Component);\n\n  LinearXAxisTickSeries.defaultProps = Object.assign(Object.assign({}, LinearAxisTickSeries.defaultProps), {\n    tickSize: 75,\n    line: jsxRuntime.jsx(LinearXAxisTickLine, {}, void 0),\n    label: jsxRuntime.jsx(LinearXAxisTickLabel, {}, void 0)\n  });\n\n  var LinearXAxis = /*#__PURE__*/function (_react$Component7) {\n    _inherits(LinearXAxis, _react$Component7);\n\n    function LinearXAxis() {\n      _classCallCheck(this, LinearXAxis);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(LinearXAxis).apply(this, arguments));\n    }\n\n    _createClass(LinearXAxis, [{\n      key: \"render\",\n      value: function render() {\n        return jsxRuntime.jsx(LinearAxis, Object.assign({}, this.props), void 0);\n      }\n    }]);\n\n    return LinearXAxis;\n  }(react.Component);\n\n  LinearXAxis.defaultProps = Object.assign(Object.assign({}, LinearAxis.defaultProps), {\n    position: 'end',\n    roundDomains: false,\n    scaled: false,\n    type: 'value',\n    orientation: 'horizontal',\n    tickSeries: jsxRuntime.jsx(LinearXAxisTickSeries, {}, void 0)\n  });\n\n  var LinearYAxisTickLabel = /*#__PURE__*/function (_react$Component8) {\n    _inherits(LinearYAxisTickLabel, _react$Component8);\n\n    function LinearYAxisTickLabel() {\n      _classCallCheck(this, LinearYAxisTickLabel);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(LinearYAxisTickLabel).apply(this, arguments));\n    }\n\n    _createClass(LinearYAxisTickLabel, [{\n      key: \"render\",\n      value: function render() {\n        return jsxRuntime.jsx(LinearAxisTickLabel, Object.assign({}, this.props), void 0);\n      }\n    }]);\n\n    return LinearYAxisTickLabel;\n  }(react.Component);\n\n  LinearYAxisTickLabel.defaultProps = Object.assign(Object.assign({}, LinearAxisTickLabel.defaultProps), {\n    rotation: false,\n    position: 'start',\n    align: 'center'\n  });\n\n  var LinearYAxisTickLine = /*#__PURE__*/function (_react$Component9) {\n    _inherits(LinearYAxisTickLine, _react$Component9);\n\n    function LinearYAxisTickLine() {\n      _classCallCheck(this, LinearYAxisTickLine);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(LinearYAxisTickLine).apply(this, arguments));\n    }\n\n    _createClass(LinearYAxisTickLine, [{\n      key: \"render\",\n      value: function render() {\n        return jsxRuntime.jsx(LinearAxisTickLine, Object.assign({}, this.props), void 0);\n      }\n    }]);\n\n    return LinearYAxisTickLine;\n  }(react.Component);\n\n  LinearYAxisTickLine.defaultProps = Object.assign(Object.assign({}, LinearAxisTickLine.defaultProps), {\n    position: 'start'\n  });\n\n  var LinearYAxisTickSeries = /*#__PURE__*/function (_react$Component10) {\n    _inherits(LinearYAxisTickSeries, _react$Component10);\n\n    function LinearYAxisTickSeries() {\n      _classCallCheck(this, LinearYAxisTickSeries);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(LinearYAxisTickSeries).apply(this, arguments));\n    }\n\n    _createClass(LinearYAxisTickSeries, [{\n      key: \"render\",\n      value: function render() {\n        return jsxRuntime.jsx(LinearAxisTickSeries, Object.assign({}, this.props), void 0);\n      }\n    }]);\n\n    return LinearYAxisTickSeries;\n  }(react.Component);\n\n  LinearYAxisTickSeries.defaultProps = Object.assign(Object.assign({}, LinearAxisTickSeries.defaultProps), {\n    tickSize: 30,\n    line: jsxRuntime.jsx(LinearYAxisTickLine, {}, void 0),\n    label: jsxRuntime.jsx(LinearYAxisTickLabel, {}, void 0)\n  });\n\n  var LinearYAxis = /*#__PURE__*/function (_react$Component11) {\n    _inherits(LinearYAxis, _react$Component11);\n\n    function LinearYAxis() {\n      _classCallCheck(this, LinearYAxis);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(LinearYAxis).apply(this, arguments));\n    }\n\n    _createClass(LinearYAxis, [{\n      key: \"render\",\n      value: function render() {\n        return jsxRuntime.jsx(LinearAxis, Object.assign({}, this.props), void 0);\n      }\n    }]);\n\n    return LinearYAxis;\n  }(react.Component);\n\n  LinearYAxis.defaultProps = Object.assign(Object.assign({}, LinearAxis.defaultProps), {\n    orientation: 'vertical',\n    scaled: false,\n    roundDomains: false,\n    type: 'value',\n    position: 'start',\n    tickSeries: jsxRuntime.jsx(LinearYAxisTickSeries, {}, void 0)\n  });\n  /**\r\n   * Returns whether the axis has a visual element or not.\r\n   */\n\n  var isAxisVisible = function isAxisVisible(axis) {\n    return !!axis.tickSeries.props.label || !!axis.tickSeries.props.line;\n  };\n\n  var RadialAxisTickLine = /*#__PURE__*/function (_react$PureComponent2) {\n    _inherits(RadialAxisTickLine, _react$PureComponent2);\n\n    function RadialAxisTickLine() {\n      _classCallCheck(this, RadialAxisTickLine);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(RadialAxisTickLine).apply(this, arguments));\n    }\n\n    _createClass(RadialAxisTickLine, [{\n      key: \"render\",\n      value: function render() {\n        var _this$props15 = this.props,\n            stroke = _this$props15.stroke,\n            size = _this$props15.size,\n            position = _this$props15.position,\n            innerRadius = _this$props15.innerRadius,\n            outerRadius = _this$props15.outerRadius;\n        var x1 = position === 'outside' ? size : -(outerRadius - innerRadius);\n        return jsxRuntime.jsx(\"line\", {\n          x1: x1,\n          x2: 0,\n          stroke: stroke,\n          style: {\n            pointerEvents: 'none'\n          }\n        }, void 0);\n      }\n    }]);\n\n    return RadialAxisTickLine;\n  }(react.PureComponent);\n\n  RadialAxisTickLine.defaultProps = {\n    stroke: 'rgba(113, 128, 141, .5)',\n    size: 10,\n    position: 'inside'\n  };\n\n  var rad2deg = function rad2deg(angle) {\n    return angle * 180 / Math.PI;\n  };\n\n  var RadialAxisTickLabel = /*#__PURE__*/function (_react$PureComponent3) {\n    _inherits(RadialAxisTickLabel, _react$PureComponent3);\n\n    function RadialAxisTickLabel() {\n      _classCallCheck(this, RadialAxisTickLabel);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(RadialAxisTickLabel).apply(this, arguments));\n    }\n\n    _createClass(RadialAxisTickLabel, [{\n      key: \"getPosition\",\n      value: function getPosition() {\n        var _this$props16 = this.props,\n            point = _this$props16.point,\n            autoRotate = _this$props16.autoRotate,\n            rotation = _this$props16.rotation,\n            padding = _this$props16.padding;\n        var textAnchor;\n        var transform;\n\n        if (autoRotate) {\n          var l = point >= Math.PI;\n          var r = point < 2 * Math.PI; // TODO: This centers the text, determine better way later\n\n          if (rotation >= 85 && rotation <= 95 || rotation <= -85 && rotation >= -95) {\n            textAnchor = 'middle';\n          } else if (l && r) {\n            textAnchor = 'end';\n          } else {\n            textAnchor = 'start';\n          }\n\n          transform = \"rotate(\".concat(90 - rad2deg(point), \", \").concat(padding, \", 0)\");\n        } else {\n          var shouldRotate = rotation > 100 && rotation;\n          var rotate = shouldRotate ? 180 : 0;\n\n          var _translate = shouldRotate ? -30 : 0;\n\n          textAnchor = shouldRotate ? 'end' : 'start';\n          transform = \"rotate(\".concat(rotate, \") translate(\").concat(_translate, \")\");\n        }\n\n        return {\n          transform: transform,\n          textAnchor: textAnchor\n        };\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props17 = this.props,\n            data = _this$props17.data,\n            fill = _this$props17.fill,\n            fontFamily = _this$props17.fontFamily,\n            fontSize = _this$props17.fontSize,\n            format = _this$props17.format,\n            lineSize = _this$props17.lineSize,\n            index = _this$props17.index;\n        var text = format ? format(data, index) : formatValue(data);\n\n        var _this$getPosition2 = this.getPosition(),\n            transform = _this$getPosition2.transform,\n            textAnchor = _this$getPosition2.textAnchor;\n\n        return jsxRuntime.jsxs(\"g\", Object.assign({\n          transform: transform\n        }, {\n          children: [jsxRuntime.jsx(\"title\", {\n            children: text\n          }, void 0), jsxRuntime.jsx(\"text\", Object.assign({\n            dy: \"0.35em\",\n            x: lineSize + 5,\n            textAnchor: textAnchor,\n            fill: fill,\n            fontFamily: fontFamily,\n            fontSize: fontSize\n          }, {\n            children: text\n          }), void 0)]\n        }), void 0);\n      }\n    }]);\n\n    return RadialAxisTickLabel;\n  }(react.PureComponent);\n\n  RadialAxisTickLabel.defaultProps = {\n    fill: '#71808d',\n    fontSize: 11,\n    padding: 15,\n    fontFamily: 'sans-serif',\n    autoRotate: true\n  };\n\n  var RadialAxisTick = /*#__PURE__*/function (_react$Component12) {\n    _inherits(RadialAxisTick, _react$Component12);\n\n    function RadialAxisTick() {\n      _classCallCheck(this, RadialAxisTick);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(RadialAxisTick).apply(this, arguments));\n    }\n\n    _createClass(RadialAxisTick, [{\n      key: \"render\",\n      value: function render() {\n        var _this$props18 = this.props,\n            line = _this$props18.line,\n            label = _this$props18.label,\n            scale = _this$props18.scale,\n            outerRadius = _this$props18.outerRadius,\n            data = _this$props18.data,\n            index = _this$props18.index,\n            padding = _this$props18.padding,\n            innerRadius = _this$props18.innerRadius;\n        var point = scale(data);\n        var rotation = point * 180 / Math.PI - 90;\n        var transform = \"rotate(\".concat(rotation, \") translate(\").concat(outerRadius + padding, \",0)\");\n        var lineSize = line ? line.props.size : 0;\n        return jsxRuntime.jsxs(\"g\", Object.assign({\n          transform: transform\n        }, {\n          children: [line && jsxRuntime.jsx(rdk.CloneElement, {\n            element: line,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius\n          }, void 0), label && jsxRuntime.jsx(rdk.CloneElement, {\n            element: label,\n            index: index,\n            point: point,\n            rotation: rotation,\n            lineSize: lineSize,\n            data: data\n          }, void 0)]\n        }), void 0);\n      }\n    }]);\n\n    return RadialAxisTick;\n  }(react.Component);\n\n  RadialAxisTick.defaultProps = {\n    outerRadius: 0,\n    padding: 0,\n    line: jsxRuntime.jsx(RadialAxisTickLine, {}, void 0),\n    label: jsxRuntime.jsx(RadialAxisTickLabel, {}, void 0)\n  };\n\n  var RadialAxisTickSeries = /*#__PURE__*/function (_react$Component13) {\n    _inherits(RadialAxisTickSeries, _react$Component13);\n\n    function RadialAxisTickSeries() {\n      _classCallCheck(this, RadialAxisTickSeries);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(RadialAxisTickSeries).apply(this, arguments));\n    }\n\n    _createClass(RadialAxisTickSeries, [{\n      key: \"render\",\n      value: function render() {\n        var _this$props19 = this.props,\n            scale = _this$props19.scale,\n            count = _this$props19.count,\n            outerRadius = _this$props19.outerRadius,\n            tick = _this$props19.tick,\n            tickValues = _this$props19.tickValues,\n            innerRadius = _this$props19.innerRadius,\n            interval = _this$props19.interval,\n            type = _this$props19.type;\n\n        var ticks = _getTicks(scale, tickValues, type, count, interval || count);\n\n        return jsxRuntime.jsx(react.Fragment, {\n          children: ticks.map(function (data, i) {\n            return jsxRuntime.jsx(rdk.CloneElement, {\n              element: tick,\n              index: i,\n              scale: scale,\n              data: data,\n              innerRadius: innerRadius,\n              outerRadius: outerRadius\n            }, i);\n          })\n        }, void 0);\n      }\n    }]);\n\n    return RadialAxisTickSeries;\n  }(react.Component);\n\n  RadialAxisTickSeries.defaultProps = {\n    count: 12,\n    type: 'time',\n    tick: jsxRuntime.jsx(RadialAxisTick, {}, void 0)\n  };\n\n  var RadialAxisArc = /*#__PURE__*/function (_react$Component14) {\n    _inherits(RadialAxisArc, _react$Component14);\n\n    function RadialAxisArc() {\n      _classCallCheck(this, RadialAxisArc);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(RadialAxisArc).apply(this, arguments));\n    }\n\n    _createClass(RadialAxisArc, [{\n      key: \"render\",\n      value: function render() {\n        var _this$props20 = this.props,\n            index = _this$props20.index,\n            stroke = _this$props20.stroke,\n            strokeDasharray = _this$props20.strokeDasharray,\n            scale = _this$props20.scale;\n        var r = scale(index);\n        var strokeColor = typeof stroke === 'string' ? stroke : stroke(index);\n        var strokeDash = typeof strokeDasharray === 'string' ? strokeDasharray : strokeDasharray(index);\n        return jsxRuntime.jsx(\"circle\", {\n          fill: \"none\",\n          strokeDasharray: strokeDash,\n          stroke: strokeColor,\n          style: {\n            pointerEvents: 'none'\n          },\n          cx: \"0\",\n          cy: \"0\",\n          r: r\n        }, void 0);\n      }\n    }]);\n\n    return RadialAxisArc;\n  }(react.Component);\n\n  RadialAxisArc.defaultProps = {\n    stroke: '#71808d',\n    strokeDasharray: '1,4'\n  };\n\n  var RadialAxisArcSeries = /*#__PURE__*/function (_react$Component15) {\n    _inherits(RadialAxisArcSeries, _react$Component15);\n\n    function RadialAxisArcSeries() {\n      _classCallCheck(this, RadialAxisArcSeries);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(RadialAxisArcSeries).apply(this, arguments));\n    }\n\n    _createClass(RadialAxisArcSeries, [{\n      key: \"render\",\n      value: function render() {\n        var _this$props21 = this.props,\n            count = _this$props21.count,\n            innerRadius = _this$props21.innerRadius,\n            outerRadius = _this$props21.outerRadius,\n            arc = _this$props21.arc;\n        var scale = d3Scale.scaleLinear().domain([0, count]).range([innerRadius, outerRadius]);\n        var arcs = scale.ticks(count);\n        return jsxRuntime.jsx(react.Fragment, {\n          children: arcs.map(function (d) {\n            return jsxRuntime.jsx(rdk.CloneElement, {\n              element: arc,\n              index: d,\n              scale: scale\n            }, d);\n          })\n        }, void 0);\n      }\n    }]);\n\n    return RadialAxisArcSeries;\n  }(react.Component);\n\n  RadialAxisArcSeries.defaultProps = {\n    count: 12,\n    arc: jsxRuntime.jsx(RadialAxisArc, {}, void 0)\n  };\n\n  var RadialAxis = /*#__PURE__*/function (_react$Component16) {\n    _inherits(RadialAxis, _react$Component16);\n\n    function RadialAxis() {\n      _classCallCheck(this, RadialAxis);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(RadialAxis).apply(this, arguments));\n    }\n\n    _createClass(RadialAxis, [{\n      key: \"render\",\n      value: function render() {\n        var _this$props22 = this.props,\n            arcs = _this$props22.arcs,\n            ticks = _this$props22.ticks,\n            xScale = _this$props22.xScale,\n            height = _this$props22.height,\n            width = _this$props22.width,\n            innerRadius = _this$props22.innerRadius,\n            type = _this$props22.type;\n        var outerRadius = Math.min(height, width) / 2;\n        return jsxRuntime.jsxs(react.Fragment, {\n          children: [arcs && jsxRuntime.jsx(rdk.CloneElement, {\n            element: arcs,\n            outerRadius: outerRadius,\n            innerRadius: innerRadius\n          }, void 0), ticks && jsxRuntime.jsx(rdk.CloneElement, {\n            element: ticks,\n            scale: xScale,\n            type: type,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius\n          }, void 0)]\n        }, void 0);\n      }\n    }]);\n\n    return RadialAxis;\n  }(react.Component);\n\n  RadialAxis.defaultProps = {\n    innerRadius: 10,\n    type: 'value',\n    arcs: jsxRuntime.jsx(RadialAxisArcSeries, {}, void 0),\n    ticks: jsxRuntime.jsx(RadialAxisTickSeries, {}, void 0)\n  };\n  /**\r\n   * Add ability to calculate scale band position.\r\n   * Reference: https://stackoverflow.com/questions/38633082/d3-getting-invert-value-of-band-scales\r\n   */\n\n  var scaleBandInvert = function scaleBandInvert(scale) {\n    var domain = scale.domain();\n    var paddingOuter = scale(domain[0]);\n    var eachBand = scale.step();\n\n    var _scale$range3 = scale.range(),\n        _scale$range4 = _slicedToArray(_scale$range3, 2),\n        end = _scale$range4[1];\n\n    return function (offset) {\n      var index = Math.floor((offset - paddingOuter) / eachBand); // Handle horizontal charts...\n\n      if (end === 0) {\n        index = index * -1;\n      }\n\n      return domain[Math.max(0, Math.min(index, domain.length - 1))];\n    };\n  };\n  /**\r\n   * Given a point position, get the closes data point in the dataset.\r\n   */\n\n\n  var getClosestPoint = function getClosestPoint(pos, scale, data) {\n    var attr = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'x';\n\n    if (scale.invert) {\n      var domain = scale.invert(pos); // Select the index\n\n      var bisect = d3Array.bisector(function (d) {\n        return d[attr];\n      }).right;\n      var index = bisect(data, domain); // Determine min index\n\n      var minIndex = Math.max(0, index - 1);\n      var before = data[minIndex]; // Determine max index\n\n      var maxIndex = Math.min(data.length - 1, index);\n      var after = data[maxIndex]; // Determine which is closest to the point\n\n      var beforeVal = before[attr];\n      var afterVal = after[attr];\n      beforeVal = domain - beforeVal;\n      afterVal = afterVal - domain;\n      return beforeVal < afterVal ? before : after;\n    } else {\n      // If we have a band scale, handle that special\n      var _domain = scale.domain();\n\n      var prop; // Of course the Marimekko is a pain...\n\n      if (scale.mariemkoInvert) {\n        prop = scale.mariemkoInvert(pos);\n      } else {\n        prop = scaleBandInvert(scale)(pos);\n      }\n\n      var idx = _domain.indexOf(prop);\n\n      return data[idx];\n    }\n  };\n  /**\r\n   * Given an event, get the parent svg element;\r\n   */\n\n\n  var getParentSVG = function getParentSVG(event) {\n    // set node to targets owner svg\n    var node = event.target.ownerSVGElement; // find the outermost svg\n\n    if (node) {\n      while (node.ownerSVGElement) {\n        node = node.ownerSVGElement;\n      }\n    }\n\n    return node;\n  };\n  /**\r\n   * Given an event, get the relative X/Y position for a target.\r\n   */\n\n\n  var getPositionForTarget = function getPositionForTarget(_ref3) {\n    var target = _ref3.target,\n        clientX = _ref3.clientX,\n        clientY = _ref3.clientY;\n\n    var _target$getBoundingCl = target.getBoundingClientRect(),\n        top = _target$getBoundingCl.top,\n        left = _target$getBoundingCl.left;\n\n    return {\n      x: clientX - left - target.clientLeft,\n      y: clientY - top - target.clientTop\n    };\n  };\n  /**\r\n   * Gets the point from q given matrix.\r\n   */\n\n\n  var getPointFromMatrix = function getPointFromMatrix(event, matrix) {\n    var parent = getParentSVG(event);\n\n    if (!parent) {\n      return null;\n    } // Determines client coordinates relative to the editor component\n\n\n    var _parent$getBoundingCl = parent.getBoundingClientRect(),\n        top = _parent$getBoundingCl.top,\n        left = _parent$getBoundingCl.left;\n\n    var x = event.clientX - left;\n    var y = event.clientY - top; // Transforms the coordinate to world coordinate (in the SVG/DIV world)\n\n    return transformationMatrix.applyToPoint(transformationMatrix.inverse(matrix), {\n      x: x,\n      y: y\n    });\n  };\n  /**\r\n   * Get the start/end matrix.\r\n   */\n\n\n  var getLimitMatrix = function getLimitMatrix(height, width, matrix) {\n    return transformationMatrix.applyToPoints(matrix, [{\n      x: 0,\n      y: 0\n    }, {\n      x: width,\n      y: height\n    }]);\n  };\n  /**\r\n   * Constrain the matrix.\r\n   */\n\n\n  var constrainMatrix = function constrainMatrix(height, width, matrix) {\n    var _getLimitMatrix = getLimitMatrix(height, width, matrix),\n        _getLimitMatrix2 = _slicedToArray(_getLimitMatrix, 2),\n        min = _getLimitMatrix2[0],\n        max = _getLimitMatrix2[1];\n\n    if (max.x < width || max.y < height) {\n      return true;\n    }\n\n    if (min.x > 0 || min.y > 0) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Determine if scale factor is less than allowed.\r\n   */\n\n\n  var lessThanScaleFactorMin = function lessThanScaleFactorMin(value, scaleFactor) {\n    return value.scaleFactorMin && value.d * scaleFactor <= value.scaleFactorMin;\n  };\n  /**\r\n   * Determine if scale factor is larger than allowed.\r\n   */\n\n\n  var moreThanScaleFactorMax = function moreThanScaleFactorMax(value, scaleFactor) {\n    return value.scaleFactorMax && value.d * scaleFactor >= value.scaleFactorMax;\n  };\n  /**\r\n   * Determine if both min and max scale fctors are going out of bounds.\r\n   */\n\n\n  var isZoomLevelGoingOutOfBounds = function isZoomLevelGoingOutOfBounds(value, scaleFactor) {\n    var a = lessThanScaleFactorMin(value, scaleFactor) && scaleFactor < 1;\n    var b = moreThanScaleFactorMax(value, scaleFactor) && scaleFactor > 1;\n    return a || b;\n  };\n  /**\r\n   * Toggle the text selection of the body.\r\n   */\n\n\n  function toggleTextSelection(allowSelection) {\n    var style = allowSelection ? '' : 'none';\n    ['-webkit-touch-callout', '-webkit-user-select', '-khtml-user-select', '-moz-user-select', '-ms-user-select', 'user-select'].forEach(function (prop) {\n      return document.body.style[prop] = style;\n    });\n  }\n\n  var Move = /*#__PURE__*/function (_react$Component17) {\n    _inherits(Move, _react$Component17);\n\n    function Move() {\n      var _this3;\n\n      _classCallCheck(this, Move);\n\n      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Move).apply(this, arguments));\n      _this3.started = false;\n      _this3.deltaX = 0;\n      _this3.deltaY = 0;\n      _this3.prevXPosition = 0;\n      _this3.prevYPosition = 0;\n\n      _this3.onMouseMove = function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n        var movementX = event.movementX,\n            movementY = event.movementY;\n        _this3.deltaX = _this3.deltaX + movementX;\n        _this3.deltaY = _this3.deltaY + movementY;\n\n        if (_this3.checkThreshold()) {\n          _this3.disableText(true);\n\n          _this3.setCursor(true);\n\n          _this3.deltaX = 0;\n          _this3.deltaY = 0;\n          _this3.started = true;\n\n          _this3.props.onMoveStart({\n            nativeEvent: event,\n            type: 'mouse'\n          });\n        } else {\n          _this3.rqf = requestAnimationFrame(function () {\n            _this3.props.onMove({\n              nativeEvent: event,\n              type: 'mouse',\n              x: movementX,\n              y: movementY\n            });\n          });\n        }\n      };\n\n      _this3.onMouseUp = function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        _this3.disposeHandlers();\n\n        if (_this3.started) {\n          _this3.props.onMoveEnd({\n            nativeEvent: event,\n            type: 'mouse'\n          });\n        } else {\n          _this3.props.onMoveCancel({\n            nativeEvent: event,\n            type: 'mouse'\n          });\n        }\n      };\n\n      _this3.onTouchMove = function (event) {\n        event.preventDefault();\n        event.stopPropagation(); // Calculate delta from previous position and current\n\n        var _this3$getTouchCoords = _this3.getTouchCoords(event),\n            clientX = _this3$getTouchCoords.clientX,\n            clientY = _this3$getTouchCoords.clientY;\n\n        var deltaX = clientX - _this3.prevXPosition;\n        var deltaY = clientY - _this3.prevYPosition; // Track the delta\n\n        _this3.deltaX = _this3.deltaX + deltaX;\n        _this3.deltaY = _this3.deltaY + deltaY;\n\n        if (_this3.checkThreshold()) {\n          _this3.disableText(true);\n\n          _this3.setCursor(true);\n\n          _this3.deltaX = 0;\n          _this3.deltaY = 0;\n          _this3.started = true;\n\n          _this3.props.onMoveStart({\n            // TODO: Come back and clean this up...\n            nativeEvent: Object.assign(Object.assign({}, event), {\n              clientX: clientX,\n              clientY: clientY\n            }),\n            type: 'touch'\n          });\n        } else {\n          _this3.rqf = requestAnimationFrame(function () {\n            _this3.props.onMove({\n              // TODO: Come back and clean this up...\n              nativeEvent: Object.assign(Object.assign({}, event), {\n                clientX: clientX,\n                clientY: clientY\n              }),\n              type: 'touch',\n              x: deltaX,\n              y: deltaY\n            });\n          });\n        }\n\n        _this3.prevXPosition = clientX;\n        _this3.prevYPosition = clientY;\n      };\n\n      _this3.onTouchEnd = function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        _this3.disposeHandlers();\n\n        if (_this3.started) {\n          _this3.props.onMoveEnd({\n            nativeEvent: event,\n            type: 'touch'\n          });\n        } else {\n          _this3.props.onMoveCancel({\n            nativeEvent: event,\n            type: 'touch'\n          });\n        }\n      };\n\n      return _this3;\n    }\n\n    _createClass(Move, [{\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        cancelAnimationFrame(this.rqf);\n        this.disposeHandlers();\n      }\n    }, {\n      key: \"disposeHandlers\",\n      value: function disposeHandlers() {\n        window.removeEventListener('mousemove', this.onMouseMove);\n        window.removeEventListener('mouseup', this.onMouseUp);\n        window.removeEventListener('touchmove', this.onTouchMove);\n        window.removeEventListener('touchend', this.onTouchEnd);\n        this.setCursor(false);\n        this.disableText(true);\n      }\n    }, {\n      key: \"disableText\",\n      value: function disableText(shouldDisable) {\n        if (this.props.disableText) {\n          toggleTextSelection(shouldDisable);\n        }\n      }\n    }, {\n      key: \"setCursor\",\n      value: function setCursor(set) {\n        var cursor = this.props.cursor;\n\n        if (cursor) {\n          if (!set) {\n            cursor = 'inherit';\n          }\n\n          document.body.style['cursor'] = cursor;\n        }\n      }\n    }, {\n      key: \"checkThreshold\",\n      value: function checkThreshold() {\n        var threshold = this.props.threshold;\n        return !this.started && (Math.abs(this.deltaX) > threshold || Math.abs(this.deltaY) > threshold);\n      }\n    }, {\n      key: \"getTouchCoords\",\n      value: function getTouchCoords(event) {\n        var _event$touches$ = event.touches[0],\n            clientX = _event$touches$.clientX,\n            clientY = _event$touches$.clientY;\n        return {\n          clientX: clientX,\n          clientY: clientY\n        };\n      }\n    }, {\n      key: \"onMouseDown\",\n      value: function onMouseDown(event) {\n        var _this$props23 = this.props,\n            preventRightClick = _this$props23.preventRightClick,\n            disabled = _this$props23.disabled;\n        var shouldCancel = event.nativeEvent.which === 3 && preventRightClick;\n\n        if (shouldCancel || disabled) {\n          return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n        this.started = false; // Always bind event so we cancel movement even if no action was taken\n\n        window.addEventListener('mousemove', this.onMouseMove);\n        window.addEventListener('mouseup', this.onMouseUp);\n      }\n    }, {\n      key: \"onTouchStart\",\n      value: function onTouchStart(event) {\n        var disabled = this.props.disabled;\n\n        if (disabled || event.touches.length !== 1) {\n          return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n        this.started = false;\n        this.prevXPosition = event.touches[0].clientX;\n        this.prevYPosition = event.touches[0].clientY; // Always bind event so we cancel movement even if no action was taken\n\n        window.addEventListener('touchmove', this.onTouchMove);\n        window.addEventListener('touchend', this.onTouchEnd);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this4 = this;\n\n        return react.Children.map(this.props.children, function (child) {\n          return react.cloneElement(child, Object.assign(Object.assign({}, child.props), {\n            onMouseDown: function onMouseDown(e) {\n              _this4.onMouseDown(e);\n\n              if (child.props.onMouseDown) {\n                child.props.onMouseDown(e);\n              }\n            },\n            onTouchStart: function onTouchStart(e) {\n              _this4.onTouchStart(e);\n\n              if (child.props.onTouchStart) {\n                child.props.onTouchStart(e);\n              }\n            }\n          }));\n        });\n      }\n    }]);\n\n    return Move;\n  }(react.Component);\n\n  Move.defaultProps = {\n    preventRightClick: true,\n    disableText: true,\n    threshold: 0,\n    onMoveStart: function onMoveStart() {\n      return undefined;\n    },\n    onMove: function onMove() {\n      return undefined;\n    },\n    onMoveEnd: function onMoveEnd() {\n      return undefined;\n    },\n    onMoveCancel: function onMoveCancel() {\n      return undefined;\n    }\n  };\n\n  function styleInject(css, ref) {\n    if (ref === void 0) ref = {};\n    var insertAt = ref.insertAt;\n\n    if (!css || typeof document === 'undefined') {\n      return;\n    }\n\n    var head = document.head || document.getElementsByTagName('head')[0];\n    var style = document.createElement('style');\n    style.type = 'text/css';\n\n    if (insertAt === 'top') {\n      if (head.firstChild) {\n        head.insertBefore(style, head.firstChild);\n      } else {\n        head.appendChild(style);\n      }\n    } else {\n      head.appendChild(style);\n    }\n\n    if (style.styleSheet) {\n      style.styleSheet.cssText = css;\n    } else {\n      style.appendChild(document.createTextNode(css));\n    }\n  }\n\n  var css_248z$s = \".BrushHandle-module_handle__1HtKb {\\n  fill: var(--color-handle-fill);\\n  stroke: var(--color-handle-stroke);\\n}\\n\\n.BrushHandle-module_dragging__k86sG {\\n  fill: var(--color-handle-drag-fill);\\n}\\n\\n.BrushHandle-module_dot__vx-R8 {\\n  fill: var(--color-handle-dots);\\n}\\n\\n.BrushHandle-module_line__1jJ7Y {\\n  stroke: var(--color-handle-line);\\n}\\n\";\n  var css$s = {\n    \"handle\": \"BrushHandle-module_handle__1HtKb\",\n    \"dragging\": \"BrushHandle-module_dragging__k86sG\",\n    \"dot\": \"BrushHandle-module_dot__vx-R8\",\n    \"line\": \"BrushHandle-module_line__1jJ7Y\"\n  };\n  styleInject(css_248z$s);\n\n  var BrushHandle = /*#__PURE__*/function (_react$PureComponent4) {\n    _inherits(BrushHandle, _react$PureComponent4);\n\n    function BrushHandle() {\n      var _this5;\n\n      _classCallCheck(this, BrushHandle);\n\n      _this5 = _possibleConstructorReturn(this, _getPrototypeOf(BrushHandle).apply(this, arguments));\n      _this5.state = {\n        isDragging: false\n      };\n      return _this5;\n    }\n\n    _createClass(BrushHandle, [{\n      key: \"onMoveStart\",\n      value: function onMoveStart() {\n        this.setState({\n          isDragging: true\n        });\n      }\n    }, {\n      key: \"onMove\",\n      value: function onMove(event) {\n        this.props.onHandleDrag(event.x);\n      }\n    }, {\n      key: \"onMoveEnd\",\n      value: function onMoveEnd() {\n        this.setState({\n          isDragging: false\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var height = this.props.height;\n        var isDragging = this.state.isDragging;\n        return jsxRuntime.jsx(Move, Object.assign({\n          cursor: \"ew-resize\",\n          onMoveStart: bind__default['default'](this.onMoveStart, this),\n          onMove: bind__default['default'](this.onMove, this),\n          onMoveEnd: bind__default['default'](this.onMoveEnd, this)\n        }, {\n          children: jsxRuntime.jsxs(\"g\", {\n            children: [jsxRuntime.jsx(\"line\", {\n              className: css$s.line,\n              y1: \"0\",\n              y2: height,\n              x1: \"5\",\n              x2: \"5\"\n            }, void 0), jsxRuntime.jsx(\"rect\", {\n              className: classNames__default['default'](css$s.handle, _defineProperty({}, css$s.dragging, isDragging)),\n              height: height - 10,\n              style: {\n                cursor: 'ew-resize'\n              },\n              width: 8,\n              y: \"5\",\n              y1: height - 5\n            }, void 0), jsxRuntime.jsx(\"g\", Object.assign({\n              transform: \"translate(-1, \".concat(height / 2 - 10, \")\"),\n              style: {\n                pointerEvents: 'none'\n              }\n            }, {\n              children: d3Array.range(5).map(function (i) {\n                return jsxRuntime.jsx(\"circle\", {\n                  cy: i * 5,\n                  cx: \"5\",\n                  r: \".5\",\n                  className: css$s.dot\n                }, i);\n              })\n            }), void 0)]\n          }, void 0)\n        }), void 0);\n      }\n    }]);\n\n    return BrushHandle;\n  }(react.PureComponent);\n\n  var css_248z$r = \".BrushSlice-module_slice__sa839 {\\n  fill: var(--color-primary);\\n}\\n\\n.BrushSlice-module_unsliced__1Ls_5 {\\n  fill: var(--color-background);\\n  opacity: 0.5;\\n  pointer-events: none;\\n}\\n\";\n  var css$r = {\n    \"slice\": \"BrushSlice-module_slice__sa839\",\n    \"unsliced\": \"BrushSlice-module_unsliced__1Ls_5\"\n  };\n  styleInject(css_248z$r);\n\n  var BrushSlice = /*#__PURE__*/function (_react$PureComponent5) {\n    _inherits(BrushSlice, _react$PureComponent5);\n\n    function BrushSlice() {\n      var _this6;\n\n      _classCallCheck(this, BrushSlice);\n\n      _this6 = _possibleConstructorReturn(this, _getPrototypeOf(BrushSlice).apply(this, arguments));\n      _this6.state = {\n        isDragging: false\n      };\n      return _this6;\n    }\n\n    _createClass(BrushSlice, [{\n      key: \"onMoveStart\",\n      value: function onMoveStart() {\n        var _this$props24 = this.props,\n            start = _this$props24.start,\n            end = _this$props24.end,\n            width = _this$props24.width;\n        var hasNoSlice = start === 0 && end === width;\n\n        if (!hasNoSlice) {\n          this.setState({\n            isDragging: true\n          });\n        }\n      }\n    }, {\n      key: \"onMove\",\n      value: function onMove(_ref4) {\n        var x = _ref4.x;\n        var _this$props25 = this.props,\n            onBrushChange = _this$props25.onBrushChange,\n            width = _this$props25.width;\n        var _this$props26 = this.props,\n            start = _this$props26.start,\n            end = _this$props26.end;\n        start = start + x;\n        end = end + x;\n\n        if (start >= 0 && end <= width) {\n          onBrushChange({\n            start: start,\n            end: end\n          });\n        }\n      }\n    }, {\n      key: \"onMoveEnd\",\n      value: function onMoveEnd() {\n        this.setState({\n          isDragging: false\n        });\n      }\n    }, {\n      key: \"onHandleDrag\",\n      value: function onHandleDrag(direction, deltaX) {\n        var onBrushChange = this.props.onBrushChange;\n        var _this$props27 = this.props,\n            start = _this$props27.start,\n            end = _this$props27.end;\n        start = direction === 'start' ? start + deltaX : start;\n        end = direction !== 'start' ? end + deltaX : end;\n        onBrushChange({\n          start: start,\n          end: end\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props28 = this.props,\n            height = _this$props28.height,\n            start = _this$props28.start,\n            end = _this$props28.end,\n            width = _this$props28.width;\n        var isDragging = this.state.isDragging;\n        var sliceWidth = Math.max(end - start, 0);\n        var endSliceWidth = Math.max(width - end, 0);\n        var hasNoSlice = start === 0 && end === width;\n        return jsxRuntime.jsxs(react.Fragment, {\n          children: [jsxRuntime.jsx(\"rect\", {\n            className: css$r.unsliced,\n            height: height,\n            width: start\n          }, void 0), jsxRuntime.jsx(\"rect\", {\n            transform: \"translate(\".concat(end, \", 0)\"),\n            className: css$r.unsliced,\n            height: height,\n            width: endSliceWidth\n          }, void 0), jsxRuntime.jsxs(\"g\", Object.assign({\n            transform: \"translate(\".concat(start, \", 0)\")\n          }, {\n            children: [jsxRuntime.jsx(Move, Object.assign({\n              cursor: \"grabbing\",\n              onMoveStart: bind__default['default'](this.onMoveStart, this),\n              onMove: bind__default['default'](this.onMove, this),\n              onMoveEnd: bind__default['default'](this.onMoveEnd, this)\n            }, {\n              children: jsxRuntime.jsx(\"rect\", {\n                className: css$r.slice,\n                height: height,\n                width: sliceWidth,\n                style: {\n                  cursor: isDragging ? 'grabbing' : 'grab',\n                  opacity: hasNoSlice ? 0 : 0.1,\n                  pointerEvents: !hasNoSlice ? 'initial' : 'none'\n                }\n              }, void 0)\n            }), void 0), jsxRuntime.jsx(\"g\", Object.assign({\n              transform: 'translate(-4, 0)'\n            }, {\n              children: jsxRuntime.jsx(BrushHandle, {\n                height: height,\n                onHandleDrag: bind__default['default'](this.onHandleDrag, this, 'start')\n              }, void 0)\n            }), void 0), jsxRuntime.jsx(\"g\", Object.assign({\n              transform: \"translate(\".concat(sliceWidth - 5, \", 0)\")\n            }, {\n              children: jsxRuntime.jsx(BrushHandle, {\n                height: height,\n                onHandleDrag: bind__default['default'](this.onHandleDrag, this, 'end')\n              }, void 0)\n            }), void 0)]\n          }), void 0)]\n        }, void 0);\n      }\n    }]);\n\n    return BrushSlice;\n  }(react.PureComponent);\n\n  var Brush = /*#__PURE__*/function (_react$PureComponent6) {\n    _inherits(Brush, _react$PureComponent6);\n\n    function Brush(props) {\n      var _this7;\n\n      _classCallCheck(this, Brush);\n\n      _this7 = _possibleConstructorReturn(this, _getPrototypeOf(Brush).call(this, props));\n      _this7.state = {\n        isSlicing: false,\n        isPanning: false,\n        start: props.start || 0,\n        end: props.end || props.width\n      };\n      return _this7;\n    }\n\n    _createClass(Brush, [{\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        // If no brush is defined and width updates, update the offset of the end handle.\n        if (prevProps.width !== this.props.width && this.state.end === prevProps.width) {\n          this.setState({\n            end: this.props.width\n          });\n        } // Don't update if we are doing the slicing\n\n\n        if (!this.state.isSlicing && !this.state.isPanning) {\n          var _this$props29 = this.props,\n              start = _this$props29.start,\n              end = _this$props29.end;\n          var startUpdated = start !== prevProps.start && start !== this.state.start;\n          var endUpdated = end !== prevProps.end && end !== this.state.end;\n\n          if (startUpdated || endUpdated) {\n            this.setState(Object.assign({}, this.ensurePositionInBounds(start, end)));\n          }\n        }\n      }\n    }, {\n      key: \"getStartEnd\",\n      value: function getStartEnd(event) {\n        var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n        var _this$getPositionsFor = this.getPositionsForPanEvent(event),\n            x = _this$getPositionsFor.x;\n\n        var start;\n        var end;\n\n        if (x < state.initial) {\n          start = x;\n          end = state.initial;\n        } else {\n          start = state.initial;\n          end = x;\n        }\n\n        return this.ensurePositionInBounds(start, end, state);\n      }\n    }, {\n      key: \"getPositionsForPanEvent\",\n      value: function getPositionsForPanEvent(event) {\n        var eventObj = {\n          target: this.ref,\n          clientX: event.clientX,\n          clientY: event.clientY\n        };\n        return getPositionForTarget(eventObj);\n      }\n    }, {\n      key: \"ensurePositionInBounds\",\n      value: function ensurePositionInBounds(newStart, newEnd) {\n        var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.state;\n        var width = this.props.width;\n        var start = newStart;\n        var end = newEnd;\n\n        if (start === undefined || start <= 0) {\n          start = 0;\n        }\n\n        if (end === undefined) {\n          end = width;\n        }\n\n        if (start > end) {\n          start = state.start;\n        }\n\n        if (end < start) {\n          end = state.end;\n        }\n\n        if (end >= width) {\n          end = width;\n        }\n\n        return {\n          start: start,\n          end: end\n        };\n      }\n    }, {\n      key: \"onMoveStart\",\n      value: function onMoveStart(event) {\n        var positions = this.getPositionsForPanEvent(event.nativeEvent);\n        this.setState({\n          isSlicing: true,\n          initial: positions.x\n        });\n      }\n    }, {\n      key: \"onMove\",\n      value: function onMove(event) {\n        var _this8 = this;\n\n        this.setState(function (prev) {\n          var onBrushChange = _this8.props.onBrushChange; // Use setState callback so we can get the true previous value\n          // rather than the bulk updated value react will trigger\n\n          var _this8$getStartEnd = _this8.getStartEnd(event.nativeEvent, prev),\n              start = _this8$getStartEnd.start,\n              end = _this8$getStartEnd.end;\n\n          if (onBrushChange) {\n            onBrushChange({\n              start: start,\n              end: end\n            });\n          }\n\n          return {\n            start: start,\n            end: end\n          };\n        });\n      }\n    }, {\n      key: \"onMoveEnd\",\n      value: function onMoveEnd() {\n        this.setState({\n          isSlicing: false\n        });\n      }\n    }, {\n      key: \"onMoveCancel\",\n      value: function onMoveCancel() {\n        var val = {\n          start: 0,\n          end: this.props.width\n        };\n        this.setState(val);\n\n        if (this.props.onBrushChange) {\n          this.props.onBrushChange(val);\n        }\n      }\n    }, {\n      key: \"onSliceChange\",\n      value: function onSliceChange(event) {\n        var val = this.ensurePositionInBounds(event.start, event.end);\n        this.setState(val);\n\n        if (this.props.onBrushChange) {\n          this.props.onBrushChange(val);\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this9 = this;\n\n        var _this$props30 = this.props,\n            children = _this$props30.children,\n            disabled = _this$props30.disabled,\n            height = _this$props30.height,\n            width = _this$props30.width;\n        var _this$state = this.state,\n            isSlicing = _this$state.isSlicing,\n            start = _this$state.start,\n            end = _this$state.end;\n        return jsxRuntime.jsx(Move, Object.assign({\n          cursor: \"crosshair\",\n          onMoveStart: bind__default['default'](this.onMoveStart, this),\n          onMove: bind__default['default'](this.onMove, this),\n          onMoveEnd: bind__default['default'](this.onMoveEnd, this),\n          onMoveCancel: bind__default['default'](this.onMoveCancel, this)\n        }, {\n          children: jsxRuntime.jsxs(\"g\", Object.assign({\n            style: {\n              pointerEvents: isSlicing ? 'none' : 'auto',\n              cursor: disabled ? '' : 'crosshair'\n            }\n          }, {\n            children: [children, !disabled && jsxRuntime.jsxs(react.Fragment, {\n              children: [jsxRuntime.jsx(\"rect\", {\n                ref: function ref(_ref5) {\n                  return _this9.ref = _ref5;\n                },\n                height: height,\n                width: width,\n                opacity: 0\n              }, void 0), start !== undefined && end !== undefined && jsxRuntime.jsx(BrushSlice, {\n                start: start,\n                end: end,\n                height: height,\n                width: width,\n                onBrushChange: bind__default['default'](this.onSliceChange, this)\n              }, void 0)]\n            }, void 0)]\n          }), void 0)\n        }), void 0);\n      }\n    }]);\n\n    return Brush;\n  }(react.PureComponent);\n\n  Brush.defaultProps = {\n    disabled: false,\n    height: 0,\n    width: 0,\n    onBrushChange: function onBrushChange() {\n      return undefined;\n    }\n  };\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  function __rest(s, e) {\n    var t = {};\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    }\n\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n  }\n\n  var ChartBrush = /*#__PURE__*/function (_react$Component18) {\n    _inherits(ChartBrush, _react$Component18);\n\n    function ChartBrush() {\n      _classCallCheck(this, ChartBrush);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ChartBrush).apply(this, arguments));\n    }\n\n    _createClass(ChartBrush, [{\n      key: \"getBrushOffset\",\n      value: function getBrushOffset() {\n        var start;\n        var end;\n        var _this$props31 = this.props,\n            disabled = _this$props31.disabled,\n            domain = _this$props31.domain,\n            scale = _this$props31.scale;\n\n        if (!disabled && domain) {\n          start = scale(domain[0]);\n          end = scale(domain[1]);\n        }\n\n        return {\n          start: start,\n          end: end\n        };\n      }\n    }, {\n      key: \"onBrushChange\",\n      value: function onBrushChange(event) {\n        var _this$props32 = this.props,\n            onBrushChange = _this$props32.onBrushChange,\n            scale = _this$props32.scale,\n            width = _this$props32.width;\n\n        if (onBrushChange) {\n          var domain;\n\n          if (event.start !== undefined && event.end !== undefined && (event.start !== 0 || event.end !== width)) {\n            var start = scale.invert(event.start);\n            var end = scale.invert(event.end);\n            domain = [start, end];\n          }\n\n          onBrushChange({\n            domain: domain\n          });\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _a = this.props,\n            scale = _a.scale,\n            height = _a.height,\n            width = _a.width,\n            children = _a.children,\n            rest = __rest(_a, [\"scale\", \"height\", \"width\", \"children\"]);\n\n        return jsxRuntime.jsx(Brush, Object.assign({}, rest, this.getBrushOffset(), {\n          height: height,\n          width: width,\n          onBrushChange: bind__default['default'](this.onBrushChange, this)\n        }, {\n          children: children\n        }), void 0);\n      }\n    }]);\n\n    return ChartBrush;\n  }(react.Component);\n\n  ChartBrush.defaultProps = {};\n  /**\r\n   * Given a margins object, returns the top/left/right/bottom positions.\r\n   */\n\n  function parseMargins(margins) {\n    var top = 0;\n    var right = 0;\n    var bottom = 0;\n    var left = 0;\n\n    if (Array.isArray(margins)) {\n      if (margins.length === 2) {\n        top = margins[0];\n        bottom = margins[0];\n        left = margins[1];\n        right = margins[1];\n      } else if (margins.length === 4) {\n        top = margins[0];\n        right = margins[1];\n        bottom = margins[2];\n        left = margins[3];\n      }\n    } else if (margins !== undefined) {\n      top = margins;\n      right = margins;\n      bottom = margins;\n      left = margins;\n    }\n\n    return {\n      top: top,\n      right: right,\n      bottom: bottom,\n      left: left\n    };\n  }\n  /**\r\n   * Calculates the margins for the chart.\r\n   */\n\n\n  function calculateMarginOffsets(height, width, margins) {\n    var left = margins.left,\n        right = margins.right,\n        bottom = margins.bottom,\n        top = margins.top;\n    var newHeight = height - top - bottom;\n    var newWidth = width - left - right;\n    return {\n      height: newHeight,\n      width: newWidth\n    };\n  }\n  /**\r\n   * Calculates the dimensions for the chart.\r\n   */\n\n\n  function getDimension(_ref6) {\n    var xOffset = _ref6.xOffset,\n        yOffset = _ref6.yOffset,\n        height = _ref6.height,\n        width = _ref6.width,\n        margins = _ref6.margins;\n    var parsedMargins = parseMargins(margins);\n    var marginDims = calculateMarginOffsets(height, width, parsedMargins);\n    var chartWidth = marginDims.width - xOffset;\n    var chartHeight = marginDims.height - yOffset;\n    return {\n      xOffset: xOffset,\n      yOffset: yOffset,\n      height: height,\n      width: width,\n      chartWidth: chartWidth,\n      chartHeight: chartHeight,\n      xMargin: xOffset + parsedMargins.left,\n      yMargin: parsedMargins.top\n    };\n  }\n\n  var ChartContainer = function ChartContainer(_a) {\n    var className = _a.className,\n        children = _a.children,\n        center = _a.center,\n        centerX = _a.centerX,\n        centerY = _a.centerY,\n        style = _a.style,\n        margins = _a.margins,\n        containerClassName = _a.containerClassName,\n        xAxisVisible = _a.xAxisVisible,\n        yAxisVisible = _a.yAxisVisible,\n        id = _a.id,\n        rest = __rest(_a, [\"className\", \"children\", \"center\", \"centerX\", \"centerY\", \"style\", \"margins\", \"containerClassName\", \"xAxisVisible\", \"yAxisVisible\", \"id\"]);\n\n    var curId = rdk.useId(id);\n\n    var _react$useState = react.useState(false),\n        _react$useState2 = _slicedToArray(_react$useState, 2),\n        xAxisSized = _react$useState2[0],\n        setXAxisSized = _react$useState2[1];\n\n    var _react$useState3 = react.useState(false),\n        _react$useState4 = _slicedToArray(_react$useState3, 2),\n        yAxisSized = _react$useState4[0],\n        setYAxisSized = _react$useState4[1];\n\n    var _react$useState5 = react.useState(0),\n        _react$useState6 = _slicedToArray(_react$useState5, 2),\n        xOffset = _react$useState6[0],\n        setYOffset = _react$useState6[1];\n\n    var _react$useState7 = react.useState(0),\n        _react$useState8 = _slicedToArray(_react$useState7, 2),\n        yOffset = _react$useState8[0],\n        setXOffset = _react$useState8[1];\n\n    var _useDimensions__defau = useDimensions__default['default'](),\n        observe = _useDimensions__defau.observe,\n        width = _useDimensions__defau.width,\n        height = _useDimensions__defau.height;\n\n    var chartSized = react.useMemo(function () {\n      if (!height || !width) {\n        return false;\n      } // TODO: @amcdnl refactor this to account for 0-2 axises on x/y\n\n\n      if (xAxisVisible && !xAxisSized) {\n        return false;\n      }\n\n      if (yAxisVisible && !yAxisSized) {\n        return false;\n      }\n\n      return true;\n    }, [height, width, xAxisSized, xAxisVisible, yAxisVisible, yAxisSized]);\n    var onUpdateAxes = react.useCallback(function (orientation, event) {\n      if (orientation === 'horizontal') {\n        setXAxisSized(true);\n      } else {\n        setYAxisSized(true);\n      }\n\n      if (event.height) {\n        setYOffset(event.height);\n      }\n\n      if (event.width) {\n        setXOffset(event.width);\n      }\n    }, []);\n    var childProps = react.useMemo(function () {\n      return Object.assign({\n        chartSized: chartSized,\n        id: curId,\n        updateAxes: onUpdateAxes,\n        yAxisSized: yAxisSized,\n        xAxisSized: xAxisSized\n      }, getDimension({\n        margins: margins,\n        height: height,\n        width: width,\n        yOffset: yOffset,\n        xOffset: xOffset\n      }));\n    }, [chartSized, curId, onUpdateAxes, yAxisSized, xAxisSized, margins, height, width, yOffset, xOffset]);\n    var translateX = center || centerX ? width / 2 : childProps.xMargin;\n    var translateY = center || centerY ? height / 2 : childProps.yMargin;\n    var styleHeight = rest.height !== undefined && rest.height !== null ? rest.height : '100%';\n    var styleWidth = rest.width !== undefined && rest.width !== null ? rest.width : '100%';\n    return jsxRuntime.jsx(\"div\", Object.assign({\n      ref: observe,\n      style: {\n        height: styleHeight,\n        width: styleWidth\n      },\n      className: containerClassName\n    }, {\n      children: height > 0 && width > 0 && jsxRuntime.jsx(\"svg\", Object.assign({\n        width: width,\n        height: height,\n        className: className,\n        style: style\n      }, {\n        children: jsxRuntime.jsx(\"g\", Object.assign({\n          transform: \"translate(\".concat(translateX, \", \").concat(translateY, \")\")\n        }, {\n          children: children(childProps)\n        }), void 0)\n      }), void 0)\n    }), void 0);\n  };\n\n  var humanFormatScale = new humanFormat__default['default'].Scale({\n    k: 1000,\n    M: 1000000,\n    B: 1000000000\n  });\n  var humanFormatMillionScale = new humanFormat__default['default'].Scale({\n    M: 1,\n    B: 1000,\n    T: 1000000\n  });\n  var ONE_MILLION = 1000000;\n  var ONE_BILLION = 1000000000;\n\n  var humanFormatBigInteger = function humanFormatBigInteger(bigInteger) {\n    if (bigInteger.greater(ONE_BILLION)) {\n      return humanFormat__default['default'](bigInteger.divide(ONE_MILLION).toJSNumber(), {\n        scale: humanFormatMillionScale\n      });\n    }\n\n    return humanFormat__default['default'](bigInteger.toJSNumber(), {\n      scale: humanFormatScale\n    });\n  };\n\n  var bigIntegerToLocaleString = function bigIntegerToLocaleString(bigInteger) {\n    var i = 0;\n    var formattedString = '';\n\n    var _iterator2 = _createForOfIteratorHelper(bigInteger.toString().split('').reverse()),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var c = _step2.value;\n\n        if (i > 0 && i % 3 === 0) {\n          formattedString = ',' + formattedString;\n        }\n\n        formattedString = c + formattedString;\n        i++;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return formattedString;\n  };\n\n  function normalizeValue(value, maxBigInt) {\n    if (bigInt__default['default'].isInstance(value)) {\n      if (maxBigInt.greater(1000000)) {\n        var divideBy = maxBigInt.divide(1000000);\n        return value.divide(divideBy).toJSNumber();\n      } else {\n        return value.toJSNumber();\n      }\n    } else {\n      return value;\n    }\n  }\n\n  function normalizeValueForFormatting(value) {\n    if (bigInt__default['default'].isInstance(value)) {\n      return bigIntegerToLocaleString(value);\n    }\n\n    return value;\n  }\n\n  function getMaxBigIntegerForNested(series) {\n    var maxBigInteger = bigInt__default['default'].one;\n\n    var _iterator3 = _createForOfIteratorHelper(series),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var group = _step3.value;\n        var maxBigIntegerForGroup = getMaxBigIntegerForShallow(group.data);\n\n        if (maxBigIntegerForGroup.greater(maxBigInteger)) {\n          maxBigInteger = maxBigIntegerForGroup;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return maxBigInteger;\n  }\n\n  function getMaxBigIntegerForShallow(series) {\n    var maxBigInteger = bigInt__default['default'].one;\n\n    var _iterator4 = _createForOfIteratorHelper(series),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var point = _step4.value;\n\n        if (bigInt__default['default'].isInstance(point.data)) {\n          var bigInteger = point.data;\n\n          if (bigInteger.greater(maxBigInteger)) {\n            maxBigInteger = bigInteger;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    return maxBigInteger;\n  }\n  /**\r\n   * Accepts a `ChartDataShape` and transforms it to a chart readable data shape.\r\n   *\r\n   * Example:\r\n   *\r\n   *   [{\r\n   *    key: 'Threat Intel',\r\n   *    data: [{ key:'2011', data: 25 }]\r\n   *   }]\r\n   *\r\n   * will be transformed to:\r\n   *\r\n   *  [{\r\n   *    key: 'Threat Intel',\r\n   *    data: [\r\n   *      key: 'Threat Intel',\r\n   *      x: '2011',\r\n   *      y: 25\r\n   *    ]\r\n   *  }]\r\n   */\n\n\n  function buildNestedChartData(series) {\n    var sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'vertical';\n    var result = [];\n    var maxBigInteger = getMaxBigIntegerForNested(series);\n    var isVertical = direction === 'vertical';\n\n    var _iterator5 = _createForOfIteratorHelper(series),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var point = _step5.value;\n\n        var _iterator6 = _createForOfIteratorHelper(point.data),\n            _step6;\n\n        try {\n          var _loop = function _loop() {\n            var nestedPoint = _step6.value;\n            var key = normalizeValueForFormatting(point.key);\n            var idx = result.findIndex(function (r) {\n              var left = r.key;\n\n              if (left instanceof Date && key instanceof Date) {\n                return left.getTime() === key.getTime();\n              }\n\n              return left === key;\n            });\n\n            if (idx === -1) {\n              result.push({\n                key: key,\n                metadata: point.metadata,\n                data: []\n              });\n              idx = result.length - 1;\n            }\n\n            var x = normalizeValue(isVertical ? nestedPoint.key : nestedPoint.data, maxBigInteger);\n            var y = normalizeValue(isVertical ? nestedPoint.data : nestedPoint.key, maxBigInteger);\n            result[idx].data.push({\n              key: key,\n              value: normalizeValueForFormatting(nestedPoint.data),\n              metadata: nestedPoint.metadata,\n              id: point.id,\n              x: x,\n              x0: isVertical ? x : 0,\n              x1: x,\n              y: y,\n              y0: isVertical ? 0 : y,\n              y1: y\n            });\n          };\n\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            _loop();\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      } // Sort the series data based on the median value\n\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    if (sort) {\n      result = result.sort(function (a, b) {\n        var aMax = d3Array.median(a.data, function (d) {\n          return d.y;\n        });\n        var bMax = d3Array.median(b.data, function (d) {\n          return d.y;\n        });\n        return aMax < bMax ? 1 : -1;\n      });\n    }\n\n    return result;\n  }\n\n  function addToChartType(a, b) {\n    if (bigInt__default['default'].isInstance(a) && bigInt__default['default'].isInstance(b)) {\n      return a.add(b);\n    } else if (a instanceof Date && typeof b === 'number') {\n      return new Date(a.valueOf() + b);\n    } else if (typeof a === 'number' && typeof b === 'number') {\n      return a + b;\n    } else {\n      throw new Error('Invalid types to addToChartTypes');\n    }\n  }\n  /**\r\n   * Accepts a shallow shape and normalizes it to a chart readable format.\r\n   */\n\n\n  function buildShallowChartData(series) {\n    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'vertical';\n    var binSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    var result = [];\n    var maxBigInteger = getMaxBigIntegerForShallow(series);\n    var isVertical = direction === 'vertical';\n\n    var _iterator7 = _createForOfIteratorHelper(series),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var point = _step7.value;\n        var isTuple = Array.isArray(point.data);\n        var k1 = point.key;\n\n        if (binSize) {\n          k1 = addToChartType(point.key, binSize);\n        }\n\n        var props = {\n          k0: normalizeValue(point.key, maxBigInteger),\n          k1: normalizeValue(k1, maxBigInteger),\n          v0: normalizeValue(isTuple ? point.data[0] : 0, maxBigInteger),\n          v1: normalizeValue(isTuple ? point.data[1] : point.data, maxBigInteger)\n        };\n        var xProp = isVertical ? 'k' : 'v';\n        var yProp = isVertical ? 'v' : 'k';\n        result.push({\n          key: normalizeValueForFormatting(props.k0),\n          value: normalizeValueForFormatting(props.v1),\n          metadata: point.metadata,\n          id: point.id,\n          x: props[\"\".concat(xProp, \"1\")],\n          x0: props[\"\".concat(xProp, \"0\")],\n          x1: props[\"\".concat(xProp, \"1\")],\n          y: props[\"\".concat(yProp, \"1\")],\n          y0: props[\"\".concat(yProp, \"0\")],\n          y1: props[\"\".concat(yProp, \"1\")]\n        });\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    return result;\n  }\n  /**\r\n   * Build a histogram given data set.\r\n   */\n\n\n  function buildBins(xScale, thresholds, data) {\n    var layout = d3Array.histogram().value(function (d) {\n      return d.x;\n    }).domain(xScale.domain()).thresholds(xScale.ticks(thresholds));\n    var bins = layout(data);\n    return bins.map(function (bin) {\n      return {\n        x0: bin.x0,\n        x1: bin.x1,\n        y: bin.length,\n        y0: 0,\n        y1: bin.length\n      };\n    });\n  }\n  /**\r\n   * Given a dataset and a list of accessors, returns a unique collection.\r\n   */\n\n\n  function uniqueBy(data) {\n    for (var _len = arguments.length, accessors = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      accessors[_key - 1] = arguments[_key];\n    }\n\n    var result = [];\n\n    var ittr = function ittr(arr, depth) {\n      var _iterator8 = _createForOfIteratorHelper(arr),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var a = _step8.value;\n          var acc = accessors[depth];\n\n          if (acc === undefined) {\n            throw new Error(\"Accessor not found for depth: \".concat(depth));\n          }\n\n          var val = acc(a);\n\n          if (Array.isArray(val)) {\n            ittr(val, depth + 1);\n          } else if (!result.includes(val)) {\n            result.push(val);\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    };\n\n    ittr(data, 0);\n    return result;\n  }\n  /**\r\n   * Given a dataset like:\r\n   *\r\n   *   [{\r\n   *    key: 'Threat Intel',\r\n   *    data: [{ key:'2011', data: 25 }]\r\n   *   }]\r\n   *\r\n   * it will transform it to:\r\n   *\r\n   *  [\r\n   *    { x: 'Theat Intel', '2011': 25 }\r\n   *  ]\r\n   */\n\n\n  function transformDataToStack$1(data) {\n    var result = [];\n    var maxBigInteger = getMaxBigIntegerForNested(data);\n\n    var _iterator9 = _createForOfIteratorHelper(data),\n        _step9;\n\n    try {\n      var _loop2 = function _loop2() {\n        var category = _step9.value;\n\n        var _iterator10 = _createForOfIteratorHelper(category.data),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var value = _step10.value;\n            var idx = result.findIndex(function (r) {\n              if (r.x instanceof Date && category.key instanceof Date) {\n                return r.x.getTime() === category.key.getTime();\n              }\n\n              return r.x === category.key;\n            });\n\n            if (idx === -1) {\n              result.push({\n                metadata: category.metadata,\n                x: category.key,\n                formattedValues: {}\n              });\n              idx = result.length - 1;\n            }\n\n            result[idx].metadata = value.metadata;\n            result[idx][value.key] = normalizeValue(value.data, maxBigInteger);\n            result[idx].formattedValues[value.key] = normalizeValueForFormatting(value.data);\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      };\n\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        _loop2();\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return result;\n  }\n  /**\r\n   * Translates the stack data to a chart standard dataset.\r\n   */\n\n\n  function transformStackToData$1(stackData) {\n    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'vertical';\n    var result = [];\n    var isVertical = direction === 'vertical'; // Transform the data from the d3 stack format to our internal format\n\n    var _iterator11 = _createForOfIteratorHelper(stackData),\n        _step11;\n\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var category = _step11.value;\n\n        var _iterator12 = _createForOfIteratorHelper(category),\n            _step12;\n\n        try {\n          var _loop3 = function _loop3() {\n            var point = _step12.value;\n            var key = point.data.x;\n            var idx = result.findIndex(function (r) {\n              if (r.key instanceof Date && key instanceof Date) {\n                return r.key.getTime() === key.getTime();\n              }\n\n              return r.key === key;\n            });\n\n            if (idx === -1) {\n              result.push({\n                key: key,\n                data: []\n              });\n              idx = result.length - 1;\n            }\n\n            var categoryKey = category.key;\n            var y = point.data[categoryKey];\n\n            var _point = _slicedToArray(point, 2),\n                y0 = _point[0],\n                y1 = _point[1];\n\n            result[idx].data.push({\n              metadata: point.data.metadata,\n              key: key,\n              x: isVertical ? categoryKey : y1,\n              x0: isVertical ? categoryKey : y0,\n              x1: isVertical ? categoryKey : y1,\n              y: isVertical ? y : categoryKey,\n              y0: isVertical ? y0 : categoryKey,\n              y1: isVertical ? y1 : categoryKey,\n              value: point.data.formattedValues[categoryKey]\n            });\n          };\n\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            _loop3();\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n\n    return result;\n  }\n  /**\r\n   * Builds a stack dataset from the standard data format.\r\n   */\n\n\n  function buildBarStackData() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n    var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'vertical';\n    var keys = uniqueBy(data, function (d) {\n      return d.data;\n    }, function (d) {\n      return d.key;\n    });\n    var stackData = transformDataToStack$1(data);\n    var stackFn = d3Shape.stack();\n\n    if (offset === 'expand') {\n      stackFn = stackFn.offset(d3Shape.stackOffsetExpand);\n    } else if (offset === 'diverging') {\n      stackFn = stackFn.offset(d3Shape.stackOffsetDiverging);\n    }\n\n    var result = stackFn.keys(keys)(stackData);\n    return transformStackToData$1(result, direction);\n  }\n  /**\r\n   * Builds a stack dataset from the standard data format.\r\n   */\n\n\n  function buildMarimekkoData() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var result = buildBarStackData(data, 'expand');\n    var sums = {}; // Calculate the sum for each series and the total sum\n\n    var totalSum = 0;\n\n    var _iterator13 = _createForOfIteratorHelper(result),\n        _step13;\n\n    try {\n      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n        var series = _step13.value;\n        var sum = series.data.reduce(function (acc, cur) {\n          return acc + cur.y;\n        }, 0);\n        sums[series.key] = sum;\n        totalSum += sum;\n      } // Calculate the x0/x1 for each series\n\n    } catch (err) {\n      _iterator13.e(err);\n    } finally {\n      _iterator13.f();\n    }\n\n    var prev = 0;\n\n    var _iterator14 = _createForOfIteratorHelper(result),\n        _step14;\n\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var _series = _step14.value;\n        var x0 = prev;\n        var x1 = prev + sums[_series.key] / totalSum;\n        prev = x1;\n\n        var _iterator15 = _createForOfIteratorHelper(_series.data),\n            _step15;\n\n        try {\n          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var point = _step15.value;\n            point.x0 = x0;\n            point.x1 = x1;\n          }\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n\n    return result;\n  }\n  /**\r\n   * Given a dataset like:\r\n   *\r\n   *   [{\r\n   *    key: 'Threat Intel',\r\n   *    data: [{ key:'2011', data: 25 }]\r\n   *   }]\r\n   *\r\n   * it will transform it to:\r\n   *\r\n   *  [\r\n   *    { x: '2011', 'Theat Intel': 25 }\r\n   *  ]\r\n   */\n\n\n  function transformDataToStack(data) {\n    var result = [];\n    var maxBigInteger = getMaxBigIntegerForNested(data);\n\n    var _iterator16 = _createForOfIteratorHelper(data),\n        _step16;\n\n    try {\n      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n        var category = _step16.value;\n\n        var _iterator17 = _createForOfIteratorHelper(category.data),\n            _step17;\n\n        try {\n          var _loop4 = function _loop4() {\n            var value = _step17.value;\n            var idx = result.findIndex(function (r) {\n              if (r.x instanceof Date && value.key instanceof Date) {\n                return r.x.getTime() === value.key.getTime();\n              }\n\n              return r.x === value.key;\n            });\n\n            if (idx === -1) {\n              result.push({\n                x: value.key,\n                formattedValues: {}\n              });\n              idx = result.length - 1;\n            }\n\n            result[idx][category.key] = normalizeValue(value.data, maxBigInteger);\n            result[idx].formattedValues[category.key] = normalizeValueForFormatting(value.data);\n          };\n\n          for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n            _loop4();\n          }\n        } catch (err) {\n          _iterator17.e(err);\n        } finally {\n          _iterator17.f();\n        }\n      }\n    } catch (err) {\n      _iterator16.e(err);\n    } finally {\n      _iterator16.f();\n    }\n\n    return result;\n  }\n  /**\r\n   * Translates the stack data to a chart standard dataset.\r\n   */\n\n\n  function transformStackToData(stackData) {\n    var result = [];\n\n    var _iterator18 = _createForOfIteratorHelper(stackData),\n        _step18;\n\n    try {\n      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n        var category = _step18.value;\n        var series = [];\n\n        var _iterator19 = _createForOfIteratorHelper(category),\n            _step19;\n\n        try {\n          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n            var point = _step19.value;\n\n            var _point2 = _slicedToArray(point, 2),\n                y0 = _point2[0],\n                y1 = _point2[1];\n\n            var x = point.data.x;\n            series.push({\n              key: category.key,\n              x: x,\n              x0: x,\n              x1: x,\n              y: y1 - y0,\n              y0: y0,\n              y1: y1,\n              value: point.data.formattedValues[category.key]\n            });\n          }\n        } catch (err) {\n          _iterator19.e(err);\n        } finally {\n          _iterator19.f();\n        }\n\n        result.push({\n          key: category.key,\n          data: series\n        });\n      }\n    } catch (err) {\n      _iterator18.e(err);\n    } finally {\n      _iterator18.f();\n    }\n\n    return result;\n  }\n  /**\r\n   * Builds a stack dataset from the standard data format.\r\n   */\n\n\n  function buildStackData(data) {\n    var normalized = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var keys = uniqueBy(data, function (d) {\n      return d.key;\n    });\n    var stackData = transformDataToStack(data);\n    var stackFn = !normalized ? d3Shape.stack() : d3Shape.stack().offset(d3Shape.stackOffsetExpand);\n    var result = stackFn.keys(keys)(stackData);\n    return transformStackToData(result);\n  }\n\n  var buildWaterfall = function buildWaterfall(series) {\n    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'vertical';\n    var binSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    var data = buildShallowChartData(series, direction, binSize);\n    var isVertical = direction === 'vertical';\n    var v = isVertical ? 'y' : 'x';\n    var cumulative = 0;\n\n    var _iterator20 = _createForOfIteratorHelper(data),\n        _step20;\n\n    try {\n      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n        var point = _step20.value;\n        point[\"\".concat(v, \"0\")] = cumulative;\n        cumulative += point[v];\n        point[\"\".concat(v, \"1\")] = cumulative;\n        point[v] = cumulative;\n      }\n    } catch (err) {\n      _iterator20.e(err);\n    } finally {\n      _iterator20.f();\n    }\n\n    return data;\n  };\n\n  var Pan = /*#__PURE__*/function (_react$Component19) {\n    _inherits(Pan, _react$Component19);\n\n    function Pan() {\n      var _this10;\n\n      _classCallCheck(this, Pan);\n\n      _this10 = _possibleConstructorReturn(this, _getPrototypeOf(Pan).apply(this, arguments));\n      _this10.prevXPosition = 0;\n      _this10.prevYPosition = 0;\n      _this10.started = false;\n      _this10.deltaX = 0;\n      _this10.deltaY = 0;\n      _this10.childRef = react.createRef();\n\n      _this10.onMouseDown = function (event) {\n        // Stop at disabled\n        if (_this10.props.disabled) {\n          return;\n        } // Ignore right click\n\n\n        if (event.which === 3) {\n          return;\n        } // If global panning is turned off, it will only pan on the container\n\n\n        if (!_this10.props.globalPanning && event.target && !event.target.classList.contains('pan-container')) {\n          return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n        toggleTextSelection(false);\n        _this10.started = false; // Always bind event so we cancel movement even if no action was taken\n\n        window.addEventListener('mousemove', _this10.onMouseMove);\n        window.addEventListener('mouseup', _this10.onMouseUp);\n      };\n\n      _this10.onMouseMove = function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n        _this10.deltaX = _this10.deltaX + event.movementX;\n        _this10.deltaY = _this10.deltaY + event.movementY;\n\n        if (_this10.checkThreshold()) {\n          if (_this10.props.cursor) {\n            document.body.style['cursor'] = _this10.props.cursor;\n          }\n\n          _this10.deltaX = 0;\n          _this10.deltaY = 0;\n          _this10.started = true;\n\n          _this10.onPanStart(event, 'mouse');\n        } else {\n          _this10.pan(event.movementX, event.movementY, event, 'mouse');\n        }\n      };\n\n      _this10.onMouseUp = function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        _this10.disposeHandlers();\n\n        toggleTextSelection(true);\n\n        if (_this10.started) {\n          _this10.onPanEnd(event, 'mouse');\n        } else {\n          _this10.props.onPanCancel({\n            nativeEvent: event,\n            source: 'mouse'\n          });\n        }\n      };\n\n      _this10.onTouchStart = function (event) {\n        // Stop at disabled\n        if (_this10.props.disabled) {\n          return;\n        } // Reqquire more than one touch\n\n\n        if (event.touches.length !== 1) {\n          return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n        toggleTextSelection(false);\n        _this10.started = false;\n        _this10.prevXPosition = event.touches[0].clientX;\n        _this10.prevYPosition = event.touches[0].clientY; // Always bind event so we cancel movement even if no action was taken\n\n        window.addEventListener('touchmove', _this10.onTouchMove);\n        window.addEventListener('touchend', _this10.onTouchEnd);\n      };\n\n      _this10.onTouchMove = function (event) {\n        event.preventDefault();\n        event.stopPropagation(); // Calculate delta from previous position and current\n\n        var x = event.touches[0].clientX;\n        var y = event.touches[0].clientY;\n        var deltaX = x - _this10.prevXPosition;\n        var deltaY = y - _this10.prevYPosition;\n        _this10.deltaX = _this10.deltaX + deltaX;\n        _this10.deltaY = _this10.deltaY + deltaY;\n\n        if (_this10.checkThreshold()) {\n          _this10.deltaX = 0;\n          _this10.deltaY = 0;\n          _this10.started = true;\n\n          _this10.onPanStart(event, 'touch');\n        } else {\n          var contrained = _this10.pan(deltaX, deltaY, event, 'touch');\n\n          if (!contrained) {\n            _this10.prevXPosition = x;\n            _this10.prevYPosition = y;\n          }\n        }\n      };\n\n      _this10.onTouchEnd = function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        _this10.disposeHandlers();\n\n        toggleTextSelection(true);\n\n        if (_this10.started) {\n          _this10.onPanEnd(event, 'touch');\n        } else {\n          _this10.props.onPanCancel({\n            nativeEvent: event,\n            source: 'touch'\n          });\n        }\n      };\n\n      return _this10;\n    }\n\n    _createClass(Pan, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this.childRef.current) {\n          this.childRef.current.addEventListener('mousedown', this.onMouseDown, {\n            passive: false\n          });\n          this.childRef.current.addEventListener('touchstart', this.onTouchStart, {\n            passive: false\n          });\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this.disposeHandlers();\n\n        if (this.childRef.current) {\n          this.childRef.current.removeEventListener('mousedown', this.onMouseDown);\n          this.childRef.current.removeEventListener('touchstart', this.onTouchStart);\n        }\n      }\n    }, {\n      key: \"disposeHandlers\",\n      value: function disposeHandlers() {\n        window.removeEventListener('mousemove', this.onMouseMove);\n        window.removeEventListener('mouseup', this.onMouseUp);\n        window.removeEventListener('touchmove', this.onTouchMove);\n        window.removeEventListener('touchend', this.onTouchEnd); // Reset cursor on body back to original\n\n        document.body.style['cursor'] = 'inherit';\n        toggleTextSelection(true);\n      }\n    }, {\n      key: \"checkThreshold\",\n      value: function checkThreshold() {\n        var threshold = this.props.threshold;\n        return !this.started && (Math.abs(this.deltaX) > threshold || Math.abs(this.deltaY) > threshold);\n      }\n    }, {\n      key: \"onPanStart\",\n      value: function onPanStart(nativeEvent, source) {\n        this.props.onPanStart({\n          nativeEvent: nativeEvent,\n          source: source\n        });\n      }\n    }, {\n      key: \"onPanMove\",\n      value: function onPanMove(x, y, source, nativeEvent) {\n        this.props.onPanMove({\n          source: source,\n          nativeEvent: nativeEvent,\n          x: x,\n          y: y\n        });\n      }\n    }, {\n      key: \"onPanEnd\",\n      value: function onPanEnd(nativeEvent, source) {\n        var onPanEnd = this.props.onPanEnd;\n        onPanEnd({\n          nativeEvent: nativeEvent,\n          source: source\n        });\n      }\n    }, {\n      key: \"pan\",\n      value: function pan(x, y, nativeEvent, source) {\n        var _this$props33 = this.props,\n            scale = _this$props33.scale,\n            constrain = _this$props33.constrain,\n            width = _this$props33.width,\n            height = _this$props33.height,\n            matrix = _this$props33.matrix;\n        var newMatrix = transformationMatrix.smoothMatrix(transformationMatrix.transform(matrix, transformationMatrix.translate(x / scale, y / scale)), 100);\n        var shouldConstrain = constrain && constrainMatrix(height, width, newMatrix);\n\n        if (!shouldConstrain) {\n          this.onPanMove(newMatrix.e, newMatrix.f, source, nativeEvent);\n        }\n\n        return shouldConstrain;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return jsxRuntime.jsx(\"g\", Object.assign({\n          ref: this.childRef\n        }, {\n          children: this.props.children\n        }), void 0);\n      }\n    }]);\n\n    return Pan;\n  }(react.Component);\n\n  Pan.defaultProps = {\n    x: 0,\n    y: 0,\n    disabled: false,\n    scale: 1,\n    threshold: 10,\n    globalPanning: true,\n    onPanStart: function onPanStart() {\n      return undefined;\n    },\n    onPanMove: function onPanMove() {\n      return undefined;\n    },\n    onPanEnd: function onPanEnd() {\n      return undefined;\n    },\n    onPanCancel: function onPanCancel() {\n      return undefined;\n    }\n  };\n  /**\r\n   * Gets the position between a given set of points.\r\n   */\n\n  var getMidpoint = function getMidpoint(pointA, pointB) {\n    return {\n      x: (pointA.x + pointB.x) / 2,\n      y: (pointA.y + pointB.y) / 2\n    };\n  };\n  /**\r\n   * Gets the distance between a given set of points.\r\n   */\n\n\n  var getDistanceBetweenPoints = function getDistanceBetweenPoints(pointA, pointB) {\n    return Math.sqrt(Math.pow(pointB.y - pointA.y, 2) + Math.pow(pointB.x - pointA.x, 2));\n  };\n  /**\r\n   * Get touch points.\r\n   */\n\n\n  function getTouchPoints(event, node) {\n    var _node$getBoundingClie = node.getBoundingClientRect(),\n        left = _node$getBoundingClie.left,\n        top = _node$getBoundingClie.top;\n\n    var _map = _toConsumableArray(event.touches).map(function (touch) {\n      return {\n        x: touch.clientX - Math.round(left),\n        y: touch.clientY - Math.round(top)\n      };\n    }),\n        _map2 = _slicedToArray(_map, 2),\n        pointA = _map2[0],\n        pointB = _map2[1];\n\n    var distance = getDistanceBetweenPoints(pointA, pointB);\n    var midpoint = getMidpoint(pointA, pointB);\n    return {\n      pointA: pointA,\n      pointB: pointB,\n      distance: distance,\n      midpoint: midpoint\n    };\n  }\n\n  var Zoom = /*#__PURE__*/function (_react$Component20) {\n    _inherits(Zoom, _react$Component20);\n\n    function Zoom() {\n      var _this11;\n\n      _classCallCheck(this, Zoom);\n\n      _this11 = _possibleConstructorReturn(this, _getPrototypeOf(Zoom).apply(this, arguments));\n      _this11.childRef = react.createRef();\n\n      _this11.onMouseWheel = function (event) {\n        var _this11$props = _this11.props,\n            disableMouseWheel = _this11$props.disableMouseWheel,\n            requireZoomModifier = _this11$props.requireZoomModifier,\n            matrix = _this11$props.matrix,\n            onZoomEnd = _this11$props.onZoomEnd;\n\n        if (disableMouseWheel) {\n          return false;\n        }\n\n        var hasModifier = event.metaKey || event.ctrlKey;\n\n        if (requireZoomModifier && !hasModifier) {\n          return false;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n        var point = getPointFromMatrix(event, matrix);\n\n        if (point) {\n          var x = point.x,\n              y = point.y;\n\n          var step = _this11.getStep(event.deltaY);\n\n          _this11.scale(x, y, step, event); // Do small timeout to 'guess' when its done zooming\n\n\n          clearTimeout(_this11.timeout);\n          _this11.timeout = setTimeout(function () {\n            return onZoomEnd();\n          }, 500);\n        }\n      };\n\n      _this11.onTouchStart = function (event) {\n        if (event.touches.length === 2) {\n          event.preventDefault();\n          event.stopPropagation();\n          toggleTextSelection(false);\n          _this11.firstTouch = getTouchPoints(event, _this11.childRef.current);\n          _this11.lastDistance = _this11.firstTouch.distance;\n          window.addEventListener('touchmove', _this11.onTouchMove);\n          window.addEventListener('touchend', _this11.onTouchEnd);\n        }\n      };\n\n      _this11.onTouchMove = function (event) {\n        if (event.touches.length === 2) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          var _getTouchPoints = getTouchPoints(event, _this11.childRef.current),\n              distance = _getTouchPoints.distance;\n\n          var distanceFactor = distance / _this11.lastDistance;\n          var point = transformationMatrix.applyToPoint(transformationMatrix.inverse(_this11.props.matrix), {\n            x: _this11.firstTouch.midpoint.x,\n            y: _this11.firstTouch.midpoint.y\n          });\n\n          if (point.x && point.y) {\n            var outside = _this11.scale(point.x, point.y, distanceFactor, event);\n\n            if (!outside) {\n              _this11.lastDistance = distance;\n            }\n          }\n        }\n      };\n\n      _this11.onTouchEnd = function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n        window.removeEventListener('touchmove', _this11.onTouchMove);\n        window.removeEventListener('touchend', _this11.onTouchEnd);\n        toggleTextSelection(true);\n\n        _this11.props.onZoomEnd();\n      };\n\n      return _this11;\n    }\n\n    _createClass(Zoom, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this$props34 = this.props,\n            disabled = _this$props34.disabled,\n            disableMouseWheel = _this$props34.disableMouseWheel;\n        var ref = this.childRef.current;\n\n        if (!disabled && ref) {\n          if (!disableMouseWheel) {\n            ref.addEventListener('mousewheel', this.onMouseWheel, {\n              passive: false\n            });\n          }\n\n          ref.addEventListener('touchstart', this.onTouchStart, {\n            passive: false\n          });\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        window.removeEventListener('touchmove', this.onTouchMove);\n        window.removeEventListener('touchend', this.onTouchEnd);\n        cancelAnimationFrame(this.rqf);\n        clearTimeout(this.timeout);\n        var ref = this.childRef.current;\n\n        if (ref) {\n          ref.removeEventListener('mousewheel', this.onMouseWheel);\n          ref.removeEventListener('touchstart', this.onTouchStart);\n        }\n\n        toggleTextSelection(true);\n      }\n    }, {\n      key: \"getStep\",\n      value: function getStep(delta) {\n        var scaleFactor = this.props.scaleFactor;\n        return -delta > 0 ? scaleFactor + 1 : 1 - scaleFactor;\n      }\n    }, {\n      key: \"scale\",\n      value: function scale(x, y, step, nativeEvent) {\n        var _this$props35 = this.props,\n            minZoom = _this$props35.minZoom,\n            maxZoom = _this$props35.maxZoom,\n            onZoom = _this$props35.onZoom,\n            matrix = _this$props35.matrix;\n        var outside = isZoomLevelGoingOutOfBounds({\n          d: matrix.a,\n          scaleFactorMin: minZoom,\n          scaleFactorMax: maxZoom\n        }, step);\n\n        if (!outside) {\n          var newMatrix = transformationMatrix.smoothMatrix(transformationMatrix.transform(matrix, transformationMatrix.translate(x, y), transformationMatrix.scale(step, step), transformationMatrix.translate(-x, -y)), 100);\n          this.rqf = requestAnimationFrame(function () {\n            onZoom({\n              scale: newMatrix.a,\n              x: newMatrix.e,\n              y: newMatrix.f,\n              nativeEvent: nativeEvent\n            });\n          });\n        }\n\n        return outside;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props36 = this.props,\n            style = _this$props36.style,\n            children = _this$props36.children;\n        return jsxRuntime.jsx(\"g\", Object.assign({\n          ref: this.childRef,\n          style: style\n        }, {\n          children: children\n        }), void 0);\n      }\n    }]);\n\n    return Zoom;\n  }(react.Component);\n\n  Zoom.defaultProps = {\n    x: 0,\n    y: 0,\n    scale: 1,\n    scaleFactor: 0.1,\n    minZoom: 1,\n    maxZoom: 10\n  };\n  var css_248z$q = \".DiscreteLegend-module_container__MpmKP {\\n  display: flex;\\n  overflow: auto;\\n}\\n\\n  .DiscreteLegend-module_container__MpmKP.DiscreteLegend-module_horizontal__3Mt5B {\\n    align-items: center;\\n    flex-direction: row;\\n  }\\n\\n  .DiscreteLegend-module_container__MpmKP.DiscreteLegend-module_vertical__M1d-S {\\n    flex-direction: column;\\n  }\\n\";\n  var css$q = {\n    \"container\": \"DiscreteLegend-module_container__MpmKP\",\n    \"horizontal\": \"DiscreteLegend-module_horizontal__3Mt5B\",\n    \"vertical\": \"DiscreteLegend-module_vertical__M1d-S\"\n  };\n  styleInject(css_248z$q);\n\n  var DiscreteLegend = function DiscreteLegend(_ref7) {\n    var _classNames__default$2;\n\n    var entries = _ref7.entries,\n        orientation = _ref7.orientation,\n        style = _ref7.style,\n        className = _ref7.className;\n    return jsxRuntime.jsx(\"div\", Object.assign({\n      className: classNames__default['default'](css$q.container, className, (_classNames__default$2 = {}, _defineProperty(_classNames__default$2, css$q.horizontal, orientation === 'horizontal'), _defineProperty(_classNames__default$2, css$q.vertical, orientation === 'vertical'), _classNames__default$2)),\n      style: style\n    }, {\n      children: entries.map(function (entry, index) {\n        return jsxRuntime.jsx(rdk.CloneElement, {\n          element: entry,\n          orientation: orientation\n        }, \"dle-\".concat(index));\n      })\n    }), void 0);\n  };\n\n  DiscreteLegend.defaultProps = {\n    orientation: 'vertical'\n  };\n  var css_248z$p = \".DiscreteLegendSymbol-module_symbol__1n4Gb {\\n  width: 15px;\\n  height: 3px;\\n}\\n\";\n  var css$p = {\n    \"symbol\": \"DiscreteLegendSymbol-module_symbol__1n4Gb\"\n  };\n  styleInject(css_248z$p);\n\n  var DiscreteLegendSymbol = function DiscreteLegendSymbol(_ref8) {\n    var className = _ref8.className,\n        color = _ref8.color;\n    return jsxRuntime.jsx(\"div\", {\n      className: classNames__default['default'](css$p.symbol, className),\n      style: {\n        background: color\n      }\n    }, void 0);\n  };\n\n  var css_248z$o = \".DiscreteLegendEntry-module_entry__2kjdn {\\n  display: flex;\\n  color: var(--color-on-primary);\\n  padding: 8px;\\n  will-change: transparency;\\n  transition: opacity 150ms ease-in;\\n}\\n\\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_vertical__2LxhZ {\\n    flex-direction: row;\\n    align-items: center;\\n  }\\n\\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_vertical__2LxhZ:first-child {\\n      padding-top: 0;\\n    }\\n\\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_vertical__2LxhZ:last-child {\\n      padding-bottom: 0;\\n    }\\n\\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_vertical__2LxhZ .DiscreteLegendEntry-module_label__2e4-v {\\n      margin-left: 8px;\\n    }\\n\\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_vertical__2LxhZ svg {\\n      display: block;\\n      margin: 0 auto;\\n    }\\n\\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_horizontal__37dGv {\\n    align-items: center;\\n    flex-direction: row;\\n  }\\n\\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_horizontal__37dGv:first-child {\\n      padding-left: 0;\\n    }\\n\\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_horizontal__37dGv:last-child {\\n      padding-right: 0;\\n    }\\n\\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_horizontal__37dGv .DiscreteLegendEntry-module_label__2e4-v {\\n      margin-left: 8px;\\n    }\\n\\n  .DiscreteLegendEntry-module_entry__2kjdn .DiscreteLegendEntry-module_label__2e4-v {\\n    font-size: 12px;\\n  }\\n\\n  .DiscreteLegendEntry-module_entry__2kjdn svg {\\n    width: 15px;\\n    height: 15px;\\n  }\\n\";\n  var css$o = {\n    \"entry\": \"DiscreteLegendEntry-module_entry__2kjdn\",\n    \"vertical\": \"DiscreteLegendEntry-module_vertical__2LxhZ\",\n    \"label\": \"DiscreteLegendEntry-module_label__2e4-v\",\n    \"horizontal\": \"DiscreteLegendEntry-module_horizontal__37dGv\"\n  };\n  styleInject(css_248z$o);\n\n  var DiscreteLegendEntry = function DiscreteLegendEntry(_ref9) {\n    var _classNames__default$3;\n\n    var label = _ref9.label,\n        symbol = _ref9.symbol,\n        title = _ref9.title,\n        className = _ref9.className,\n        color = _ref9.color,\n        style = _ref9.style,\n        orientation = _ref9.orientation,\n        onMouseEnter = _ref9.onMouseEnter,\n        onMouseLeave = _ref9.onMouseLeave,\n        onClick = _ref9.onClick;\n    return jsxRuntime.jsxs(\"div\", Object.assign({\n      title: title,\n      className: classNames__default['default'](css$o.entry, className, (_classNames__default$3 = {}, _defineProperty(_classNames__default$3, css$o.vertical, orientation === 'vertical'), _defineProperty(_classNames__default$3, css$o.horizontal, orientation === 'horizontal'), _classNames__default$3)),\n      onClick: onClick,\n      onMouseEnter: onMouseEnter,\n      onMouseLeave: onMouseLeave,\n      style: style\n    }, {\n      children: [jsxRuntime.jsx(rdk.CloneElement, {\n        element: symbol,\n        color: color\n      }, void 0), jsxRuntime.jsx(\"span\", Object.assign({\n        className: css$o.label\n      }, {\n        children: label\n      }), void 0)]\n    }), void 0);\n  };\n\n  DiscreteLegendEntry.defaultProps = {\n    symbol: jsxRuntime.jsx(DiscreteLegendSymbol, {}, void 0),\n    orientation: 'horizontal'\n  };\n  var css_248z$n = \".SequentialLegend-module_container__2EkZd {\\n  display: flex;\\n  height: 100%;\\n}\\n\\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_vertical__1DXNP {\\n    flex-direction: column;\\n    max-width: 55px;\\n  }\\n\\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_vertical__1DXNP .SequentialLegend-module_start__1Pb9A,\\n    .SequentialLegend-module_container__2EkZd.SequentialLegend-module_vertical__1DXNP .SequentialLegend-module_end__3RWw0 {\\n      text-align: center;\\n      padding: 5px 0;\\n      width: 100%;\\n    }\\n\\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_vertical__1DXNP .SequentialLegend-module_gradient__3aF0r {\\n      width: 25px;\\n      margin: 0 auto;\\n    }\\n\\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_horizontal__2Q9EA {\\n    flex-direction: row-reverse;\\n  }\\n\\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_horizontal__2Q9EA .SequentialLegend-module_start__1Pb9A,\\n    .SequentialLegend-module_container__2EkZd.SequentialLegend-module_horizontal__2Q9EA .SequentialLegend-module_end__3RWw0 {\\n      max-width: 20%;\\n    }\\n\\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_horizontal__2Q9EA .SequentialLegend-module_start__1Pb9A {\\n      text-align: right;\\n      padding-left: 5px;\\n    }\\n\\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_horizontal__2Q9EA .SequentialLegend-module_end__3RWw0 {\\n      text-align: left;\\n      padding-right: 5px;\\n    }\\n\\n  .SequentialLegend-module_container__2EkZd .SequentialLegend-module_gradient__3aF0r {\\n    flex: 1;\\n    width: 100%;\\n    border-radius: 2px;\\n  }\\n\\n  .SequentialLegend-module_container__2EkZd .SequentialLegend-module_start__1Pb9A,\\n  .SequentialLegend-module_container__2EkZd .SequentialLegend-module_end__3RWw0 {\\n    color: var(--color-on-primary);\\n    font-size: 12px;\\n    white-space: nowrap;\\n    overflow: hidden;\\n    text-overflow: ellipsis;\\n  }\\n\\n[dir=\\\"ltr\\\"] :export {\\n  start-top: SequentialLegend-module_start__1Pb9A;\\n  start-left: SequentialLegend-module_start__1Pb9A;\\n}\\n\\n[dir=\\\"rtl\\\"] :export {\\n  start-top: SequentialLegend-module_start__1Pb9A;\\n  start-right: SequentialLegend-module_start__1Pb9A;\\n}\\n\\n[dir=\\\"ltr\\\"] :export {\\n  end-bottom: SequentialLegend-module_end__3RWw0;\\n  end-right: SequentialLegend-module_end__3RWw0;\\n}\\n\\n[dir=\\\"rtl\\\"] :export {\\n  end-bottom: SequentialLegend-module_end__3RWw0;\\n  end-left: SequentialLegend-module_end__3RWw0;\\n}\\n\";\n  var css$n = {\n    \"container\": \"SequentialLegend-module_container__2EkZd\",\n    \"vertical\": \"SequentialLegend-module_vertical__1DXNP\",\n    \"gradient\": \"SequentialLegend-module_gradient__3aF0r\",\n    \"horizontal\": \"SequentialLegend-module_horizontal__2Q9EA\"\n  };\n  styleInject(css_248z$n);\n\n  var SequentialLegend = /*#__PURE__*/function (_react$PureComponent7) {\n    _inherits(SequentialLegend, _react$PureComponent7);\n\n    function SequentialLegend() {\n      _classCallCheck(this, SequentialLegend);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(SequentialLegend).apply(this, arguments));\n    }\n\n    _createClass(SequentialLegend, [{\n      key: \"render\",\n      value: function render() {\n        var _classNames__default$4;\n\n        var _this$props37 = this.props,\n            orientation = _this$props37.orientation,\n            className = _this$props37.className,\n            style = _this$props37.style,\n            colorScheme = _this$props37.colorScheme,\n            data = _this$props37.data; // Generate the color gradient\n\n        var color = chroma__default['default'].scale(colorScheme).colors(10).reverse().map(function (c, i) {\n          return \"\".concat(c, \" \").concat(i * 10, \"%\");\n        }).join(','); // Get the extent from the data passed\n\n        var _d3Array$extent = d3Array.extent(uniqueBy(data, function (d) {\n          return d.data;\n        }, function (d) {\n          return d.data;\n        })),\n            _d3Array$extent2 = _slicedToArray(_d3Array$extent, 2),\n            end = _d3Array$extent2[0],\n            start = _d3Array$extent2[1]; // Get direction\n\n\n        var gradientDir = orientation === 'vertical' ? '' : 'to left,';\n        return jsxRuntime.jsxs(\"div\", Object.assign({\n          style: style,\n          className: classNames__default['default'](css$n.container, className, (_classNames__default$4 = {}, _defineProperty(_classNames__default$4, css$n.vertical, orientation === 'vertical'), _defineProperty(_classNames__default$4, css$n.horizontal, orientation === 'horizontal'), _classNames__default$4))\n        }, {\n          children: [jsxRuntime.jsx(\"div\", Object.assign({\n            className: css$n.start\n          }, {\n            children: formatValue(start)\n          }), void 0), jsxRuntime.jsx(\"div\", {\n            className: css$n.gradient,\n            style: {\n              background: \"linear-gradient(\".concat(gradientDir).concat(color, \")\")\n            }\n          }, void 0), jsxRuntime.jsx(\"div\", Object.assign({\n            className: css$n.end\n          }, {\n            children: formatValue(end)\n          }), void 0)]\n        }), void 0);\n      }\n    }]);\n\n    return SequentialLegend;\n  }(react.PureComponent);\n\n  SequentialLegend.defaultProps = {\n    colorScheme: ['rgba(28, 107, 86, 0.5)', '#2da283'],\n    orientation: 'vertical'\n  };\n  var css_248z$m = \".Gridline-module_gridLine__1K6sy {\\n  shape-rendering: crispEdges;\\n  pointer-events: none;\\n}\\n\";\n  var css$m = {\n    \"gridLine\": \"Gridline-module_gridLine__1K6sy\"\n  };\n  styleInject(css_248z$m);\n\n  var Gridline = function Gridline(_ref10) {\n    var strokeWidth = _ref10.strokeWidth,\n        direction = _ref10.direction,\n        className = _ref10.className,\n        strokeColor = _ref10.strokeColor,\n        data = _ref10.data,\n        height = _ref10.height,\n        width = _ref10.width,\n        scale = _ref10.scale,\n        strokeDasharray = _ref10.strokeDasharray;\n    var coords = react.useMemo(function () {\n      var pos = scale(data);\n\n      if (direction === 'x') {\n        return {\n          x1: pos,\n          x2: pos,\n          y1: 0,\n          y2: height\n        };\n      } else {\n        return {\n          y1: pos,\n          y2: pos,\n          x1: 0,\n          x2: width\n        };\n      }\n    }, [direction, data, height, width, scale]);\n    return jsxRuntime.jsx(\"line\", Object.assign({}, coords, {\n      className: classNames__default['default'](css$m.gridLine, className),\n      strokeDasharray: strokeDasharray,\n      strokeWidth: strokeWidth,\n      stroke: strokeColor,\n      fill: \"none\"\n    }), void 0);\n  };\n\n  Gridline.defaultProps = {\n    strokeWidth: 1,\n    strokeDasharray: '2 5',\n    direction: 'all',\n    strokeColor: 'rgba(153, 153, 153, 0.5)'\n  };\n\n  var GridlineSeries = function GridlineSeries(_ref11) {\n    var line = _ref11.line,\n        stripe = _ref11.stripe,\n        yScale = _ref11.yScale,\n        xScale = _ref11.xScale,\n        yAxis = _ref11.yAxis,\n        xAxis = _ref11.xAxis,\n        height = _ref11.height,\n        width = _ref11.width;\n\n    var shouldRenderY = function shouldRenderY(direction) {\n      return direction === 'all' || direction === 'y';\n    };\n\n    var shouldRenderX = function shouldRenderX(direction) {\n      return direction === 'all' || direction === 'x';\n    };\n\n    var getSkipIndex = react.useCallback(function (direction) {\n      if (direction === 'x' && yAxis.axisLine !== null && yAxis.position === 'start' || direction === 'y' && xAxis.axisLine !== null && xAxis.position === 'end') {\n        return 0;\n      }\n\n      return null;\n    }, [xAxis, yAxis]);\n\n    var _react$useMemo = react.useMemo(function () {\n      return {\n        yAxisGrid: _getTicks(yScale, yAxis.tickSeries.props.tickValues, yAxis.type, getMaxTicks(yAxis.tickSeries.props.tickSize, height), yAxis.tickSeries.props.interval),\n        xAxisGrid: _getTicks(xScale, xAxis.tickSeries.props.tickValues, xAxis.type, getMaxTicks(xAxis.tickSeries.props.tickSize, width), xAxis.tickSeries.props.interval)\n      };\n    }, [height, width, xAxis, yAxis, yScale, xScale]),\n        yAxisGrid = _react$useMemo.yAxisGrid,\n        xAxisGrid = _react$useMemo.xAxisGrid;\n\n    var renderGroup = react.useCallback(function (element, grid, scale, direction, type) {\n      var skipIdx = getSkipIndex(direction);\n      return grid.map(function (point, index) {\n        return jsxRuntime.jsx(react.Fragment, {\n          children: index !== skipIdx && jsxRuntime.jsx(rdk.CloneElement, {\n            element: element,\n            index: index,\n            scale: scale,\n            data: point,\n            height: height,\n            width: width,\n            direction: direction\n          }, void 0)\n        }, \"\".concat(type, \"-\").concat(direction, \"-\").concat(index));\n      });\n    }, [getSkipIndex, height, width]);\n    var renderSeries = react.useCallback(function (yAxisGrid, xAxisGrid, element, type) {\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [shouldRenderY(element.props.direction) && renderGroup(element, yAxisGrid, yScale, 'y', type), shouldRenderX(element.props.direction) && renderGroup(element, xAxisGrid, xScale, 'x', type)]\n      }, void 0);\n    }, [renderGroup, xScale, yScale]);\n    return jsxRuntime.jsxs(\"g\", Object.assign({\n      style: {\n        pointerEvents: 'none'\n      }\n    }, {\n      children: [line && renderSeries(yAxisGrid, xAxisGrid, line, 'line'), stripe && renderSeries(yAxisGrid, xAxisGrid, stripe, 'stripe')]\n    }), void 0);\n  };\n\n  GridlineSeries.defaultProps = {\n    line: jsxRuntime.jsx(Gridline, {\n      direction: \"all\"\n    }, void 0),\n    stripe: null\n  };\n  var css_248z$l = \".GridStripe-module_gridStripe__1UttV {\\n  pointer-events: none;\\n}\\n\";\n  var css$l = {\n    \"gridStripe\": \"GridStripe-module_gridStripe__1UttV\"\n  };\n  styleInject(css_248z$l);\n\n  var GridStripe = function GridStripe(_ref12) {\n    var fill = _ref12.fill,\n        className = _ref12.className,\n        position = _ref12.position,\n        data = _ref12.data,\n        height = _ref12.height,\n        width = _ref12.width,\n        scale = _ref12.scale,\n        index = _ref12.index;\n    var coords = react.useMemo(function () {\n      var pos = scale(data);\n      var stripeFill = index % 2 ? 'none' : fill;\n      var dim = scale.bandwidth();\n\n      if (position === 'vertical') {\n        return {\n          y: 0,\n          x: pos,\n          height: height,\n          width: dim,\n          fill: stripeFill\n        };\n      } else {\n        return {\n          y: pos,\n          x: 0,\n          height: dim,\n          width: width,\n          fill: stripeFill\n        };\n      }\n    }, [scale, data, index, height, width, fill, position]);\n    return jsxRuntime.jsx(\"rect\", Object.assign({\n      className: classNames__default['default'](css$l.gridStripe, className)\n    }, coords), void 0);\n  };\n\n  GridStripe.defaultProps = {\n    fill: '#393c3e'\n  };\n  var css_248z$k = \".MarkLine-module_markLine__2002U {\\n  pointer-events: none;\\n  stroke-dasharray: 4, 4;\\n  stroke-linecap: round;\\n}\\n\";\n  var css$k = {\n    \"markLine\": \"MarkLine-module_markLine__2002U\"\n  };\n  styleInject(css_248z$k);\n\n  var MarkLine = function MarkLine(_ref13) {\n    var pointX = _ref13.pointX,\n        height = _ref13.height,\n        _ref13$strokeWidth = _ref13.strokeWidth,\n        strokeWidth = _ref13$strokeWidth === void 0 ? 1 : _ref13$strokeWidth,\n        _ref13$strokeColor = _ref13.strokeColor,\n        strokeColor = _ref13$strokeColor === void 0 ? '#eee' : _ref13$strokeColor;\n    return jsxRuntime.jsx(\"line\", {\n      stroke: strokeColor,\n      strokeWidth: strokeWidth,\n      y1: \"0\",\n      vectorEffect: \"non-scaling-stroke\",\n      y2: height,\n      x1: pointX,\n      x2: pointX,\n      className: css$k.markLine\n    }, void 0);\n  };\n\n  var GradientStop = function GradientStop(_ref14) {\n    var color = _ref14.color,\n        offset = _ref14.offset,\n        _ref14$stopOpacity = _ref14.stopOpacity,\n        stopOpacity = _ref14$stopOpacity === void 0 ? 1 : _ref14$stopOpacity;\n    return jsxRuntime.jsx(\"stop\", {\n      offset: offset,\n      stopOpacity: stopOpacity,\n      stopColor: color\n    }, void 0);\n  };\n\n  var Gradient = function Gradient(_ref15) {\n    var id = _ref15.id,\n        color = _ref15.color,\n        _ref15$direction = _ref15.direction,\n        direction = _ref15$direction === void 0 ? 'vertical' : _ref15$direction,\n        _ref15$stops = _ref15.stops,\n        stops = _ref15$stops === void 0 ? [jsxRuntime.jsx(GradientStop, {\n      offset: \"0%\",\n      stopOpacity: 0.3\n    }, \"start\"), jsxRuntime.jsx(GradientStop, {\n      offset: \"80%\",\n      stopOpacity: 1\n    }, \"stop\")] : _ref15$stops;\n    var pos = direction === 'vertical' ? {\n      x1: '10%',\n      x2: '10%',\n      y1: '100%',\n      y2: '0%'\n    } : {\n      y1: '0%',\n      y2: '0%',\n      x1: '0%',\n      x2: '100%'\n    };\n    return jsxRuntime.jsx(\"linearGradient\", Object.assign({\n      spreadMethod: \"pad\",\n      id: id\n    }, pos, {\n      children: stops.map(function (stop, index) {\n        return jsxRuntime.jsx(rdk.CloneElement, {\n          element: stop,\n          color: stop.props.color || color\n        }, \"gradient-\".concat(index));\n      })\n    }), void 0);\n  };\n\n  var RadialGradient = function RadialGradient(_ref16) {\n    var id = _ref16.id,\n        color = _ref16.color,\n        _ref16$radius = _ref16.radius,\n        radius = _ref16$radius === void 0 ? '30%' : _ref16$radius,\n        _ref16$stops = _ref16.stops,\n        stops = _ref16$stops === void 0 ? [jsxRuntime.jsx(GradientStop, {\n      offset: \"0%\",\n      stopOpacity: 0.2\n    }, \"start\"), jsxRuntime.jsx(GradientStop, {\n      offset: \"80%\",\n      stopOpacity: 0.7\n    }, \"stop\")] : _ref16$stops;\n    return jsxRuntime.jsx(\"radialGradient\", Object.assign({\n      id: id,\n      cx: 0,\n      cy: 0,\n      r: radius,\n      gradientUnits: \"userSpaceOnUse\"\n    }, {\n      children: stops.map(function (stop, index) {\n        return jsxRuntime.jsx(rdk.CloneElement, {\n          element: stop,\n          color: color\n        }, \"gradient-\".concat(index));\n      })\n    }), void 0);\n  };\n\n  var Mask = function Mask(_ref17) {\n    var id = _ref17.id,\n        fill = _ref17.fill;\n    return jsxRuntime.jsx(\"mask\", Object.assign({\n      id: id\n    }, {\n      children: jsxRuntime.jsx(\"rect\", {\n        x: \"0\",\n        y: \"0\",\n        width: \"100%\",\n        height: \"100%\",\n        fill: fill\n      }, void 0)\n    }), void 0);\n  };\n\n  var Stripes = function Stripes(_ref18) {\n    var id = _ref18.id,\n        fill = _ref18.fill;\n    return jsxRuntime.jsx(\"pattern\", Object.assign({\n      id: id,\n      width: \"4\",\n      height: \"4\",\n      patternUnits: \"userSpaceOnUse\",\n      patternTransform: \"rotate(45)\"\n    }, {\n      children: jsxRuntime.jsx(\"rect\", {\n        className: \"area-stripe\",\n        width: \"1\",\n        height: \"4\",\n        fill: fill\n      }, void 0)\n    }), void 0);\n  };\n\n  var css_248z$j = \".TooltipTemplate-module_label__1-9Eq {\\n  font-size: 16px;\\n  margin-bottom: 3px;\\n  color: var(--color-on-tooltip);\\n}\\n\\n.TooltipTemplate-module_value__3RhFW {\\n  font-size: 13px;\\n  color: var(--color-on-tooltip);\\n  opacity: 0.7;\\n}\\n\\n.TooltipTemplate-module_subValue__2jKhI {\\n  display: block;\\n  text-align: left;\\n  padding: 3px 5px;\\n}\\n\\n.TooltipTemplate-module_subValue__2jKhI .TooltipTemplate-module_subValueColor__2Mkos {\\n    width: 5px;\\n    height: 15px;\\n    margin-right: 8px;\\n    display: inline-block;\\n  }\\n\\n.TooltipTemplate-module_subValue__2jKhI .TooltipTemplate-module_subValueName__MtlOy {\\n    margin-right: 5px;\\n  }\\n\";\n  var css$j = {\n    \"label\": \"TooltipTemplate-module_label__1-9Eq\",\n    \"value\": \"TooltipTemplate-module_value__3RhFW\",\n    \"subValue\": \"TooltipTemplate-module_subValue__2jKhI\",\n    \"subValueColor\": \"TooltipTemplate-module_subValueColor__2Mkos\",\n    \"subValueName\": \"TooltipTemplate-module_subValueName__MtlOy\"\n  };\n  styleInject(css_248z$j);\n\n  var TooltipTemplate = function TooltipTemplate(_ref19) {\n    var value = _ref19.value,\n        color = _ref19.color,\n        className = _ref19.className;\n\n    if (!value) {\n      return null;\n    }\n\n    var renderValues = function renderValues(data, index) {\n      var fill = color(data, index);\n      return jsxRuntime.jsxs(\"span\", Object.assign({\n        className: css$j.subValue\n      }, {\n        children: [jsxRuntime.jsx(\"span\", {\n          className: css$j.subValueColor,\n          style: {\n            backgroundColor: fill\n          }\n        }, void 0), jsxRuntime.jsxs(\"span\", Object.assign({\n          className: css$j.subValueName\n        }, {\n          children: [formatValue(data.key || data.x), \":\"]\n        }), void 0), jsxRuntime.jsx(\"span\", {\n          children: formatValue(data.value || data.y)\n        }, void 0)]\n      }), void 0);\n    };\n\n    var renderMultiple = function renderMultiple(value) {\n      var excessCount = value.data.length - 15;\n      var pagedValues = value.data.slice(0, 15);\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [pagedValues.map(function (point, i) {\n          return jsxRuntime.jsx(react.Fragment, {\n            children: renderValues(point, i)\n          }, i);\n        }), excessCount > 0 && jsxRuntime.jsxs(\"div\", {\n          children: [\"...\", excessCount, \" more...\"]\n        }, void 0)]\n      }, void 0);\n    };\n\n    var isMultiple = Array.isArray(value.data);\n    return jsxRuntime.jsxs(\"div\", Object.assign({\n      className: className,\n      role: \"tooltip\"\n    }, {\n      children: [jsxRuntime.jsx(\"div\", Object.assign({\n        className: css$j.label\n      }, {\n        children: formatValue(value.x)\n      }), void 0), jsxRuntime.jsxs(\"div\", Object.assign({\n        className: css$j.value\n      }, {\n        children: [isMultiple && renderMultiple(value), !isMultiple && jsxRuntime.jsx(react.Fragment, {\n          children: formatValue(value.value || value.y)\n        }, void 0)]\n      }), void 0)]\n    }), void 0);\n  };\n\n  var ChartTooltip = function ChartTooltip(_a) {\n    var _content = _a.content,\n        value = _a.value,\n        data = _a.data,\n        color = _a.color,\n        rest = __rest(_a, [\"content\", \"value\", \"data\", \"color\"]);\n\n    return jsxRuntime.jsx(realayers.Tooltip, Object.assign({}, rest, {\n      content: function content() {\n        if (!value && !data) {\n          return null;\n        }\n\n        return typeof _content === 'function' ? _content(data || value, color) : react.cloneElement(_content, Object.assign(Object.assign({}, _content.props), {\n          value: value,\n          color: color\n        }));\n      }\n    }), void 0);\n  };\n\n  ChartTooltip.defaultProps = {\n    content: jsxRuntime.jsx(TooltipTemplate, {}, void 0)\n  };\n\n  var TooltipArea = /*#__PURE__*/function (_react$Component21) {\n    _inherits(TooltipArea, _react$Component21);\n\n    function TooltipArea() {\n      var _this12;\n\n      _classCallCheck(this, TooltipArea);\n\n      _this12 = _possibleConstructorReturn(this, _getPrototypeOf(TooltipArea).apply(this, arguments));\n      _this12.state = {};\n      _this12.ref = react.createRef();\n      _this12.transformData = memoize__default['default'](function (series) {\n        var _this12$props = _this12.props,\n            inverse = _this12$props.inverse,\n            isHorizontal = _this12$props.isHorizontal;\n        var result = [];\n\n        if (inverse) {\n          var _iterator21 = _createForOfIteratorHelper(series),\n              _step21;\n\n          try {\n            for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n              var point = _step21.value;\n              var seriesPoint = point;\n\n              if (Array.isArray(seriesPoint.data)) {\n                var _iterator22 = _createForOfIteratorHelper(seriesPoint.data),\n                    _step22;\n\n                try {\n                  var _loop5 = function _loop5() {\n                    var nestedPoint = _step22.value;\n                    var right = nestedPoint.x;\n                    var idx = result.findIndex(function (r) {\n                      var left = r.x;\n\n                      if (left instanceof Date && right instanceof Date) {\n                        return left.getTime() === right.getTime();\n                      }\n\n                      return left === right;\n                    });\n\n                    if (idx === -1) {\n                      result.push({\n                        x: nestedPoint.x,\n                        data: []\n                      });\n                      idx = result.length - 1;\n                    }\n\n                    var data = result[idx].data;\n\n                    if (Array.isArray(data)) {\n                      data.push(nestedPoint);\n                    }\n                  };\n\n                  for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                    _loop5();\n                  }\n                } catch (err) {\n                  _iterator22.e(err);\n                } finally {\n                  _iterator22.f();\n                }\n              } else {\n                result.push(point);\n              }\n            }\n          } catch (err) {\n            _iterator21.e(err);\n          } finally {\n            _iterator21.f();\n          }\n        } else {\n          var _iterator23 = _createForOfIteratorHelper(series),\n              _step23;\n\n          try {\n            for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n              var _point3 = _step23.value;\n              var nestedPoint = _point3;\n\n              if (Array.isArray(nestedPoint.data)) {\n                result.push(Object.assign(Object.assign({}, nestedPoint), {\n                  x: nestedPoint.key,\n                  data: nestedPoint.data.map(function (d) {\n                    return Object.assign(Object.assign({}, d), {\n                      key: !isHorizontal ? d.x : d.y,\n                      value: !isHorizontal ? d.y : d.x\n                    });\n                  })\n                }));\n              } else {\n                var shallowPoint = _point3;\n                result.push(Object.assign(Object.assign({}, shallowPoint), {\n                  // Histograms special logic...\n                  x: shallowPoint.key === undefined ? shallowPoint.x0 : _point3.key,\n                  y: shallowPoint.value === undefined ? shallowPoint.y : shallowPoint.value\n                }));\n              }\n            }\n          } catch (err) {\n            _iterator23.e(err);\n          } finally {\n            _iterator23.f();\n          }\n        }\n\n        return result;\n      });\n      return _this12;\n    }\n\n    _createClass(TooltipArea, [{\n      key: \"getXCoord\",\n      value: function getXCoord(x, y) {\n        var _this$props38 = this.props,\n            isRadial = _this$props38.isRadial,\n            width = _this$props38.width,\n            height = _this$props38.height; // If the shape is radial, we need to convert the X coords to a radial format.\n\n        if (isRadial) {\n          var outerRadius = Math.min(width, height) / 2;\n          var rad = Math.atan2(y - outerRadius, x - outerRadius) + Math.PI / 2; // TODO: Figure out what the 'correct' way to do this is...\n\n          if (rad < 0) {\n            rad += Math.PI * 2;\n          }\n\n          return rad;\n        }\n\n        return x;\n      }\n    }, {\n      key: \"onMouseMove\",\n      value: function onMouseMove(event) {\n        var _this$props39 = this.props,\n            xScale = _this$props39.xScale,\n            yScale = _this$props39.yScale,\n            onValueEnter = _this$props39.onValueEnter,\n            height = _this$props39.height,\n            width = _this$props39.width,\n            data = _this$props39.data,\n            isRadial = _this$props39.isRadial,\n            isHorizontal = _this$props39.isHorizontal,\n            placement = _this$props39.placement;\n        var value = this.state.value;\n        var transformed = this.transformData(data); // Get our default placement\n\n        var newPlacement = placement;\n\n        if (!placement) {\n          if (isHorizontal) {\n            newPlacement = 'right';\n          } else {\n            newPlacement = 'top';\n          }\n        } // Get the path container element\n\n\n        var target = this.ref.current;\n\n        var _getPositionForTarget = getPositionForTarget({\n          target: target,\n          // Manually pass the x/y from the event\n          clientX: event.clientX,\n          clientY: event.clientY\n        }),\n            y = _getPositionForTarget.y,\n            x = _getPositionForTarget.x; // Need to flip scales/coords if we are a horz layout\n\n\n        var keyScale;\n        var valueScale;\n        var coord;\n\n        if (isHorizontal) {\n          keyScale = yScale;\n          valueScale = xScale;\n          coord = y;\n        } else {\n          coord = this.getXCoord(x, y);\n          keyScale = xScale;\n          valueScale = yScale;\n        }\n\n        var newValue = getClosestPoint(coord, keyScale, transformed);\n\n        if (!isEqual__default['default'](newValue, value) && newValue) {\n          var pointX = keyScale(newValue.x);\n          var pointY = valueScale(newValue.y);\n          var marginX = 0;\n          var marginY = 0;\n\n          if (isNaN(pointY)) {\n            pointY = height / 2;\n            marginX = 10;\n\n            if (!placement) {\n              newPlacement = 'right';\n            }\n          } else {\n            marginY = -10;\n          } // If the points didn't change, don't trigger an update\n\n\n          if (pointX === this.prevX && pointY === this.prevY) {\n            return;\n          }\n\n          this.prevY = pointY;\n          this.prevX = pointX;\n          var _target = event.target;\n\n          var _target$getBoundingCl2 = _target.getBoundingClientRect(),\n              top = _target$getBoundingCl2.top,\n              left = _target$getBoundingCl2.left;\n\n          var offsetX = 0;\n          var offsetY = 0;\n\n          if (isRadial) {\n            // If its radial, we need to convert the coords to radial format\n            var outerRadius = Math.min(width, height) / 2;\n            offsetX = pointY * Math.cos(pointX - Math.PI / 2) + outerRadius;\n            offsetY = pointY * Math.sin(pointX - Math.PI / 2) + outerRadius;\n          } else {\n            offsetX = pointX;\n            offsetY = pointY;\n          }\n\n          offsetX += left + marginX;\n          offsetY += top + marginY;\n          this.setState({\n            placement: newPlacement,\n            visible: true,\n            value: newValue,\n            offsetX: offsetX,\n            offsetY: offsetY\n          });\n          onValueEnter({\n            visible: true,\n            value: newValue,\n            pointY: pointY,\n            pointX: pointX,\n            offsetX: offsetX,\n            offsetY: offsetY,\n            nativeEvent: event\n          });\n        }\n      }\n    }, {\n      key: \"onMouseLeave\",\n      value: function onMouseLeave() {\n        this.prevX = undefined;\n        this.prevY = undefined;\n        this.setState({\n          value: undefined,\n          visible: false\n        });\n        this.props.onValueLeave();\n      }\n    }, {\n      key: \"getTooltipReference\",\n      value: function getTooltipReference() {\n        var _this$state2 = this.state,\n            offsetX = _this$state2.offsetX,\n            offsetY = _this$state2.offsetY;\n        return {\n          width: 4,\n          height: 4,\n          top: offsetY,\n          left: offsetX\n        };\n      }\n    }, {\n      key: \"renderRadial\",\n      value: function renderRadial() {\n        var _this$props40 = this.props,\n            height = _this$props40.height,\n            width = _this$props40.width,\n            innerRadius = _this$props40.innerRadius,\n            outerRadius = _this$props40.outerRadius;\n        innerRadius = innerRadius || 0;\n        outerRadius = outerRadius || Math.min(width, height) / 2;\n        var d = d3Shape.arc()({\n          innerRadius: innerRadius,\n          outerRadius: outerRadius,\n          startAngle: 180,\n          endAngle: Math.PI / 2\n        });\n        return jsxRuntime.jsx(\"path\", {\n          d: d,\n          opacity: \"0\",\n          cursor: \"auto\",\n          ref: this.ref,\n          onMouseMove: bind__default['default'](this.onMouseMove, this)\n        }, void 0);\n      }\n    }, {\n      key: \"renderLinear\",\n      value: function renderLinear() {\n        var _this$props41 = this.props,\n            height = _this$props41.height,\n            width = _this$props41.width;\n        return jsxRuntime.jsx(\"rect\", {\n          height: height,\n          ref: this.ref,\n          width: width,\n          opacity: 0,\n          cursor: \"auto\",\n          onMouseMove: bind__default['default'](this.onMouseMove, this)\n        }, void 0);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props42 = this.props,\n            isRadial = _this$props42.isRadial,\n            children = _this$props42.children,\n            tooltip = _this$props42.tooltip,\n            disabled = _this$props42.disabled,\n            color = _this$props42.color;\n        var _this$state3 = this.state,\n            visible = _this$state3.visible,\n            placement = _this$state3.placement,\n            value = _this$state3.value;\n        return jsxRuntime.jsxs(react.Fragment, {\n          children: [disabled && children, !disabled && jsxRuntime.jsxs(\"g\", Object.assign({\n            onMouseLeave: bind__default['default'](this.onMouseLeave, this)\n          }, {\n            children: [isRadial && this.renderRadial(), !isRadial && this.renderLinear(), jsxRuntime.jsx(rdk.CloneElement, {\n              element: tooltip,\n              visible: visible,\n              placement: placement,\n              modifiers: {\n                offset: {\n                  offset: '0, 15px'\n                }\n              },\n              reference: this.getTooltipReference(),\n              color: color,\n              value: value\n            }, void 0), children]\n          }), void 0)]\n        }, void 0);\n      }\n    }]);\n\n    return TooltipArea;\n  }(react.Component);\n\n  TooltipArea.defaultProps = {\n    isRadial: false,\n    tooltip: jsxRuntime.jsx(ChartTooltip, {}, void 0),\n    inverse: true,\n    onValueEnter: function onValueEnter() {\n      return undefined;\n    },\n    onValueLeave: function onValueLeave() {\n      return undefined;\n    }\n  };\n  /**\r\n   * Gets the min/max values handling nested arrays.\r\n   */\n\n  function extent(data, attr) {\n    var accessor = function accessor(val, fn) {\n      if (Array.isArray(val.data)) {\n        return fn(val.data, function (vv) {\n          return vv[attr];\n        });\n      }\n\n      return val[attr];\n    };\n\n    var minVal = d3Array.min(data, function (d) {\n      return accessor(d, d3Array.min);\n    });\n    var maxVal = d3Array.max(data, function (d) {\n      return accessor(d, d3Array.max);\n    });\n    return [minVal, maxVal];\n  }\n  /**\r\n   * Get the domain for the Y Axis.\r\n   */\n\n\n  function getYDomain(_ref20) {\n    var data = _ref20.data,\n        _ref20$scaled = _ref20.scaled,\n        scaled = _ref20$scaled === void 0 ? false : _ref20$scaled,\n        _ref20$isDiverging = _ref20.isDiverging,\n        isDiverging = _ref20$isDiverging === void 0 ? false : _ref20$isDiverging;\n\n    var _extent = extent(data, 'y'),\n        _extent2 = _slicedToArray(_extent, 2),\n        startY = _extent2[0],\n        endY = _extent2[1];\n\n    var _extent3 = extent(data, 'y1'),\n        _extent4 = _slicedToArray(_extent3, 2),\n        startY1 = _extent4[0],\n        endY1 = _extent4[1]; // If dealing w/ negative numbers, we should\n    // normalize the top and bottom values\n\n\n    if (startY < 0 || isDiverging) {\n      var posStart = -startY;\n      var maxNum = Math.max(posStart, endY);\n      return [-maxNum, maxNum];\n    } // Scaled start scale at non-zero\n\n\n    if (scaled) {\n      return [startY1, endY1];\n    } // Start at 0 based\n\n\n    return [0, endY1];\n  }\n  /**\r\n   * Get the domain for the X Axis.\r\n   */\n\n\n  function getXDomain(_ref21) {\n    var data = _ref21.data,\n        _ref21$scaled = _ref21.scaled,\n        scaled = _ref21$scaled === void 0 ? false : _ref21$scaled,\n        _ref21$isDiverging = _ref21.isDiverging,\n        isDiverging = _ref21$isDiverging === void 0 ? false : _ref21$isDiverging;\n    var startX0 = extent(data, 'x0')[0];\n    var endX1 = extent(data, 'x1')[1]; // Histograms use dates for start/end\n\n    if (typeof startX0 === 'number' && typeof endX1 === 'number') {\n      // If dealing w/ negative numbers, we should\n      // normalize the top and bottom values\n      if (startX0 < 0 || isDiverging) {\n        var posStart = -startX0;\n        var maxNum = Math.max(posStart, endX1);\n        return [-maxNum, maxNum];\n      } // If not scaled, return 0/max domains\n\n\n      if (!scaled) {\n        return [0, endX1];\n      }\n    } // Scaled start scale at non-zero\n\n\n    return [startX0, endX1];\n  }\n  /**\r\n   * Helper function for interpolation.\r\n   */\n\n\n  function interpolate(type) {\n    if (type === 'smooth') {\n      return d3Shape.curveMonotoneX;\n    } else if (type === 'step') {\n      return d3Shape.curveStep;\n    } else {\n      return d3Shape.curveLinear;\n    }\n  }\n  /**\r\n   * Calculates whether the stroke should be shown.\r\n   */\n\n\n  function calculateShowStroke(current, data) {\n    var i = data.indexOf(current);\n    var showLine = false;\n    var prev = data[i - 1];\n\n    if (i > 0 && prev.y) {\n      showLine = true;\n    }\n\n    var cur = data[i];\n\n    if (cur.y) {\n      showLine = true;\n    }\n\n    var next = data[i + 1];\n\n    if (i < data.length - 1 && next.y) {\n      showLine = true;\n    }\n\n    return showLine;\n  }\n  /**\r\n   * Get the angle from a radian.\r\n   */\n\n\n  var getDegrees = function getDegrees(radians) {\n    return radians / Math.PI * 180 - 90;\n  };\n\n  var functionProps = function functionProps(prop, val, data) {\n    if (typeof val === 'function') {\n      return val(data);\n    } else if (prop === 'className') {\n      return classNames__default['default'](val);\n    } else if (val !== undefined || val !== null) {\n      return val;\n    }\n\n    return {};\n  };\n\n  var constructFunctionProps = function constructFunctionProps(props, data) {\n    return {\n      className: functionProps('className', props.className, data),\n      style: functionProps('style', props.style, data)\n    };\n  };\n\n  function wrapText(_ref22) {\n    var key = _ref22.key,\n        _ref22$x = _ref22.x,\n        x = _ref22$x === void 0 ? 0 : _ref22$x,\n        _ref22$y = _ref22.y,\n        y = _ref22$y === void 0 ? 0 : _ref22$y,\n        paddingY = _ref22.paddingY,\n        paddingX = _ref22.paddingX,\n        width = _ref22.width,\n        height = _ref22.height,\n        fontFamily = _ref22.fontFamily,\n        fontSize = _ref22.fontSize;\n    var size = calculateDimensions(key, fontFamily, fontSize);\n    var words = key.toString().split(/\\s+/);\n\n    if (words.length > 1 && size.width > width) {\n      var rows = [];\n      var sumWidth = 0;\n      var sumHeight = 0;\n      var curText = '';\n      var lineNum = 0;\n\n      var _iterator24 = _createForOfIteratorHelper(words),\n          _step24;\n\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n          var word = _step24.value;\n          var wordSize = calculateDimensions(word, fontFamily, fontSize);\n          var wordWidth = wordSize.width;\n          lineNum++;\n\n          if (sumWidth + wordWidth < width) {\n            sumWidth += wordWidth;\n            sumHeight += wordSize.height;\n            curText = \"\".concat(curText, \" \").concat(word);\n          } else {\n            rows.push(curText);\n            sumWidth += wordSize.width;\n            sumHeight += wordSize.height;\n            curText = word;\n          }\n\n          if (words.length === lineNum) {\n            rows.push(curText);\n          }\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n\n      if (height && sumHeight + paddingY >= height) {\n        return null;\n      }\n\n      if (width && sumWidth + paddingX >= width) {\n        return null;\n      }\n\n      return rows.map(function (r, i) {\n        return jsxRuntime.jsx(\"tspan\", Object.assign({\n          dominantBaseline: \"alphabetic\",\n          style: {\n            baselineShift: '0%'\n          },\n          dy: i > 0 ? size.height : -size.height / 2,\n          x: x\n        }, {\n          children: r\n        }), i);\n      });\n    }\n\n    if (height && size.height + paddingY >= height) {\n      return null;\n    }\n\n    if (width && size.width + paddingX >= width) {\n      return null;\n    } // NOTE: 5px seems to magic number for making it center\n\n\n    return jsxRuntime.jsx(\"tspan\", Object.assign({\n      dominantBaseline: \"alphabetic\",\n      style: {\n        baselineShift: '0%'\n      },\n      dy: size.height / 2 - 5,\n      x: x\n    }, {\n      children: key\n    }), void 0);\n  }\n\n  var ZoomPan = /*#__PURE__*/function (_react$Component22) {\n    _inherits(ZoomPan, _react$Component22);\n\n    function ZoomPan() {\n      var _this13;\n\n      _classCallCheck(this, ZoomPan);\n\n      _this13 = _possibleConstructorReturn(this, _getPrototypeOf(ZoomPan).apply(this, arguments));\n      _this13.zoomRef = react.createRef();\n      _this13.panRef = react.createRef();\n      _this13.state = {\n        isZooming: false,\n        isPanning: false,\n        matrix: transformationMatrix.identity()\n      };\n      return _this13;\n    }\n\n    _createClass(ZoomPan, [{\n      key: \"onPanStart\",\n      value: function onPanStart(event) {\n        this.setState({\n          isPanning: true\n        });\n        this.props.onPanStart(event);\n      }\n    }, {\n      key: \"onPanMove\",\n      value: function onPanMove(event) {\n        this.props.onZoomPan({\n          scale: this.props.scale,\n          x: event.x,\n          y: event.y,\n          type: 'pan',\n          nativeEvent: event.nativeEvent\n        });\n        this.props.onPanMove(event);\n      }\n    }, {\n      key: \"onPanEnd\",\n      value: function onPanEnd(event) {\n        this.setState({\n          isPanning: false\n        });\n        this.props.onPanEnd(event);\n      }\n    }, {\n      key: \"onZoom\",\n      value: function onZoom(event) {\n        this.props.onZoomPan({\n          x: event.x,\n          y: event.y,\n          scale: event.scale,\n          nativeEvent: event.nativeEvent,\n          type: 'zoom'\n        });\n        this.props.onZoom(event);\n      }\n    }, {\n      key: \"onZoomEnd\",\n      value: function onZoomEnd() {\n        this.setState({\n          isZooming: false\n        });\n        this.props.onZoomEnd();\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props43 = this.props,\n            height = _this$props43.height,\n            width = _this$props43.width,\n            children = _this$props43.children,\n            disabled = _this$props43.disabled,\n            pannable = _this$props43.pannable,\n            maxZoom = _this$props43.maxZoom,\n            minZoom = _this$props43.minZoom,\n            zoomable = _this$props43.zoomable,\n            scale = _this$props43.scale,\n            x = _this$props43.x,\n            y = _this$props43.y,\n            disableMouseWheel = _this$props43.disableMouseWheel,\n            constrain = _this$props43.constrain,\n            zoomStep = _this$props43.zoomStep,\n            onPanCancel = _this$props43.onPanCancel,\n            requireZoomModifier = _this$props43.requireZoomModifier,\n            globalPanning = _this$props43.globalPanning;\n        var _this$state4 = this.state,\n            isZooming = _this$state4.isZooming,\n            isPanning = _this$state4.isPanning;\n        var cursor = pannable ? 'move' : 'auto';\n        var selection = isZooming || isPanning ? 'none' : 'auto';\n        var matrix = transformationMatrix.fromObject(this.state.matrix);\n        return jsxRuntime.jsx(Pan, Object.assign({\n          x: x,\n          y: y,\n          scale: scale,\n          matrix: matrix,\n          constrain: constrain,\n          height: height,\n          width: width,\n          disabled: !pannable || disabled,\n          ref: this.panRef,\n          globalPanning: globalPanning,\n          onPanStart: bind__default['default'](this.onPanStart, this),\n          onPanMove: bind__default['default'](this.onPanMove, this),\n          onPanEnd: bind__default['default'](this.onPanEnd, this),\n          onPanCancel: onPanCancel\n        }, {\n          children: jsxRuntime.jsxs(Zoom, Object.assign({\n            ref: this.zoomRef,\n            disabled: !zoomable || disabled,\n            scaleFactor: zoomStep,\n            disableMouseWheel: disableMouseWheel,\n            maxZoom: maxZoom,\n            minZoom: minZoom,\n            scale: scale,\n            x: x,\n            y: y,\n            style: {\n              cursor: cursor\n            },\n            requireZoomModifier: requireZoomModifier,\n            matrix: matrix,\n            onZoom: bind__default['default'](this.onZoom, this),\n            onZoomEnd: bind__default['default'](this.onZoomEnd, this)\n          }, {\n            children: [!disabled && jsxRuntime.jsx(\"rect\", {\n              height: height,\n              width: width,\n              opacity: 0,\n              className: \"pan-container\"\n            }, void 0), jsxRuntime.jsx(\"g\", Object.assign({\n              style: {\n                pointerEvents: selection,\n                userSelect: selection\n              }\n            }, {\n              children: children\n            }), void 0)]\n          }), void 0)\n        }), void 0);\n      }\n    }], [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(props, state) {\n        // TODO: the types in the library don't seem to be correct...\n        var matrix = transformationMatrix.transform(transformationMatrix.fromDefinition([{\n          type: 'translate',\n          tx: props.x,\n          ty: props.y\n        }, {\n          type: 'scale',\n          sx: props.scale,\n          sy: props.scale\n        }]));\n\n        if (!isEqual__default['default'](matrix, state.matrix)) {\n          return {\n            matrix: matrix\n          };\n        }\n\n        return null;\n      }\n    }]);\n\n    return ZoomPan;\n  }(react.Component);\n\n  ZoomPan.defaultProps = {\n    maxZoom: 10,\n    minZoom: 0,\n    zoomStep: 0.1,\n    pannable: true,\n    zoomable: true,\n    constrain: true,\n    height: 0,\n    width: 0,\n    x: 0,\n    y: 0,\n    scale: 1,\n    globalPanning: true,\n    onPanStart: function onPanStart() {\n      return undefined;\n    },\n    onPanMove: function onPanMove() {\n      return undefined;\n    },\n    onPanEnd: function onPanEnd() {\n      return undefined;\n    },\n    onPanCancel: function onPanCancel() {\n      return undefined;\n    },\n    onZoom: function onZoom() {\n      return undefined;\n    },\n    onZoomEnd: function onZoomEnd() {\n      return undefined;\n    }\n  };\n  /**\r\n   * Gets the X Scale function.\r\n   */\n\n  function getXScale(_ref23) {\n    var type = _ref23.type,\n        roundDomains = _ref23.roundDomains,\n        data = _ref23.data,\n        width = _ref23.width,\n        domain = _ref23.domain,\n        padding = _ref23.padding,\n        scaled = _ref23.scaled,\n        _ref23$isMultiSeries = _ref23.isMultiSeries,\n        isMultiSeries = _ref23$isMultiSeries === void 0 ? false : _ref23$isMultiSeries,\n        _ref23$isDiverging = _ref23.isDiverging,\n        isDiverging = _ref23$isDiverging === void 0 ? false : _ref23$isDiverging;\n    var scale;\n\n    if (type === 'time' || type === 'duration' || type === 'value') {\n      if (type === 'time') {\n        scale = d3Scale.scaleTime().rangeRound([0, width]);\n      } else {\n        scale = d3Scale.scaleLinear().rangeRound([0, width]);\n      }\n\n      scale = scale.domain(domain || getXDomain({\n        data: data,\n        scaled: scaled,\n        isDiverging: isDiverging\n      }));\n    } else {\n      if (!domain) {\n        if (isMultiSeries) {\n          domain = uniqueBy(data, function (d) {\n            return d.key;\n          });\n        } else {\n          domain = uniqueBy(data, function (d) {\n            return d.x;\n          });\n        }\n      }\n\n      scale = d3Scale.scaleBand().rangeRound([0, width]).padding(padding || 0).domain(domain);\n    }\n\n    return roundDomains ? scale.nice() : scale;\n  }\n  /**\r\n   * Gets the Y Scale function.\r\n   */\n\n\n  function getYScale(_ref24) {\n    var type = _ref24.type,\n        height = _ref24.height,\n        data = _ref24.data,\n        domain = _ref24.domain,\n        _ref24$roundDomains = _ref24.roundDomains,\n        roundDomains = _ref24$roundDomains === void 0 ? false : _ref24$roundDomains,\n        _ref24$scaled = _ref24.scaled,\n        scaled = _ref24$scaled === void 0 ? false : _ref24$scaled,\n        _ref24$padding = _ref24.padding,\n        padding = _ref24$padding === void 0 ? 0 : _ref24$padding,\n        _ref24$isMultiSeries = _ref24.isMultiSeries,\n        isMultiSeries = _ref24$isMultiSeries === void 0 ? false : _ref24$isMultiSeries,\n        _ref24$isDiverging = _ref24.isDiverging,\n        isDiverging = _ref24$isDiverging === void 0 ? false : _ref24$isDiverging;\n    var scale;\n\n    if (type === 'time' || type === 'value' || type === 'duration') {\n      scale = d3Scale.scaleLinear().range([height, 0]).domain(domain || getYDomain({\n        data: data,\n        scaled: scaled,\n        isDiverging: isDiverging\n      }));\n    } else {\n      if (!domain) {\n        if (isMultiSeries) {\n          domain = uniqueBy(data, function (d) {\n            return d.key;\n          });\n        } else {\n          domain = uniqueBy(data, function (d) {\n            return d.y;\n          });\n        }\n      }\n\n      scale = d3Scale.scaleBand().rangeRound([height, 0]).padding(padding).domain(domain);\n    }\n\n    return roundDomains ? scale.nice() : scale;\n  }\n  /**\r\n   * Get a linear scale for the mariemko chart.\r\n   */\n\n\n  var getMarimekkoScale = function getMarimekkoScale(width, roundDomains) {\n    var scale = d3Scale.scaleLinear().rangeRound([0, width]);\n    return roundDomains ? scale.nice() : scale;\n  };\n  /**\r\n   * Builds a fake scale function to get a group scale for a marimekko value scale.\r\n   */\n\n\n  var getMarimekkoGroupScale = function getMarimekkoGroupScale(_ref25) {\n    var data = _ref25.data,\n        width = _ref25.width,\n        valueScale = _ref25.valueScale,\n        padding = _ref25.padding;\n    var domain = uniqueBy(data, function (d) {\n      return d.key;\n    });\n    var barCount = data.length;\n    var widthMinusPadding = width - padding * (barCount - 1);\n    var xMultiplier = widthMinusPadding / width; // Given a data series, find the x0/x1 for it.\n\n    var getXRange = function getXRange(series) {\n      var _series$data = _slicedToArray(series.data, 1),\n          val = _series$data[0];\n\n      var x0 = valueScale(val.x0);\n      var x1 = valueScale(val.x1);\n      return {\n        x0: x0,\n        x1: x1\n      };\n    };\n\n    var scale = function scale(arg) {\n      var result = 0;\n      var index = data.findIndex(function (d) {\n        return d.key === arg;\n      });\n      var series = data[index];\n\n      if (series && series.data && series.data.length) {\n        var _getXRange = getXRange(series),\n            x1 = _getXRange.x1,\n            x0 = _getXRange.x0;\n\n        result = (x1 - x0) / 2 + x0;\n\n        if (padding) {\n          result = result * xMultiplier + index * padding;\n        }\n      }\n\n      return result;\n    };\n\n    scale.range = function () {\n      return [0, width];\n    };\n\n    scale.domain = function () {\n      return domain;\n    }; // Special invert function for marimekko\n\n\n    scale.mariemkoInvert = function (offset) {\n      var found;\n\n      for (var i = 0; i < domain.length; i++) {\n        var attr = domain[i];\n        var series = data[i];\n\n        var _getXRange2 = getXRange(series),\n            x1 = _getXRange2.x1,\n            x0 = _getXRange2.x0;\n\n        if (offset >= x0 - padding / 2 && offset <= x1 - padding / 2) {\n          found = attr;\n          break;\n        }\n      }\n\n      return found;\n    };\n\n    return scale;\n  };\n  /**\r\n   * Get the group scale aka x0.\r\n   */\n\n\n  function getGroupScale(_ref26) {\n    var dimension = _ref26.dimension,\n        padding = _ref26.padding,\n        data = _ref26.data,\n        _ref26$direction = _ref26.direction,\n        direction = _ref26$direction === void 0 ? 'vertical' : _ref26$direction;\n    var domain = uniqueBy(data, function (d) {\n      return d.key;\n    });\n    var spacing = domain.length / (dimension / padding + 1);\n    var range = direction === 'vertical' ? [0, dimension] : [dimension, 0];\n    return d3Scale.scaleBand().rangeRound(range).paddingInner(spacing).paddingOuter(spacing / 2).domain(domain);\n  }\n  /**\r\n   * Get the inner scale aka x1.\r\n   */\n\n\n  function getInnerScale(_ref27) {\n    var groupScale = _ref27.groupScale,\n        padding = _ref27.padding,\n        data = _ref27.data,\n        _ref27$prop = _ref27.prop,\n        prop = _ref27$prop === void 0 ? 'x' : _ref27$prop;\n    var dimension = groupScale.bandwidth();\n    var domain = uniqueBy(data, function (d) {\n      return d.data;\n    }, function (d) {\n      return d[prop];\n    });\n    var spacing = domain.length / (dimension / padding + 1);\n    return d3Scale.scaleBand().rangeRound([0, dimension]).paddingInner(spacing).domain(domain);\n  }\n  /**\r\n   * Get the Y Scale for a given set of radiuses.\r\n   * Reference: https://github.com/d3/d3-scale/issues/90\r\n   */\n\n\n  var getRadialYScale = function getRadialYScale(innerRadius, outerRadius, domain) {\n    if (domain[0] === 0 && domain[1] === 0) {\n      // If all values are 0, set the domain to [0, 1], so the zero values are\n      // all at the bottom of the chart, not the middle.\n      domain = [0, 1];\n    }\n\n    var y = d3Scale.scaleLinear().range([innerRadius * innerRadius, outerRadius * outerRadius]).domain(domain);\n    var yScale = Object.assign(function (d) {\n      return Math.sqrt(y(d));\n    }, y);\n    return yScale;\n  };\n\n  var ChartZoomPan = /*#__PURE__*/function (_react$Component23) {\n    _inherits(ChartZoomPan, _react$Component23);\n\n    function ChartZoomPan() {\n      _classCallCheck(this, ChartZoomPan);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ChartZoomPan).apply(this, arguments));\n    }\n\n    _createClass(ChartZoomPan, [{\n      key: \"onZoomPan\",\n      value: function onZoomPan(event) {\n        var _this$props44 = this.props,\n            width = _this$props44.width,\n            data = _this$props44.data,\n            axisType = _this$props44.axisType,\n            roundDomains = _this$props44.roundDomains,\n            onZoomPan = _this$props44.onZoomPan;\n        var can = event.type === 'zoom' || event.type === 'pan' && event.scale > 1;\n\n        if (can) {\n          var scale = getXScale({\n            width: width,\n            type: axisType,\n            roundDomains: roundDomains,\n            data: data\n          });\n          var newScale = scale.copy().domain(scale.range().map(function (x) {\n            return (x - event.x) / event.scale;\n          }).map(scale.clamp(true).invert, event.x));\n          onZoomPan({\n            domain: newScale.domain(),\n            isZoomed: event.scale !== 1\n          });\n        }\n      }\n    }, {\n      key: \"getOffset\",\n      value: function getOffset() {\n        var zoomOffset = {\n          scale: undefined,\n          x: undefined\n        };\n        var _this$props45 = this.props,\n            disabled = _this$props45.disabled,\n            domain = _this$props45.domain,\n            width = _this$props45.width,\n            data = _this$props45.data,\n            axisType = _this$props45.axisType,\n            roundDomains = _this$props45.roundDomains;\n\n        if (!disabled && domain) {\n          var xScale = getXScale({\n            width: width,\n            type: axisType,\n            roundDomains: roundDomains,\n            data: data\n          });\n          var offset = xScale(domain[0]);\n          var endOffset = xScale(domain[1]);\n          var scale = width / (endOffset - offset); // Apply the new scale to the offset so its scaled correctly\n\n          offset = offset * scale;\n          zoomOffset = {\n            scale: scale,\n            x: -offset\n          };\n        }\n\n        return zoomOffset;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _a = this.props,\n            data = _a.data,\n            height = _a.height,\n            children = _a.children,\n            width = _a.width,\n            onZoomPan = _a.onZoomPan,\n            rest = __rest(_a, [\"data\", \"height\", \"children\", \"width\", \"onZoomPan\"]);\n\n        var _this$getOffset2 = this.getOffset(),\n            scale = _this$getOffset2.scale,\n            x = _this$getOffset2.x;\n\n        return jsxRuntime.jsx(ZoomPan, Object.assign({}, rest, {\n          scale: scale,\n          x: x,\n          height: height,\n          width: width,\n          pannable: scale > 1,\n          onZoomPan: bind__default['default'](this.onZoomPan, this)\n        }, {\n          children: children\n        }), void 0);\n      }\n    }]);\n\n    return ChartZoomPan;\n  }(react.Component);\n\n  ChartZoomPan.defaultProps = {\n    onZoomPan: function onZoomPan() {\n      return undefined;\n    }\n  };\n  var DEFAULT_TRANSITION = {\n    type: 'spring',\n    velocity: 5,\n    damping: 20,\n    // https://github.com/framer/motion/issues/1513#issuecomment-1121133717\n    restDelta: 0.01,\n    restSpeed: 0.01\n  };\n\n  var MotionPath = function MotionPath(_a) {\n    var custom = _a.custom,\n        transition = _a.transition,\n        rest = __rest(_a, [\"custom\", \"transition\"]);\n\n    var d = framerMotion.useMotionValue(custom.exit.d);\n    var prevPath = framerMotion.useMotionValue(custom.exit.d);\n    var spring = framerMotion.useSpring(prevPath, Object.assign(Object.assign({}, DEFAULT_TRANSITION), {\n      from: 0,\n      to: 1\n    }));\n    react.useEffect(function () {\n      var interpolator = d3Interpolate.interpolate(prevPath.get(), custom.enter.d);\n      var unsub = spring.onChange(function (v) {\n        return d.set(interpolator(v));\n      });\n      prevPath.set(custom.enter.d);\n      return unsub;\n    });\n\n    var _b = custom.enter,\n        enterD = _b.d,\n        enterRest = __rest(_b, [\"d\"]);\n\n    var _c = custom.exit,\n        exitRest = __rest(_c, [\"d\"]);\n\n    return jsxRuntime.jsx(framerMotion.motion.path, Object.assign({}, rest, {\n      initial: exitRest,\n      exit: exitRest,\n      animate: enterRest,\n      transition: transition,\n      d: transition.type !== false ? d : enterD\n    }), void 0);\n  };\n  /**\r\n   * Color Schemes\r\n   * Credits: https://gka.github.io/chroma.js/#chroma-brewer\r\n   */\n\n\n  var schemes = Object.assign({\n    cybertron: chroma__default['default'].scale(['#2d60e8', '#26efb5']).correctLightness().colors(8)\n  }, chroma__default['default'].brewer);\n  /**\r\n   * Given a point, get the key attributes for it.\r\n   */\n\n  var rangeHelper = function rangeHelper(point, attribute) {\n    return point.map(function (r, i) {\n      if (r) {\n        if (r[attribute] !== undefined) {\n          return r[attribute];\n        } else if (r.data && r.data[attribute] !== undefined) {\n          return r.data[attribute];\n        }\n      }\n\n      return i;\n    });\n  };\n  /**\r\n   * Get a color given a range.\r\n   */\n\n\n  var getColor = function getColor(props) {\n    var _Object$assign = Object.assign({\n      attribute: 'key',\n      isMultiSeries: false,\n      scale: d3Scale.scaleOrdinal\n    }, props),\n        point = _Object$assign.point,\n        colorScheme = _Object$assign.colorScheme,\n        attribute = _Object$assign.attribute,\n        index = _Object$assign.index,\n        data = _Object$assign.data,\n        active = _Object$assign.active,\n        isMultiSeries = _Object$assign.isMultiSeries,\n        domain = _Object$assign.domain,\n        key = _Object$assign.key,\n        scale = _Object$assign.scale;\n\n    if (typeof colorScheme === 'string' && schemes[colorScheme]) {\n      colorScheme = schemes[colorScheme];\n    }\n\n    if (Array.isArray(colorScheme)) {\n      if (!domain) {\n        if (isMultiSeries && Array.isArray(data)) {\n          var maxIdx = d3Array.maxIndex(data, function (d) {\n            return d.data.length;\n          });\n          var maxVal = data[maxIdx];\n          data = maxVal.data;\n        }\n\n        domain = rangeHelper(data, attribute);\n      }\n\n      key = key !== undefined ? key : point[attribute];\n      return scale(colorScheme).domain(domain)(key);\n    } else if (typeof colorScheme === 'function') {\n      return colorScheme(point, index, active);\n    } else {\n      return colorScheme;\n    }\n  };\n\n  var COUNT_DEFAULTS = {\n    from: 0,\n    duration: 1,\n    delay: 0,\n    format: true,\n    decimalPlaces: 0\n  };\n\n  var useCount = function useCount(_ref28) {\n    var from = _ref28.from,\n        to = _ref28.to,\n        duration = _ref28.duration,\n        delay = _ref28.delay,\n        decimalPlaces = _ref28.decimalPlaces,\n        format = _ref28.format;\n    var nodeRef = react.useRef(null);\n    from = from || COUNT_DEFAULTS.from;\n    duration = duration || COUNT_DEFAULTS.duration;\n    delay = delay || COUNT_DEFAULTS.delay;\n    format = format || COUNT_DEFAULTS.format;\n    decimalPlaces = decimalPlaces || COUNT_DEFAULTS.decimalPlaces;\n    react.useEffect(function () {\n      var node = nodeRef.current;\n      var controls = framerMotion.animate(from, to, {\n        duration: duration,\n        delay: delay,\n        onUpdate: function onUpdate(value) {\n          var formatted = value;\n\n          if (decimalPlaces) {\n            formatted = Number(value.toFixed(decimalPlaces));\n          } else {\n            formatted = Number(value.toFixed(0));\n          }\n\n          if (format) {\n            formatted = formatted.toLocaleString();\n          }\n\n          node.textContent = formatted;\n        }\n      });\n      return function () {\n        return controls.stop();\n      };\n    }, [from, to, duration, delay, decimalPlaces, format]);\n    return nodeRef;\n  };\n\n  var Count = function Count(_a) {\n    var className = _a.className,\n        rest = __rest(_a, [\"className\"]);\n\n    var ref = useCount(rest);\n    return jsxRuntime.jsx(\"span\", {\n      ref: ref,\n      className: className\n    }, void 0);\n  };\n\n  Count.defaultProps = {\n    from: 0,\n    duration: 1,\n    delay: 0,\n    localize: true,\n    decimalPlaces: 0\n  };\n  var css_248z$i = \".ScatterPoint-module_inactive__3ahvT {\\n  opacity: 0.2;\\n}\\n\";\n  var css$i = {\n    \"inactive\": \"ScatterPoint-module_inactive__3ahvT\"\n  };\n  styleInject(css_248z$i);\n\n  var ScatterPoint = function ScatterPoint(_a) {\n    var symbol = _a.symbol,\n        index = _a.index,\n        id = _a.id,\n        data = _a.data,\n        xScale = _a.xScale,\n        yScale = _a.yScale,\n        active = _a.active,\n        tooltip = _a.tooltip,\n        cursor = _a.cursor,\n        size = _a.size,\n        color = _a.color,\n        animated = _a.animated,\n        _onClick = _a.onClick,\n        _onMouseEnter = _a.onMouseEnter,\n        _onMouseLeave = _a.onMouseLeave,\n        rest = __rest(_a, [\"symbol\", \"index\", \"id\", \"data\", \"xScale\", \"yScale\", \"active\", \"tooltip\", \"cursor\", \"size\", \"color\", \"animated\", \"onClick\", \"onMouseEnter\", \"onMouseLeave\"]);\n\n    var rectRef = react.useRef(null);\n\n    var _react$useState9 = react.useState(false),\n        _react$useState10 = _slicedToArray(_react$useState9, 2),\n        tooltipVisible = _react$useState10[0],\n        setTooltipVisible = _react$useState10[1];\n\n    var extras = react.useMemo(function () {\n      return constructFunctionProps(rest, data);\n    }, [rest, data]);\n    var r = react.useMemo(function () {\n      return typeof size === 'function' ? size(data) : size;\n    }, [size, data]);\n    var renderedSymbol = react.useMemo(function () {\n      return symbol ? symbol(data) : null;\n    }, [data, symbol]);\n    var transitionProps = react.useMemo(function () {\n      return animated ? Object.assign(Object.assign({}, DEFAULT_TRANSITION), {\n        delay: index * 0.005\n      }) : {\n        type: false,\n        delay: 0\n      };\n    }, [index, animated]);\n    var enterProps = react.useMemo(function () {\n      var cy = yScale(data.y1);\n\n      if (yScale.bandwidth) {\n        var width = yScale.bandwidth();\n        cy = cy + width / 2;\n      }\n\n      return {\n        x: xScale(data.x),\n        y: cy\n      };\n    }, [data, yScale]);\n    var exitProps = react.useMemo(function () {\n      var _yScale$domain = yScale.domain(),\n          _yScale$domain2 = _slicedToArray(_yScale$domain, 1),\n          yStartDomain = _yScale$domain2[0];\n\n      return {\n        y: yScale(yStartDomain),\n        x: xScale(data.x)\n      };\n    }, [data, yScale]);\n    var fill = react.useMemo(function () {\n      return getColor({\n        colorScheme: color,\n        index: index,\n        point: data\n      });\n    }, [data, color, index]);\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [jsxRuntime.jsx(\"g\", Object.assign({\n        ref: rectRef,\n        onMouseEnter: function onMouseEnter() {\n          setTooltipVisible(true);\n\n          _onMouseEnter(data);\n        },\n        onMouseLeave: function onMouseLeave() {\n          setTooltipVisible(false);\n\n          _onMouseLeave(data);\n        },\n        onClick: function onClick() {\n          return _onClick(data);\n        },\n        className: classNames__default['default'](_defineProperty({}, css$i.inactive, !active))\n      }, {\n        children: symbol ? jsxRuntime.jsx(framerMotion.motion.g, Object.assign({}, extras, {\n          initial: {\n            translateX: exitProps.x,\n            translateY: exitProps.y,\n            opacity: 0\n          },\n          animate: {\n            translateX: enterProps.x,\n            translateY: enterProps.y,\n            opacity: 1\n          },\n          exit: {\n            translateX: exitProps.x,\n            translateY: exitProps.y,\n            opacity: 0\n          },\n          transition: transitionProps\n        }, {\n          children: renderedSymbol\n        }), \"symbol-\".concat(id, \"-\").concat(data.id)) : jsxRuntime.jsx(framerMotion.motion.circle, {\n          className: extras.className,\n          style: Object.assign(Object.assign({}, extras.style), {\n            cursor: cursor\n          }),\n          initial: {\n            cx: exitProps.x,\n            cy: exitProps.y,\n            fill: fill,\n            r: r,\n            opacity: 0\n          },\n          animate: {\n            cx: enterProps.x,\n            cy: enterProps.y,\n            opacity: 1,\n            fill: fill,\n            r: r\n          },\n          exit: {\n            cx: exitProps.x,\n            cy: exitProps.y,\n            fill: fill,\n            r: r,\n            opacity: 0\n          },\n          transition: transitionProps\n        }, \"symbol-\".concat(id, \"-\").concat(data.id))\n      }), void 0), tooltip && !tooltip.props.disabled && jsxRuntime.jsx(rdk.CloneElement, {\n        element: tooltip,\n        visible: tooltipVisible,\n        reference: rectRef,\n        value: data\n      }, void 0)]\n    }, void 0);\n  };\n\n  ScatterPoint.defaultProps = {\n    active: true,\n    toolti: jsxRuntime.jsx(ChartTooltip, {}, void 0),\n    cursor: 'pointer',\n    size: 4,\n    color: schemes.cybertron[0],\n    animated: true,\n    onClick: function onClick() {\n      return undefined;\n    },\n    onMouseEnter: function onMouseEnter() {\n      return undefined;\n    },\n    onMouseLeave: function onMouseLeave() {\n      return undefined;\n    }\n  }; // For bubble charts, often symbols exceed the area\n  // and we want to add a little bit of padding to prevent clipping\n\n  var PADDING$1 = 25;\n  var HALF_PADDING$1 = PADDING$1 / 2;\n\n  var ScatterSeries = function ScatterSeries(_a) {\n    var data = _a.data,\n        height = _a.height,\n        width = _a.width,\n        id = _a.id,\n        isZoomed = _a.isZoomed,\n        activeIds = _a.activeIds,\n        point = _a.point,\n        rest = __rest(_a, [\"data\", \"height\", \"width\", \"id\", \"isZoomed\", \"activeIds\", \"point\"]);\n\n    var renderPoint = react.useCallback(function (pointData, index) {\n      var pointId;\n\n      if (pointData.id) {\n        pointId = pointData.id;\n      }\n\n      var key = pointId || index;\n      var active = !(activeIds && activeIds.length) || activeIds.includes(pointId);\n      var visible = point.props.visible;\n\n      if (visible && !visible(pointData, index)) {\n        return jsxRuntime.jsx(react.Fragment, {}, key);\n      }\n\n      return jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n        element: point\n      }, rest, {\n        id: id,\n        data: pointData,\n        index: index,\n        active: active\n      }), key);\n    }, [point, id, rest, activeIds]);\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [jsxRuntime.jsx(\"defs\", {\n        children: jsxRuntime.jsx(\"clipPath\", Object.assign({\n          id: \"\".concat(id, \"-path\")\n        }, {\n          children: jsxRuntime.jsx(\"rect\", {\n            width: isZoomed ? width : width + PADDING$1,\n            height: height + PADDING$1,\n            x: isZoomed ? 0 : -HALF_PADDING$1,\n            y: -HALF_PADDING$1\n          }, void 0)\n        }), void 0)\n      }, void 0), jsxRuntime.jsx(\"g\", Object.assign({\n        clipPath: \"url(#\".concat(id, \"-path)\")\n      }, {\n        children: data.map(renderPoint)\n      }), void 0)]\n    }, void 0);\n  };\n\n  ScatterSeries.defaultProps = {\n    point: jsxRuntime.jsx(ScatterPoint, {}, void 0)\n  };\n  var css_248z$h = \".ScatterPlot-module_scatterPlot__1gWRV {\\n  overflow: visible;\\n}\\n\";\n  var css$h = {\n    \"scatterPlot\": \"ScatterPlot-module_scatterPlot__1gWRV\"\n  };\n  styleInject(css_248z$h);\n\n  var ScatterPlot = function ScatterPlot(_ref29) {\n    var id = _ref29.id,\n        width = _ref29.width,\n        height = _ref29.height,\n        margins = _ref29.margins,\n        className = _ref29.className,\n        series = _ref29.series,\n        xAxis = _ref29.xAxis,\n        yAxis = _ref29.yAxis,\n        data = _ref29.data,\n        gridlines = _ref29.gridlines,\n        containerClassName = _ref29.containerClassName,\n        brush = _ref29.brush,\n        zoomPan = _ref29.zoomPan,\n        secondaryAxis = _ref29.secondaryAxis;\n    var zoomControlled = react.useMemo(function () {\n      var _a, _b; // eslint-disable-next-line\n\n\n      return !((_b = (_a = zoomPan === null || zoomPan === void 0 ? void 0 : zoomPan.props) === null || _a === void 0 ? void 0 : _a.domain) === null || _b === void 0 ? void 0 : _b.hasOwnProperty('domain'));\n    }, [zoomPan]);\n    var timeout = react.useRef(null);\n\n    var _react$useState11 = react.useState(false),\n        _react$useState12 = _slicedToArray(_react$useState11, 2),\n        preventAnimation = _react$useState12[0],\n        setPreventAnimation = _react$useState12[1];\n\n    var _react$useState13 = react.useState(null),\n        _react$useState14 = _slicedToArray(_react$useState13, 2),\n        zoomDomain = _react$useState14[0],\n        setZoomDomain = _react$useState14[1];\n\n    var _react$useState15 = react.useState(false),\n        _react$useState16 = _slicedToArray(_react$useState15, 2),\n        isZoomed = _react$useState16[0],\n        setIsZoomed = _react$useState16[1];\n\n    var aggregatedData = react.useMemo(function () {\n      return buildShallowChartData(data);\n    }, [data]);\n    var getScales = react.useCallback(function (chartHeight, chartWidth) {\n      var yScale = getYScale({\n        roundDomains: yAxis.props.roundDomains,\n        type: yAxis.props.type,\n        height: chartHeight,\n        data: aggregatedData,\n        domain: yAxis.props.domain\n      });\n      var xScale = getXScale({\n        width: chartWidth,\n        type: xAxis.props.type,\n        roundDomains: xAxis.props.roundDomains,\n        data: aggregatedData,\n        domain: zoomDomain || xAxis.props.domain\n      });\n      return {\n        yScale: yScale,\n        xScale: xScale\n      };\n    }, [yAxis, xAxis, aggregatedData, zoomDomain]);\n    var onZoomPan = react.useCallback(function (event) {\n      if (zoomControlled) {\n        setPreventAnimation(true);\n        setZoomDomain(event.domain);\n        setIsZoomed(event.isZoomed);\n        clearTimeout(timeout.current);\n        timeout.current = setTimeout(function () {\n          return setPreventAnimation(true);\n        }, 500);\n      }\n    }, [zoomControlled]);\n    var renderChart = react.useCallback(function (_ref30) {\n      var chartHeight = _ref30.chartHeight,\n          chartWidth = _ref30.chartWidth,\n          id = _ref30.id,\n          updateAxes = _ref30.updateAxes,\n          chartSized = _ref30.chartSized;\n\n      var _getScales = getScales(chartHeight, chartWidth),\n          yScale = _getScales.yScale,\n          xScale = _getScales.xScale;\n\n      var animated = preventAnimation === true ? false : series.props.animated;\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [chartSized && gridlines && jsxRuntime.jsx(rdk.CloneElement, {\n          element: gridlines,\n          height: chartHeight,\n          width: chartWidth,\n          yScale: yScale,\n          xScale: xScale,\n          yAxis: yAxis.props,\n          xAxis: xAxis.props\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: xAxis,\n          height: chartHeight,\n          width: chartWidth,\n          scale: xScale,\n          onDimensionsChange: function onDimensionsChange(e) {\n            return updateAxes('horizontal', e);\n          }\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: yAxis,\n          height: chartHeight,\n          width: chartWidth,\n          scale: yScale,\n          onDimensionsChange: function onDimensionsChange(e) {\n            return updateAxes('vertical', e);\n          }\n        }, void 0), secondaryAxis && secondaryAxis.map(function (axis, i) {\n          return jsxRuntime.jsx(rdk.CloneElement, {\n            element: axis,\n            height: chartHeight,\n            width: chartWidth,\n            onDimensionsChange: function onDimensionsChange(e) {\n              return updateAxes('horizontal', e);\n            }\n          }, i);\n        }), chartSized && jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n          element: brush,\n          height: chartHeight,\n          width: chartWidth,\n          scale: xScale\n        }, {\n          children: jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n            element: zoomPan,\n            onZoomPan: onZoomPan,\n            height: chartHeight,\n            width: chartWidth,\n            axisType: xAxis.props.type,\n            roundDomains: xAxis.props.roundDomains,\n            data: aggregatedData,\n            domain: zoomDomain\n          }, {\n            children: jsxRuntime.jsx(rdk.CloneElement, {\n              element: series,\n              id: \"area-series-\".concat(id),\n              data: aggregatedData,\n              height: chartHeight,\n              width: chartWidth,\n              yScale: yScale,\n              xScale: xScale,\n              isZoomed: isZoomed,\n              animated: animated\n            }, void 0)\n          }), void 0)\n        }), void 0)]\n      }, void 0);\n    }, [getScales, preventAnimation, series, gridlines, yAxis, xAxis, secondaryAxis, brush, zoomPan, onZoomPan, aggregatedData, zoomDomain, isZoomed]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      containerClassName: containerClassName,\n      margins: margins,\n      xAxisVisible: isAxisVisible(xAxis.props),\n      yAxisVisible: isAxisVisible(yAxis.props),\n      className: classNames__default['default'](css$h.scatterPlot, className)\n    }, {\n      children: renderChart\n    }), void 0);\n  };\n\n  ScatterPlot.defaultProps = {\n    data: [],\n    xAxis: jsxRuntime.jsx(LinearXAxis, {\n      type: \"time\"\n    }, void 0),\n    yAxis: jsxRuntime.jsx(LinearYAxis, {\n      type: \"value\"\n    }, void 0),\n    series: jsxRuntime.jsx(ScatterSeries, {}, void 0),\n    gridlines: jsxRuntime.jsx(GridlineSeries, {}, void 0),\n    brush: null,\n    zoomPan: null\n  };\n  var css_248z$g = \".PointSeries-module_point__3cXpV {\\n  stroke: rgba(255, 255, 255, 0.5);\\n  stroke-width: 1px;\\n}\\n\";\n  var css$g = {\n    \"point\": \"PointSeries-module_point__3cXpV\"\n  };\n  styleInject(css_248z$g);\n\n  var PointSeries = function PointSeries(_ref31) {\n    var data = _ref31.data,\n        xScale = _ref31.xScale,\n        yScale = _ref31.yScale,\n        animated = _ref31.animated,\n        point = _ref31.point,\n        color = _ref31.color,\n        height = _ref31.height,\n        width = _ref31.width,\n        id = _ref31.id,\n        activeValues = _ref31.activeValues,\n        show = _ref31.show;\n    var getIsVisible = react.useCallback(function (point, index) {\n      var isActive = activeValues && point && isEqual__default['default'](activeValues.x, point.x);\n\n      if (show === 'hover') {\n        return isActive;\n      } else if (show === 'first') {\n        if (activeValues) {\n          return isActive;\n        } else {\n          return index === 0;\n        }\n      } else if (show === 'last') {\n        if (activeValues) {\n          return isActive;\n        } else {\n          return index === data.length - 1;\n        }\n      }\n\n      return show;\n    }, [activeValues, data.length, show]);\n    return jsxRuntime.jsx(ScatterSeries, {\n      height: height,\n      width: width,\n      id: id,\n      animated: animated,\n      data: data,\n      xScale: xScale,\n      yScale: yScale,\n      point: jsxRuntime.jsx(rdk.CloneElement, {\n        element: point,\n        color: color,\n        className: css$g.point,\n        size: 4,\n        tooltip: null,\n        visible: getIsVisible\n      }, void 0)\n    }, void 0);\n  };\n\n  PointSeries.defaultProps = {\n    show: 'hover',\n    point: jsxRuntime.jsx(ScatterPoint, {}, void 0)\n  };\n\n  var Area = function Area(_a) {\n    var id = _a.id,\n        gradient = _a.gradient,\n        mask = _a.mask,\n        data = _a.data,\n        color = _a.color,\n        index = _a.index,\n        total = _a.total,\n        xScale = _a.xScale,\n        yScale = _a.yScale,\n        animated = _a.animated,\n        interpolation = _a.interpolation,\n        rest = __rest(_a, [\"id\", \"gradient\", \"mask\", \"data\", \"color\", \"index\", \"total\", \"xScale\", \"yScale\", \"animated\", \"interpolation\"]);\n\n    var stroke = color(data, index);\n    var coords = react.useMemo(function () {\n      return data.map(function (item) {\n        return {\n          x: xScale(item.x),\n          x1: xScale(item.x) - xScale(item.x1),\n          y: yScale(item.y),\n          y0: yScale(item.y0),\n          y1: yScale(item.y1)\n        };\n      });\n    }, [data, xScale, yScale]);\n    var getAreaPath = react.useCallback(function (d) {\n      // If the input data is a single value and this is the only\n      // area in a series, fill the available space with an area:\n      if (d.length === 1 && total === 1) {\n        var _d2 = d,\n            _d3 = _slicedToArray(_d2, 1),\n            point = _d3[0]; // Assume the single data point's `x` value\n        // is the middle of the graph:\n\n\n        var midpoint = point.x;\n        d = [Object.assign({}, point), Object.assign({}, point)];\n\n        var _d4 = d,\n            _d5 = _slicedToArray(_d4, 2),\n            start = _d5[0],\n            end = _d5[1];\n\n        start.x = 0;\n        end.x = midpoint * 2;\n      }\n\n      var fn = d3Shape.area().x(function (d) {\n        return d.x;\n      }).y0(function (d) {\n        return d.y0;\n      }).y1(function (d) {\n        return d.y1;\n      }).curve(interpolate(interpolation));\n      return fn(d);\n    }, [interpolation, total]);\n    var enter = react.useMemo(function () {\n      var areaPath = getAreaPath(coords);\n      return {\n        d: areaPath === null ? undefined : areaPath\n      };\n    }, [coords, getAreaPath]);\n    var exit = react.useMemo(function () {\n      var maxY = Math.max.apply(Math, _toConsumableArray(yScale.range()));\n      var coords = data.map(function (item) {\n        return {\n          x: xScale(item.x),\n          x1: 0,\n          y: 0,\n          y1: maxY,\n          y0: maxY\n        };\n      });\n      var areaPath = getAreaPath(coords);\n      return {\n        d: areaPath === null ? undefined : areaPath\n      };\n    }, [data, getAreaPath, xScale, yScale]);\n    var fill = react.useMemo(function () {\n      if (mask) {\n        return \"url(#mask-pattern-\".concat(id, \")\");\n      } else {\n        if (gradient) {\n          return \"url(#gradient-\".concat(id, \")\");\n        }\n\n        return '';\n      }\n    }, [gradient, id, mask]);\n    var transition = react.useMemo(function () {\n      if (animated) {\n        return Object.assign(Object.assign({}, DEFAULT_TRANSITION), {\n          delay: index * 0.05\n        });\n      } else {\n        return {\n          type: false,\n          delay: 0\n        };\n      }\n    }, [animated, index]);\n    var renderArea = react.useCallback(function () {\n      var maskPath = mask ? \"url(#mask-\".concat(id, \")\") : '';\n      var extras = constructFunctionProps(rest, data);\n      return jsxRuntime.jsx(MotionPath, Object.assign({}, extras, {\n        pointerEvents: \"none\",\n        mask: maskPath,\n        fill: fill,\n        transition: transition,\n        custom: {\n          enter: enter,\n          exit: exit\n        }\n      }), void 0);\n    }, [data, enter, exit, fill, id, mask, rest, transition]);\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [renderArea(), mask && jsxRuntime.jsxs(react.Fragment, {\n        children: [jsxRuntime.jsx(Mask, {\n          id: \"mask-\".concat(id),\n          fill: \"url(#gradient-\".concat(id, \")\")\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: mask,\n          id: \"mask-pattern-\".concat(id),\n          fill: stroke\n        }, void 0)]\n      }, void 0), gradient && jsxRuntime.jsx(rdk.CloneElement, {\n        element: gradient,\n        id: \"gradient-\".concat(id),\n        color: stroke\n      }, void 0)]\n    }, void 0);\n  };\n\n  Area.defaultProps = {\n    gradient: jsxRuntime.jsx(Gradient, {}, void 0),\n    interpolation: 'linear'\n  };\n\n  var Line = function Line(_a) {\n    var width = _a.width,\n        data = _a.data,\n        color = _a.color,\n        index = _a.index,\n        strokeWidth = _a.strokeWidth,\n        hasArea = _a.hasArea,\n        animated = _a.animated,\n        yScale = _a.yScale,\n        xScale = _a.xScale,\n        showZeroStroke = _a.showZeroStroke,\n        interpolation = _a.interpolation,\n        rest = __rest(_a, [\"width\", \"data\", \"color\", \"index\", \"strokeWidth\", \"hasArea\", \"animated\", \"yScale\", \"xScale\", \"showZeroStroke\", \"interpolation\"]);\n\n    var _react$useState17 = react.useState(null),\n        _react$useState18 = _slicedToArray(_react$useState17, 2),\n        pathLength = _react$useState18[0],\n        setPathLength = _react$useState18[1];\n\n    var ghostPathRef = react.useRef(null);\n    react.useEffect(function () {\n      if (ghostPathRef.current) {\n        setPathLength(ghostPathRef.current.getTotalLength());\n      }\n    }, [data, xScale, yScale, width]);\n    var getLinePath = react.useCallback(function (point) {\n      var fn = d3Shape.line().x(function (d) {\n        return d.x;\n      }).y(function (d) {\n        return d.y1;\n      }).defined(function (d) {\n        return showZeroStroke || calculateShowStroke(d, point);\n      }).curve(interpolate(interpolation));\n      return fn(point);\n    }, [interpolation, showZeroStroke]);\n    var transition = react.useMemo(function () {\n      if (animated) {\n        return Object.assign(Object.assign({}, DEFAULT_TRANSITION), {\n          delay: hasArea ? 0 : index * 0.05\n        });\n      } else {\n        return {\n          type: false,\n          delay: 0\n        };\n      }\n    }, [animated, hasArea, index]);\n    var coords = react.useMemo(function () {\n      return data.map(function (item) {\n        return {\n          x: xScale(item.x),\n          x1: xScale(item.x) - xScale(item.x1),\n          y: yScale(item.y),\n          y0: yScale(item.y0),\n          y1: yScale(item.y1)\n        };\n      });\n    }, [data, xScale, yScale]);\n    var enter = react.useMemo(function () {\n      var linePath = getLinePath(coords);\n      var strokeDasharray = '';\n\n      if (!hasArea && pathLength !== null) {\n        strokeDasharray = \"\".concat(pathLength, \" \").concat(pathLength);\n      }\n\n      return {\n        d: linePath === null ? undefined : linePath,\n        strokeDashoffset: 0,\n        strokeDasharray: strokeDasharray\n      };\n    }, [coords, getLinePath, hasArea, pathLength]);\n    var exit = react.useMemo(function () {\n      var newCoords = coords;\n\n      if (hasArea) {\n        var maxY = Math.max.apply(Math, _toConsumableArray(yScale.range()));\n        newCoords = data.map(function (item) {\n          return {\n            x: xScale(item.x),\n            x1: 0,\n            y: maxY,\n            y1: maxY,\n            y0: maxY\n          };\n        });\n      }\n\n      var linePath = getLinePath(newCoords);\n      var strokeDasharray = '';\n      var strokeDashoffset = 0;\n\n      if (!hasArea && pathLength !== null) {\n        strokeDasharray = \"\".concat(pathLength, \" \").concat(pathLength);\n        strokeDashoffset = pathLength;\n      }\n\n      return {\n        d: linePath === null ? undefined : linePath,\n        strokeDasharray: strokeDasharray,\n        strokeDashoffset: strokeDashoffset\n      };\n    }, [coords, data, getLinePath, hasArea, pathLength, xScale, yScale]);\n    var stroke = color(data, index);\n    var extras = constructFunctionProps(rest, data);\n    var showLine = hasArea || pathLength !== null; // framer-motion freaks out when these are added for area\n\n    if (hasArea) {\n      delete enter.strokeDashoffset;\n      delete exit.strokeDashoffset;\n    }\n\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [showLine && jsxRuntime.jsx(MotionPath, Object.assign({}, extras, {\n        pointerEvents: \"none\",\n        stroke: stroke,\n        strokeWidth: strokeWidth,\n        fill: \"none\",\n        transition: transition,\n        custom: {\n          enter: enter,\n          exit: exit\n        }\n      }), void 0), !hasArea && jsxRuntime.jsx(\"path\", {\n        opacity: \"0\",\n        d: enter.d,\n        ref: ghostPathRef,\n        pointerEvents: \"none\"\n      }, void 0)]\n    }, void 0);\n  };\n\n  Line.defaultProps = {\n    showZeroStroke: true,\n    strokeWidth: 3\n  }; // For area charts, often symbols exceed the area\n  // and we want to add a little bit of padding to prevent clipping\n\n  var PADDING = 25;\n  var HALF_PADDING = PADDING / 2;\n\n  var AreaSeries = function AreaSeries(_ref32) {\n    var data = _ref32.data,\n        height = _ref32.height,\n        id = _ref32.id,\n        width = _ref32.width,\n        isZoomed = _ref32.isZoomed,\n        tooltip = _ref32.tooltip,\n        xScale = _ref32.xScale,\n        yScale = _ref32.yScale,\n        type = _ref32.type,\n        markLine = _ref32.markLine,\n        symbols = _ref32.symbols,\n        animated = _ref32.animated,\n        area = _ref32.area,\n        interpolation = _ref32.interpolation,\n        line = _ref32.line,\n        colorScheme = _ref32.colorScheme;\n\n    var _react$useState19 = react.useState(null),\n        _react$useState20 = _slicedToArray(_react$useState19, 2),\n        activeValues = _react$useState20[0],\n        setActiveValues = _react$useState20[1];\n\n    var _react$useState21 = react.useState(null),\n        _react$useState22 = _slicedToArray(_react$useState21, 2),\n        activePoint = _react$useState22[0],\n        setActivePoint = _react$useState22[1];\n\n    var onValueEnter = react.useCallback(function (event) {\n      setActivePoint(event.pointX);\n      setActiveValues(event.value);\n    }, []);\n    var onValueLeave = react.useCallback(function () {\n      setActivePoint(undefined);\n      setActiveValues(undefined);\n    }, []);\n    var isMulti = type === 'grouped' || type === 'stacked' || type === 'stackedNormalized';\n    var getPointColor = react.useCallback(function (point, index) {\n      var _a;\n\n      var key = Array.isArray(point) ? (_a = point === null || point === void 0 ? void 0 : point[0]) === null || _a === void 0 ? void 0 : _a.key : point === null || point === void 0 ? void 0 : point.key;\n      return getColor({\n        data: data,\n        colorScheme: colorScheme,\n        active: activeValues,\n        point: point,\n        index: index,\n        key: key\n      });\n    }, [activeValues, colorScheme, data]);\n    var renderArea = react.useCallback(function (data) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var total = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [line && jsxRuntime.jsx(rdk.CloneElement, {\n          element: line,\n          xScale: xScale,\n          yScale: yScale,\n          data: data,\n          width: width,\n          index: index,\n          hasArea: area !== null,\n          animated: animated,\n          interpolation: interpolation,\n          color: getPointColor\n        }, void 0), area && jsxRuntime.jsx(rdk.CloneElement, {\n          element: area,\n          id: \"\".concat(id, \"-area-\").concat(index),\n          xScale: xScale,\n          yScale: yScale,\n          data: data,\n          index: index,\n          total: total,\n          animated: animated,\n          interpolation: interpolation,\n          color: getPointColor\n        }, void 0)]\n      }, void 0);\n    }, [animated, area, getPointColor, id, interpolation, line, width, xScale, yScale]);\n    var renderSymbols = react.useCallback(function (data) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var visible = symbols !== null;\n      var activeSymbols = symbols && symbols.props.activeValues || activeValues; // Animations are only valid for Area\n\n      var isAnimated = area !== undefined && animated && !activeSymbols;\n      return jsxRuntime.jsx(react.Fragment, {\n        children: visible && jsxRuntime.jsx(rdk.CloneElement, {\n          element: symbols,\n          id: id,\n          height: height,\n          width: width,\n          activeValues: activeSymbols,\n          xScale: xScale,\n          yScale: yScale,\n          index: index,\n          data: data,\n          animated: isAnimated,\n          color: function color() {\n            return getPointColor(data, index);\n          }\n        }, \"point-series-\".concat(id))\n      }, void 0);\n    }, [activeValues, animated, area, getPointColor, height, id, symbols, width, xScale, yScale]);\n    var renderMarkLine = react.useCallback(function () {\n      return jsxRuntime.jsx(react.Fragment, {\n        children: activeValues && markLine && jsxRuntime.jsx(rdk.CloneElement, {\n          element: markLine,\n          height: height,\n          pointX: activePoint\n        }, void 0)\n      }, void 0);\n    }, [activePoint, activeValues, height, markLine]);\n    var renderSingleSeries = react.useCallback(function (data) {\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [renderArea(data), renderMarkLine(), renderSymbols(data)]\n      }, void 0);\n    }, [renderArea, renderMarkLine, renderSymbols]);\n    var renderMultiSeries = react.useCallback(function (data) {\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [data.map(function (point, index) {\n          return jsxRuntime.jsx(react.Fragment, {\n            children: renderArea(point.data, index, data.length)\n          }, \"\".concat(point.key.toString()));\n        }).reverse(), renderMarkLine(), data.map(function (point, index) {\n          return jsxRuntime.jsx(react.Fragment, {\n            children: renderSymbols(point.data, index)\n          }, \"\".concat(point.key.toString()));\n        }).reverse()]\n      }, void 0);\n    }, [renderArea, renderMarkLine, renderSymbols]);\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [jsxRuntime.jsx(\"defs\", {\n        children: jsxRuntime.jsx(\"clipPath\", Object.assign({\n          id: \"\".concat(id, \"-path\")\n        }, {\n          children: jsxRuntime.jsx(\"rect\", {\n            width: isZoomed ? width : width + PADDING,\n            height: height + PADDING,\n            x: isZoomed ? 0 : -HALF_PADDING,\n            y: -HALF_PADDING\n          }, void 0)\n        }), void 0)\n      }, void 0), jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n        element: tooltip,\n        xScale: xScale,\n        yScale: yScale,\n        data: data,\n        height: height,\n        width: width,\n        color: getColor,\n        onValueEnter: onValueEnter,\n        onValueLeave: onValueLeave\n      }, {\n        children: jsxRuntime.jsxs(\"g\", Object.assign({\n          clipPath: \"url(#\".concat(id, \"-path)\")\n        }, {\n          children: [isMulti && renderMultiSeries(data), !isMulti && renderSingleSeries(data)]\n        }), void 0)\n      }), void 0)]\n    }, void 0);\n  };\n\n  AreaSeries.defaultProps = {\n    colorScheme: 'cybertron',\n    animated: true,\n    interpolation: 'linear',\n    type: 'standard',\n    line: jsxRuntime.jsx(Line, {}, void 0),\n    area: jsxRuntime.jsx(Area, {}, void 0),\n    markLine: jsxRuntime.jsx(MarkLine, {}, void 0),\n    tooltip: jsxRuntime.jsx(TooltipArea, {}, void 0),\n    symbols: jsxRuntime.jsx(PointSeries, {}, void 0)\n  };\n\n  var StackedNormalizedAreaSeries = function StackedNormalizedAreaSeries(_a) {\n    var type = _a.type,\n        symbols = _a.symbols,\n        rest = __rest(_a, [\"type\", \"symbols\"]);\n\n    return jsxRuntime.jsx(AreaSeries, Object.assign({}, rest, {\n      type: \"stackedNormalized\",\n      symbols: symbols && jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n        element: symbols\n      }, symbols.props, {\n        point: jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n          element: symbols.props.point\n        }, symbols.props.point.props, {\n          tooltip: null\n        }), void 0)\n      }), void 0)\n    }), void 0);\n  };\n\n  StackedNormalizedAreaSeries.defaultProps = Object.assign(Object.assign({}, AreaSeries.defaultProps), {\n    type: 'stackedNormalized',\n    tooltip: jsxRuntime.jsx(TooltipArea, {\n      tooltip: jsxRuntime.jsx(ChartTooltip, {\n        content: function content(series, color) {\n          if (!series) {\n            return null;\n          }\n\n          var value = Object.assign(Object.assign({}, series), {\n            data: series.data.map(function (d) {\n              return Object.assign(Object.assign({}, d), {\n                value: \"\".concat(formatValue(d.value), \" \\u2219 \").concat(formatValue(Math.floor((d.y1 - d.y0) * 100)), \"%\")\n              });\n            })\n          });\n          return jsxRuntime.jsx(TooltipTemplate, {\n            color: color,\n            value: value\n          }, void 0);\n        }\n      }, void 0)\n    }, void 0)\n  });\n\n  var StackedAreaSeries = function StackedAreaSeries(_a) {\n    var type = _a.type,\n        symbols = _a.symbols,\n        rest = __rest(_a, [\"type\", \"symbols\"]);\n\n    return jsxRuntime.jsx(AreaSeries, Object.assign({}, rest, {\n      type: \"stacked\",\n      symbols: symbols && jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n        element: symbols\n      }, symbols.props, {\n        point: jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n          element: symbols.props.point\n        }, symbols.props.point.props, {\n          tooltip: null\n        }), void 0)\n      }), void 0)\n    }), void 0);\n  };\n\n  StackedAreaSeries.defaultProps = Object.assign(Object.assign({}, AreaSeries.defaultProps), {\n    type: 'stacked'\n  });\n  var css_248z$f = \".AreaChart-module_areaChart__1BikF {\\n  overflow: visible;\\n}\\n\";\n  var css$f = {\n    \"areaChart\": \"AreaChart-module_areaChart__1BikF\"\n  };\n  styleInject(css_248z$f);\n\n  var AreaChart = function AreaChart(_ref33) {\n    var xAxis = _ref33.xAxis,\n        yAxis = _ref33.yAxis,\n        id = _ref33.id,\n        data = _ref33.data,\n        width = _ref33.width,\n        height = _ref33.height,\n        margins = _ref33.margins,\n        className = _ref33.className,\n        containerClassName = _ref33.containerClassName,\n        series = _ref33.series,\n        gridlines = _ref33.gridlines,\n        brush = _ref33.brush,\n        zoomPan = _ref33.zoomPan,\n        secondaryAxis = _ref33.secondaryAxis;\n    var zoom = zoomPan ? zoomPan.props : {};\n\n    var _react$useState23 = react.useState(zoom.domain),\n        _react$useState24 = _slicedToArray(_react$useState23, 2),\n        zoomDomain = _react$useState24[0],\n        setZoomDomain = _react$useState24[1];\n\n    var _react$useState25 = react.useState(false),\n        _react$useState26 = _slicedToArray(_react$useState25, 2),\n        preventAnimation = _react$useState26[0],\n        setPreventAnimation = _react$useState26[1];\n\n    var _react$useState27 = react.useState(!!zoom.domain),\n        _react$useState28 = _slicedToArray(_react$useState27, 2),\n        isZoomed = _react$useState28[0],\n        setIsZoomed = _react$useState28[1]; // eslint-disable-next-line\n\n\n    var _react$useState29 = react.useState(!zoom.hasOwnProperty('domain')),\n        _react$useState30 = _slicedToArray(_react$useState29, 1),\n        zoomControlled = _react$useState30[0];\n\n    var timeoutRef = react.useRef(null);\n    var seriesType = series.props.type;\n    var isMultiSeries = seriesType === 'stacked' || seriesType === 'stackedNormalized' || seriesType === 'grouped';\n    var animated = preventAnimation === true ? false : series.props.animated;\n    react.useEffect(function () {\n      if (zoomPan) {\n        var _zoom = zoomPan.props;\n\n        if (!zoomControlled && _zoom.domain !== zoomDomain) {\n          setZoomDomain(_zoom.domain);\n          setIsZoomed(!!_zoom.domain);\n        }\n      }\n    }, [zoomControlled, zoomDomain, zoomPan]);\n    var aggregatedData = react.useMemo(function () {\n      if (seriesType === 'stacked' || seriesType === 'stackedNormalized') {\n        return buildStackData(data, seriesType === 'stackedNormalized');\n      } else if (seriesType === 'grouped') {\n        return buildNestedChartData(data, true);\n      } else {\n        return buildShallowChartData(data);\n      }\n    }, [data, seriesType]);\n    var getScales = react.useCallback(function (chartWidth, chartHeight) {\n      var xScale = getXScale({\n        width: chartWidth,\n        type: xAxis.props.type,\n        roundDomains: xAxis.props.roundDomains,\n        data: aggregatedData,\n        domain: zoomDomain || xAxis.props.domain,\n        isMultiSeries: isMultiSeries\n      });\n      var yScale = getYScale({\n        roundDomains: yAxis.props.roundDomains,\n        type: yAxis.props.type,\n        height: chartHeight,\n        data: aggregatedData,\n        domain: yAxis.props.domain,\n        isMultiSeries: isMultiSeries\n      });\n      return {\n        xScale: xScale,\n        yScale: yScale\n      };\n    }, [aggregatedData, isMultiSeries, xAxis.props.domain, xAxis.props.roundDomains, xAxis.props.type, yAxis.props.domain, yAxis.props.roundDomains, yAxis.props.type, zoomDomain]);\n    var onZoomPan = react.useCallback(function (event) {\n      if (zoomControlled) {\n        setZoomDomain(event.domain);\n        setIsZoomed(event.isZoomed);\n        setPreventAnimation(true);\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(function () {\n          return setPreventAnimation(false);\n        });\n      }\n    }, [zoomControlled]);\n    var renderChart = react.useCallback(function (_ref34) {\n      var chartHeight = _ref34.chartHeight,\n          chartWidth = _ref34.chartWidth,\n          id = _ref34.id,\n          updateAxes = _ref34.updateAxes,\n          chartSized = _ref34.chartSized;\n\n      var _getScales2 = getScales(chartWidth, chartHeight),\n          xScale = _getScales2.xScale,\n          yScale = _getScales2.yScale;\n\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [chartSized && gridlines && jsxRuntime.jsx(rdk.CloneElement, {\n          element: gridlines,\n          height: chartHeight,\n          width: chartWidth,\n          yScale: yScale,\n          xScale: xScale,\n          yAxis: yAxis.props,\n          xAxis: xAxis.props\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: xAxis,\n          height: chartHeight,\n          width: chartWidth,\n          scale: xScale,\n          onDimensionsChange: function onDimensionsChange(event) {\n            return updateAxes('horizontal', event);\n          }\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: yAxis,\n          height: chartHeight,\n          width: chartWidth,\n          scale: yScale,\n          onDimensionsChange: function onDimensionsChange(event) {\n            return updateAxes('vertical', event);\n          }\n        }, void 0), secondaryAxis && secondaryAxis.map(function (axis, i) {\n          return jsxRuntime.jsx(rdk.CloneElement, {\n            element: axis,\n            height: chartHeight,\n            width: chartWidth,\n            onDimensionsChange: function onDimensionsChange(event) {\n              return updateAxes('horizontal', event);\n            }\n          }, i);\n        }), chartSized && jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n          element: brush,\n          height: chartHeight,\n          width: chartWidth,\n          scale: xScale\n        }, {\n          children: jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n            element: zoomPan,\n            onZoomPan: onZoomPan,\n            height: chartHeight,\n            width: chartWidth,\n            axisType: xAxis.props.type,\n            roundDomains: xAxis.props.roundDomains,\n            data: aggregatedData,\n            domain: zoomDomain\n          }, {\n            children: jsxRuntime.jsx(rdk.CloneElement, {\n              element: series,\n              id: \"area-series-\".concat(id),\n              data: aggregatedData,\n              height: chartHeight,\n              width: chartWidth,\n              yScale: yScale,\n              xScale: xScale,\n              isZoomed: isZoomed,\n              animated: animated\n            }, void 0)\n          }), void 0)\n        }), void 0)]\n      }, void 0);\n    }, [aggregatedData, animated, brush, getScales, gridlines, isZoomed, onZoomPan, secondaryAxis, series, xAxis, yAxis, zoomDomain, zoomPan]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      margins: margins,\n      containerClassName: containerClassName,\n      xAxisVisible: isAxisVisible(xAxis.props),\n      yAxisVisible: isAxisVisible(yAxis.props),\n      className: classNames__default['default'](css$f.areaChart, className, series.type)\n    }, {\n      children: renderChart\n    }), void 0);\n  };\n\n  AreaChart.defaultProps = {\n    data: [],\n    xAxis: jsxRuntime.jsx(LinearXAxis, {\n      type: \"time\"\n    }, void 0),\n    yAxis: jsxRuntime.jsx(LinearYAxis, {\n      type: \"value\"\n    }, void 0),\n    series: jsxRuntime.jsx(AreaSeries, {}, void 0),\n    gridlines: jsxRuntime.jsx(GridlineSeries, {}, void 0),\n    brush: null,\n    zoomPan: null\n  };\n\n  var StackedAreaChart = function StackedAreaChart(props) {\n    return jsxRuntime.jsx(AreaChart, Object.assign({}, props), void 0);\n  };\n\n  StackedAreaChart.defaultProps = {\n    series: jsxRuntime.jsx(StackedAreaSeries, {}, void 0)\n  };\n\n  var StackedNormalizedAreaChart = function StackedNormalizedAreaChart(props) {\n    return jsxRuntime.jsx(AreaChart, Object.assign({}, props), void 0);\n  };\n\n  StackedNormalizedAreaChart.defaultProps = {\n    series: jsxRuntime.jsx(StackedNormalizedAreaSeries, {}, void 0),\n    yAxis: jsxRuntime.jsx(LinearYAxis, {\n      type: \"value\",\n      tickSeries: jsxRuntime.jsx(LinearYAxisTickSeries, {\n        label: jsxRuntime.jsx(LinearYAxisTickLabel, {\n          rotation: false,\n          format: function format(data) {\n            return \"\".concat(data * 100, \"%\");\n          }\n        }, void 0)\n      }, void 0)\n    }, void 0)\n  };\n\n  var Bar = function Bar(_ref35) {\n    var activeBrightness = _ref35.activeBrightness,\n        id = _ref35.id,\n        gradient = _ref35.gradient,\n        data = _ref35.data,\n        barIndex = _ref35.barIndex,\n        color = _ref35.color,\n        yScale = _ref35.yScale,\n        barCount = _ref35.barCount,\n        xScale = _ref35.xScale,\n        groupIndex = _ref35.groupIndex,\n        minHeight = _ref35.minHeight,\n        rangeLines = _ref35.rangeLines,\n        animated = _ref35.animated,\n        active = _ref35.active,\n        type = _ref35.type,\n        tooltip = _ref35.tooltip,\n        layout = _ref35.layout,\n        mask = _ref35.mask,\n        label = _ref35.label,\n        cursor = _ref35.cursor,\n        rx = _ref35.rx,\n        ry = _ref35.ry,\n        isCategorical = _ref35.isCategorical,\n        className = _ref35.className,\n        style = _ref35.style,\n        width = _ref35.width,\n        padding = _ref35.padding,\n        guide = _ref35.guide,\n        xScale1 = _ref35.xScale1,\n        onMouseEnter = _ref35.onMouseEnter,\n        onClick = _ref35.onClick,\n        onMouseMove = _ref35.onMouseMove,\n        onMouseLeave = _ref35.onMouseLeave;\n    var isVertical = react.useMemo(function () {\n      return layout === 'vertical';\n    }, [layout]);\n    var rect = react.useRef(null);\n\n    var _react$useState31 = react.useState(active),\n        _react$useState32 = _slicedToArray(_react$useState31, 2),\n        internalActive = _react$useState32[0],\n        setInternalActive = _react$useState32[1];\n\n    var calculateLinearScalePadding = react.useCallback(function (scale, offset, size) {\n      // This function calculates the padding on a linear scale used by the marimekko chart.\n      var totalSize = scale.range()[1];\n      var sizeMinusPadding = totalSize - padding * (barCount - 1);\n      var multiplier = sizeMinusPadding / totalSize;\n      offset = offset * multiplier + groupIndex * padding;\n      size = size * multiplier;\n      return {\n        size: size,\n        offset: offset\n      };\n    }, [barCount, groupIndex, padding]);\n    var getExit = react.useCallback(function (_ref36) {\n      var x = _ref36.x,\n          y = _ref36.y,\n          width = _ref36.width,\n          height = _ref36.height;\n      var newX = isVertical ? x : Math.min.apply(Math, _toConsumableArray(xScale.range()));\n      var newY = isVertical ? Math.max.apply(Math, _toConsumableArray(yScale.range())) : y;\n      var newHeight = isVertical ? 0 : height;\n      var newWidth = isVertical ? width : 0;\n\n      if (type === 'stackedDiverging') {\n        if (isVertical) {\n          newY = newY / 2;\n        } else {\n          newX = newX / 2;\n        }\n      }\n\n      return {\n        x: newX,\n        y: newY,\n        height: newHeight,\n        width: newWidth\n      };\n    }, [isVertical, type, xScale, yScale]);\n    var getKeyCoords = react.useCallback(function (v, v0, v1, scale, sizeOverride, isCategorical, padding) {\n      var offset;\n      var size;\n\n      if (isCategorical) {\n        if (scale.bandwidth) {\n          offset = scale(v);\n          size = scale.bandwidth();\n\n          if (sizeOverride) {\n            if (offset) {\n              offset = offset + size / 2 - sizeOverride / 2;\n            } else {\n              // Stacked bar charts don't have offsets...\n              offset = size / 2 - sizeOverride / 2;\n            }\n\n            size = sizeOverride;\n          }\n        } else {\n          if (sizeOverride) {\n            throw new Error('Not a valid option for this scale type');\n          }\n\n          offset = scale(v0);\n          size = scale(v1 - v0);\n\n          if (padding) {\n            var calc = calculateLinearScalePadding(scale, offset, size);\n            offset = calc.offset;\n            size = calc.size;\n          }\n        }\n      } else {\n        if (sizeOverride) {\n          throw new Error('Not a valid option for this scale type');\n        }\n\n        var c0 = scale(v0);\n        var c1 = scale(v1);\n        var delta = c1 - c0;\n        offset = c0;\n        size = Math.max(delta - 1, 0);\n      }\n\n      return {\n        offset: isNaN(offset) ? 0 : offset,\n        size: isNaN(size) ? 0 : size\n      };\n    }, [calculateLinearScalePadding]);\n    var getValueCoords = react.useCallback(function (v0, v1, scale) {\n      var c0 = scale(v0);\n      var c1 = scale(v1);\n      var size = Math.abs(c0 - c1);\n      var minSize = Math.max(minHeight || 0, size);\n      var offset = Math.min(c0, c1);\n      return {\n        offset: isNaN(offset) ? 0 : offset,\n        size: isNaN(minSize) ? 0 : minSize\n      };\n    }, [minHeight]);\n    var getCoords = react.useCallback(function (data) {\n      var newYScale = yScale;\n      var newXScale = xScale;\n\n      if (xScale1) {\n        if (isVertical) {\n          newXScale = xScale1;\n        } else {\n          newYScale = xScale1;\n        }\n      }\n\n      if (isVertical) {\n        var xCoords = getKeyCoords(data.x, data.x0, data.x1, newXScale, width, isCategorical, padding);\n        var yCoords = getValueCoords(data.y0, data.y1, newYScale);\n        return {\n          x: xCoords.offset,\n          width: xCoords.size,\n          y: yCoords.offset,\n          height: yCoords.size\n        };\n      } else {\n        var _yCoords = getKeyCoords(data.y, data.y0, data.y1, newYScale, width, isCategorical, padding);\n\n        var _xCoords = getValueCoords(data.x0, data.x1, newXScale);\n\n        return {\n          x: _xCoords.offset,\n          width: _xCoords.size,\n          y: _yCoords.offset,\n          height: _yCoords.size\n        };\n      }\n    }, [getKeyCoords, getValueCoords, isCategorical, isVertical, padding, width, xScale, xScale1, yScale]);\n    var onMouseEnterInternal = react.useCallback(function (event) {\n      // Only tooltip bars rely on this...\n      if (tooltip) {\n        setInternalActive(true);\n      }\n\n      onMouseEnter({\n        value: data,\n        nativeEvent: event\n      });\n    }, [data, onMouseEnter, tooltip]);\n    var onMouseLeaveInternal = react.useCallback(function (event) {\n      // Only tooltip bars rely on this...\n      if (tooltip) {\n        setInternalActive(false);\n      }\n\n      onMouseLeave({\n        value: data,\n        nativeEvent: event\n      });\n    }, [data, onMouseLeave, tooltip]);\n    var onMouseClick = react.useCallback(function (event) {\n      onClick({\n        value: data,\n        nativeEvent: event\n      });\n    }, [data, onClick]);\n    var getFill = react.useCallback(function (color) {\n      if (mask) {\n        return \"url(#mask-pattern-\".concat(id, \")\");\n      } else {\n        if (gradient) {\n          return \"url(#gradient-\".concat(id, \")\");\n        }\n\n        return color;\n      }\n    }, [gradient, id, mask]);\n    var tooltipData = react.useMemo(function () {\n      var xAttr = isCategorical ? 'x' : 'x0';\n      var x = data[xAttr]; // Stacked diverging negative numbers\n      // in horizontal layouts need to pull x0\n\n      if (data.x0 < 0) {\n        x = data.x0;\n      }\n\n      var matches = isVertical ? data.key && data.key !== x : data.key && data.key !== data.y;\n\n      if (matches) {\n        x = \"\".concat(data.key, \" \\u2219 \").concat(x);\n      }\n\n      return {\n        y: data.y,\n        x: x\n      };\n    }, [data, isCategorical, isVertical]);\n    var getTransition = react.useCallback(function (index) {\n      if (animated) {\n        var delay = 0;\n\n        if (layout === 'vertical') {\n          delay = index / barCount * 0.5;\n        } else {\n          delay = (barCount - index) / barCount * 0.5;\n        }\n\n        return Object.assign(Object.assign({}, DEFAULT_TRANSITION), {\n          delay: delay\n        });\n      } else {\n        return {\n          type: false,\n          delay: 0\n        };\n      }\n    }, [animated, barCount, layout]);\n    var renderBar = react.useCallback(function (currentColorShade, coords, index) {\n      var maskPath = mask ? \"url(#mask-\".concat(id, \")\") : '';\n      var fill = getFill(currentColorShade);\n      var initialExit = getExit(coords);\n      var extras = constructFunctionProps({\n        className: className,\n        style: style\n      }, data);\n      var transition = getTransition(index); // UGH: https://github.com/framer/motion/issues/384\n\n      var initial = Object.assign(Object.assign({}, initialExit), {\n        attrX: initialExit.x,\n        attrY: initialExit.y,\n        fill: fill\n      });\n      delete initial.x;\n      delete initial.y;\n      var animate = Object.assign(Object.assign({}, coords), {\n        attrX: coords.x,\n        attrY: coords.y,\n        fill: fill\n      });\n      delete animate.x;\n      delete animate.y;\n      return jsxRuntime.jsx(\"g\", Object.assign({\n        ref: rect\n      }, {\n        children: jsxRuntime.jsx(framerMotion.motion.rect, {\n          className: classNames__default['default'](extras.className),\n          style: Object.assign(Object.assign({}, extras.style), {\n            cursor: cursor\n          }),\n          mask: maskPath,\n          rx: rx,\n          ry: ry,\n          initial: initial,\n          animate: animate,\n          exit: initial,\n          transition: transition,\n          onMouseEnter: onMouseEnterInternal,\n          onMouseLeave: onMouseLeaveInternal,\n          onClick: onMouseClick,\n          onMouseMove: onMouseMove\n        }, void 0)\n      }), void 0);\n    }, [className, cursor, data, getExit, getFill, getTransition, id, mask, onMouseClick, onMouseEnterInternal, onMouseLeaveInternal, onMouseMove, rx, ry, style]);\n    var renderGuideBar = react.useCallback(function () {\n      var _Object$assign2;\n\n      if (!guide) {\n        return null;\n      } // If we are stacked, only render the first bar\n\n\n      if (type === 'stacked' && barIndex !== 0) {\n        return null;\n      } // No reason to show them since they are always 100% tall\n\n\n      if (type === 'stackedNormalized' || type === 'marimekko') {\n        console.error('Guide bars are not supported for these chart types');\n        return null;\n      }\n\n      var valueScale = isVertical ? yScale : xScale;\n\n      var _valueScale$domain = valueScale.domain(),\n          _valueScale$domain2 = _slicedToArray(_valueScale$domain, 2),\n          start = _valueScale$domain2[0],\n          end = _valueScale$domain2[1];\n\n      var attr = isVertical ? 'y' : 'x'; // For stacked diverging we need to flip the points for positive / negative bars\n\n      var attrStart = type === 'stackedDiverging' ? '0' : '1';\n      var endPoint = type === 'stackedDiverging' ? start : end;\n      var startPoint = type === 'stackedDiverging' && data[attr] > 0 ? end : endPoint;\n      var coords = getCoords(Object.assign(Object.assign({}, data), (_Object$assign2 = {}, _defineProperty(_Object$assign2, attr, endPoint), _defineProperty(_Object$assign2, \"\".concat(attr).concat(attrStart), startPoint), _Object$assign2)));\n      return jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n        element: guide\n      }, coords, {\n        active: active\n      }), void 0);\n    }, [active, barIndex, data, getCoords, guide, isVertical, type, xScale, yScale]);\n    var isActive = tooltip ? internalActive : active;\n    var stroke = color(data, barIndex);\n    var coords = getCoords(data);\n    var currentColorShade = active ? chroma__default['default'](stroke).brighten(activeBrightness).hex() : stroke;\n    var rangeLineColor = rangeLines && rangeLines.props.color || stroke;\n    var rangeLineColorShade = active ? chroma__default['default'](rangeLineColor).brighten(activeBrightness) : rangeLineColor;\n    var index = groupIndex !== undefined ? groupIndex : barIndex;\n    var scale = isVertical ? yScale : xScale;\n    var barLabel = isVertical ? tooltipData.y : tooltipData.x;\n    var placement = layout === 'vertical' ? 'top' : 'right';\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [renderGuideBar(), renderBar(currentColorShade, coords, index), rangeLines && jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n        element: rangeLines\n      }, coords, {\n        index: index,\n        data: data,\n        scale: scale,\n        color: rangeLineColorShade,\n        barCount: barCount,\n        animated: animated,\n        layout: layout,\n        type: type\n      }), void 0), mask && jsxRuntime.jsxs(react.Fragment, {\n        children: [jsxRuntime.jsx(Mask, {\n          id: \"mask-\".concat(id),\n          fill: \"url(#gradient-\".concat(id, \")\")\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: mask,\n          id: \"mask-pattern-\".concat(id),\n          fill: stroke\n        }, void 0)]\n      }, void 0), gradient && jsxRuntime.jsx(rdk.CloneElement, {\n        element: gradient,\n        id: \"gradient-\".concat(id),\n        direction: layout,\n        color: currentColorShade\n      }, void 0), label && jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n        element: label\n      }, coords, {\n        text: formatValue(barLabel),\n        index: index,\n        data: data,\n        scale: scale,\n        fill: label.props.fill || currentColorShade,\n        barCount: barCount,\n        animated: animated,\n        layout: layout,\n        type: type\n      }), void 0), tooltip && jsxRuntime.jsx(rdk.CloneElement, {\n        element: tooltip,\n        visible: !!isActive,\n        reference: rect,\n        color: color,\n        value: tooltipData,\n        placement: tooltip.props.placement || placement,\n        data: data\n      }, void 0)]\n    }, void 0);\n  };\n\n  Bar.defaultProps = {\n    activeBrightness: 0.5,\n    rx: 0,\n    ry: 0,\n    cursor: 'auto',\n    rangeLines: null,\n    label: null,\n    tooltip: null,\n    layout: 'vertical',\n    guide: null,\n    gradient: jsxRuntime.jsx(Gradient, {}, void 0),\n    onClick: function onClick() {\n      return undefined;\n    },\n    onMouseEnter: function onMouseEnter() {\n      return undefined;\n    },\n    onMouseLeave: function onMouseLeave() {\n      return undefined;\n    },\n    onMouseMove: function onMouseMove() {\n      return undefined;\n    }\n  };\n\n  var BarSeries = function BarSeries(_ref37) {\n    var data = _ref37.data,\n        tooltip = _ref37.tooltip,\n        xScale = _ref37.xScale,\n        yScale = _ref37.yScale,\n        height = _ref37.height,\n        width = _ref37.width,\n        colorScheme = _ref37.colorScheme,\n        xScale1 = _ref37.xScale1,\n        bar = _ref37.bar,\n        padding = _ref37.padding,\n        animated = _ref37.animated,\n        isCategorical = _ref37.isCategorical,\n        layout = _ref37.layout,\n        type = _ref37.type,\n        id = _ref37.id;\n    var ref = react.useRef(null);\n\n    var _react$useState33 = react.useState(null),\n        _react$useState34 = _slicedToArray(_react$useState33, 2),\n        activeValues = _react$useState34[0],\n        setActiveValues = _react$useState34[1];\n\n    var isVertical = react.useMemo(function () {\n      return layout === 'vertical';\n    }, [layout]);\n    var isMultiSeries = react.useMemo(function () {\n      return type === 'grouped' || type === 'stacked' || type === 'marimekko' || type === 'stackedNormalized' || type === 'stackedDiverging';\n    }, [type]);\n    var getTransform = react.useCallback(function (data) {\n      var xPos = 0;\n      var yPos = 0;\n\n      if (type !== 'marimekko') {\n        if (layout === 'vertical') {\n          var val = xScale(data.key);\n          xPos = val;\n        } else {\n          var _val = yScale(data.key);\n\n          yPos = _val;\n        }\n      }\n\n      return \"translate(\".concat(xPos, \", \").concat(yPos, \")\");\n    }, [layout, type, xScale, yScale]);\n    var getBarColor = react.useCallback(function (point, index) {\n      var key = 'key';\n\n      if (isMultiSeries) {\n        if (layout === 'vertical') {\n          key = 'x';\n        } else {\n          key = 'y';\n        }\n      } // histograms...\n\n\n      if (point[key] === undefined) {\n        key = 'x0';\n      }\n\n      return getColor({\n        colorScheme: colorScheme,\n        point: point,\n        index: index,\n        data: data,\n        isMultiSeries: isMultiSeries,\n        attribute: key\n      });\n    }, [colorScheme, data, isMultiSeries, layout]);\n    var onMouseMove = react.useCallback(function (event) {\n      var _a; // Manuallly call mouse move so we don't have to kill bar pointer events\n\n\n      (_a = ref.current) === null || _a === void 0 ? void 0 : _a.onMouseMove(event);\n    }, []);\n    var onValueEnter = react.useCallback(function (event) {\n      setActiveValues(event.value);\n    }, []);\n    var onValueLeave = react.useCallback(function () {\n      setActiveValues(null);\n    }, []);\n    var renderBar = react.useCallback(function (data, barIndex, barCount, groupIndex) {\n      var active = activeValues && activeValues.x === data.key;\n      var newYScale = yScale;\n      var newXScale = xScale;\n\n      if (xScale1) {\n        if (isVertical) {\n          newXScale = xScale1;\n        } else {\n          newYScale = xScale1;\n        }\n      } // Histograms dont have keys\n\n\n      var key = barIndex.toString();\n\n      if (data.key) {\n        key = \"\".concat(data.key.toString(), \"-\").concat(groupIndex, \"-\").concat(data.x);\n      }\n\n      var barElements = Array.isArray(bar) ? bar[barIndex] : bar;\n\n      if (!bar) {\n        barElements = jsxRuntime.jsx(Bar, {}, void 0);\n      }\n\n      return jsxRuntime.jsx(react.Fragment, {\n        children: jsxRuntime.jsx(rdk.CloneElement, {\n          element: barElements,\n          id: \"\".concat(id, \"-bar-\").concat(groupIndex, \"-\").concat(barIndex),\n          animated: animated,\n          active: active,\n          xScale: newXScale,\n          xScale1: xScale1,\n          yScale: newYScale,\n          padding: padding,\n          barCount: barCount,\n          groupIndex: groupIndex,\n          barIndex: barIndex,\n          data: data,\n          isCategorical: isCategorical,\n          color: getBarColor,\n          layout: layout,\n          type: type,\n          onMouseMove: onMouseMove\n        }, void 0)\n      }, key);\n    }, [activeValues, animated, bar, getBarColor, id, isCategorical, isVertical, layout, onMouseMove, padding, type, xScale, xScale1, yScale]);\n    var renderBarGroup = react.useCallback(function (data, barCount, groupIndex) {\n      return jsxRuntime.jsx(react.Fragment, {\n        children: data.map(function (barData, barIndex) {\n          return renderBar(barData, barIndex, barCount, groupIndex);\n        })\n      }, void 0);\n    }, [renderBar]);\n    return jsxRuntime.jsxs(rdk.CloneElement, Object.assign({\n      element: tooltip,\n      childRef: ref,\n      xScale: xScale,\n      yScale: yScale,\n      data: data,\n      height: height,\n      width: width,\n      inverse: false,\n      isHorizontal: layout === 'horizontal',\n      color: getBarColor,\n      onValueEnter: onValueEnter,\n      onValueLeave: onValueLeave\n    }, {\n      children: [isMultiSeries && data.map(function (groupData, index) {\n        return jsxRuntime.jsx(\"g\", Object.assign({\n          transform: getTransform(groupData)\n        }, {\n          children: renderBarGroup(groupData.data, data.length, index)\n        }), \"bar-group-\".concat(index));\n      }), !isMultiSeries && renderBarGroup(data, data.length)]\n    }), void 0);\n  };\n\n  BarSeries.defaultProps = {\n    type: 'standard',\n    padding: 0.1,\n    groupPadding: 16,\n    animated: true,\n    tooltip: jsxRuntime.jsx(TooltipArea, {\n      tooltip: jsxRuntime.jsx(ChartTooltip, {\n        followCursor: true,\n        modifiers: {\n          offset: '5px, 5px'\n        }\n      }, void 0)\n    }, void 0),\n    colorScheme: 'cybertron',\n    bar: jsxRuntime.jsx(Bar, {}, void 0),\n    layout: 'vertical'\n  };\n\n  var RangeLines = function RangeLines(_ref38) {\n    var layout = _ref38.layout,\n        color = _ref38.color,\n        x = _ref38.x,\n        y = _ref38.y,\n        scale = _ref38.scale,\n        type = _ref38.type,\n        height = _ref38.height,\n        position = _ref38.position,\n        strokeWidth = _ref38.strokeWidth,\n        width = _ref38.width,\n        animated = _ref38.animated,\n        index = _ref38.index,\n        barCount = _ref38.barCount,\n        data = _ref38.data;\n    var isVertical = react.useMemo(function () {\n      return layout === 'vertical';\n    }, [layout]);\n    var rangeLineHeight = react.useMemo(function () {\n      return Math.min(strokeWidth, isVertical ? height : width);\n    }, [height, isVertical, strokeWidth, width]);\n\n    var _react$useMemo2 = react.useMemo(function () {\n      return [isVertical ? width : rangeLineHeight, isVertical ? rangeLineHeight : height];\n    }, [height, isVertical, rangeLineHeight, width]),\n        _react$useMemo3 = _slicedToArray(_react$useMemo2, 2),\n        newWidth = _react$useMemo3[0],\n        newHeight = _react$useMemo3[1];\n\n    var enterProps = react.useMemo(function () {\n      var newY = y;\n      var newX = x; // If its diverging and the value is negative, we\n      // need to reverse the type...\n\n      var isTop = position === 'top';\n      var direction = isVertical ? data.y < 0 && isTop ? 'bottom' : position : data.x0 < 0 && isTop ? 'bottom' : position;\n\n      if (isVertical) {\n        if (direction === 'top') {\n          newY = y;\n        } else {\n          newY = y + height - rangeLineHeight;\n        }\n      } else {\n        if (direction === 'top') {\n          newX = x + width - rangeLineHeight;\n        } else {\n          newX = x;\n        }\n      }\n\n      return {\n        x: newX,\n        y: newY,\n        opacity: 1\n      };\n    }, [data.x0, data.y, height, isVertical, position, rangeLineHeight, width, x, y]);\n    var exitProps = react.useMemo(function () {\n      var newY = y;\n      var newX = x;\n\n      if (isVertical) {\n        var maxY = Math.max.apply(Math, _toConsumableArray(scale.range()));\n\n        if (position === 'top') {\n          newY = maxY;\n        } else {\n          newY = maxY + height - rangeLineHeight;\n        }\n      } else {\n        var minX = Math.min.apply(Math, _toConsumableArray(scale.range()));\n\n        if (position === 'top') {\n          newX = minX;\n        } else {\n          newX = minX + width - rangeLineHeight;\n        }\n      }\n\n      if (type === 'stackedDiverging') {\n        if (isVertical) {\n          newY = newY / 2;\n        } else {\n          newX = newX / 2;\n        }\n      }\n\n      return {\n        y: newY,\n        x: newX,\n        opacity: 0\n      };\n    }, [height, isVertical, position, rangeLineHeight, scale, type, width, x, y]);\n    var delay = react.useMemo(function () {\n      var delay = 0;\n\n      if (animated) {\n        if (layout === 'vertical') {\n          return index / barCount * 0.5;\n        } else {\n          return (barCount - index) / barCount * 0.5;\n        }\n      }\n\n      return delay;\n    }, [animated, barCount, index, layout]); // UGH: https://github.com/framer/motion/issues/384\n\n    var initial = react.useMemo(function () {\n      var r = Object.assign(Object.assign({}, exitProps), {\n        attrX: exitProps.x,\n        attrY: exitProps.y\n      });\n      delete r.x;\n      delete r.y;\n      return r;\n    }, [exitProps]);\n    var animate = react.useMemo(function () {\n      var r = Object.assign(Object.assign({}, enterProps), {\n        attrX: enterProps.x,\n        attrY: enterProps.y\n      });\n      delete r.x;\n      delete r.y;\n      return r;\n    }, [enterProps]);\n    return jsxRuntime.jsx(framerMotion.motion.rect, {\n      pointerEvents: \"none\",\n      fill: color,\n      width: newWidth,\n      height: newHeight,\n      initial: initial,\n      animate: animate,\n      exit: initial,\n      transition: Object.assign(Object.assign({}, DEFAULT_TRANSITION), {\n        delay: delay\n      })\n    }, void 0);\n  };\n\n  RangeLines.defaultProps = {\n    position: 'top',\n    strokeWidth: 1,\n    layout: 'vertical'\n  };\n\n  var StackedBarSeries = function StackedBarSeries(props) {\n    return jsxRuntime.jsx(BarSeries, Object.assign({\n      type: \"stackedNormalized\"\n    }, props), void 0);\n  };\n\n  StackedBarSeries.defaultProps = Object.assign(Object.assign({}, BarSeries.defaultProps), {\n    type: 'stacked',\n    bar: jsxRuntime.jsx(Bar, {\n      gradient: jsxRuntime.jsx(Gradient, {\n        stops: [jsxRuntime.jsx(GradientStop, {\n          offset: \"5%\",\n          stopOpacity: 0.1\n        }, \"start\"), jsxRuntime.jsx(GradientStop, {\n          offset: \"90%\",\n          stopOpacity: 0.7\n        }, \"stop\")]\n      }, void 0),\n      rangeLines: jsxRuntime.jsx(RangeLines, {\n        position: \"top\",\n        strokeWidth: 3\n      }, void 0)\n    }, void 0)\n  });\n\n  var StackedNormalizedBarSeries = function StackedNormalizedBarSeries(props) {\n    return jsxRuntime.jsx(BarSeries, Object.assign({\n      type: \"stackedNormalized\"\n    }, props), void 0);\n  };\n\n  StackedNormalizedBarSeries.defaultProps = Object.assign(Object.assign({}, BarSeries.defaultProps), {\n    type: 'stackedNormalized',\n    tooltip: jsxRuntime.jsx(TooltipArea, {\n      tooltip: jsxRuntime.jsx(ChartTooltip, {\n        followCursor: true,\n        modifiers: {\n          offset: '5px, 5px'\n        },\n        content: function content(point, color) {\n          point.data = point.data.map(function (d) {\n            // Handle horz case\n            var start = isNaN(d.y0) ? d.x0 : d.y0;\n            var end = isNaN(d.y1) ? d.x1 : d.y1;\n            return Object.assign(Object.assign({}, d), {\n              value: \"\".concat(formatValue(Math.floor((end - start) * 100)), \"%\")\n            });\n          });\n          return jsxRuntime.jsx(TooltipTemplate, {\n            value: point,\n            color: color\n          }, void 0);\n        }\n      }, void 0)\n    }, void 0),\n    bar: jsxRuntime.jsx(Bar, {\n      gradient: jsxRuntime.jsx(Gradient, {\n        stops: [jsxRuntime.jsx(GradientStop, {\n          offset: \"5%\",\n          stopOpacity: 0.1\n        }, \"start\"), jsxRuntime.jsx(GradientStop, {\n          offset: \"90%\",\n          stopOpacity: 0.7\n        }, \"stop\")]\n      }, void 0),\n      rangeLines: jsxRuntime.jsx(RangeLines, {\n        position: \"top\",\n        strokeWidth: 3\n      }, void 0)\n    }, void 0)\n  });\n\n  var MarimekkoBarSeries = function MarimekkoBarSeries(props) {\n    return jsxRuntime.jsx(BarSeries, Object.assign({\n      type: \"marimekko\"\n    }, props), void 0);\n  };\n\n  MarimekkoBarSeries.defaultProps = Object.assign(Object.assign({}, BarSeries.defaultProps), {\n    type: 'marimekko',\n    padding: 10,\n    tooltip: jsxRuntime.jsx(TooltipArea, {\n      tooltip: jsxRuntime.jsx(ChartTooltip, {\n        followCursor: true,\n        modifiers: {\n          offset: '5px, 5px'\n        },\n        content: function content(point, color) {\n          var data = Object.assign(Object.assign({}, point), {\n            data: point.data.map(function (d) {\n              return Object.assign(Object.assign({}, d), {\n                value: \"\".concat(formatValue(d.value), \" \\u2219 \").concat(formatValue(Math.floor((d.y1 - d.y0) * 100)), \"%\")\n              });\n            })\n          });\n          return jsxRuntime.jsx(TooltipTemplate, {\n            value: data,\n            color: color\n          }, void 0);\n        }\n      }, void 0)\n    }, void 0),\n    bar: jsxRuntime.jsx(Bar, {\n      padding: 10,\n      gradient: jsxRuntime.jsx(Gradient, {\n        stops: [jsxRuntime.jsx(GradientStop, {\n          offset: \"5%\",\n          stopOpacity: 0.1\n        }, \"start\"), jsxRuntime.jsx(GradientStop, {\n          offset: \"90%\",\n          stopOpacity: 0.7\n        }, \"stop\")]\n      }, void 0),\n      rangeLines: jsxRuntime.jsx(RangeLines, {\n        position: \"top\",\n        strokeWidth: 3\n      }, void 0)\n    }, void 0)\n  });\n\n  var BarLabel = function BarLabel(_ref39) {\n    var fontSize = _ref39.fontSize,\n        fontFamily = _ref39.fontFamily,\n        fill = _ref39.fill,\n        layout = _ref39.layout,\n        className = _ref39.className,\n        text = _ref39.text,\n        x = _ref39.x,\n        y = _ref39.y,\n        height = _ref39.height,\n        position = _ref39.position,\n        width = _ref39.width,\n        data = _ref39.data,\n        padding = _ref39.padding,\n        scale = _ref39.scale,\n        type = _ref39.type,\n        animated = _ref39.animated,\n        index = _ref39.index,\n        barCount = _ref39.barCount;\n    var isVertical = react.useMemo(function () {\n      return layout === 'vertical';\n    }, [layout]);\n    var textAnchor = isVertical ? 'middle' : 'start';\n    var enterProps = react.useMemo(function () {\n      var newY = y;\n      var newX = x; // If its diverging and the value is negative, we\n      // need to reverse the type...\n\n      var isTop = position === 'top';\n      var direction = isVertical ? data.y < 0 && isTop ? 'bottom' : position : data.x0 < 0 && isTop ? 'bottom' : position;\n\n      if (isVertical) {\n        if (direction === 'top') {\n          newY = y - padding;\n        } else if (direction === 'center') {\n          newY = y + height / 2;\n        } else if (direction === 'bottom') {\n          newY = y + height - padding;\n        }\n\n        newX = newX + width / 2;\n      } else {\n        if (direction === 'top') {\n          newX = x + width + padding;\n        } else if (direction === 'center') {\n          newX = x + width / 2;\n        } else if (direction === 'bottom') {\n          newX = x + padding;\n        }\n\n        newY = newY + height / 2;\n      }\n\n      return {\n        translateX: newX,\n        translateY: newY,\n        opacity: 1\n      };\n    }, [data.x0, data.y, height, isVertical, padding, position, width, x, y]);\n    var exitProps = react.useMemo(function () {\n      var newY = y;\n      var newX = x;\n\n      if (isVertical) {\n        var maxY = Math.max.apply(Math, _toConsumableArray(scale.range()));\n\n        if (position === 'top') {\n          newY = maxY;\n        } else {\n          newY = maxY + height + padding;\n        }\n\n        newX = newX + width / 2;\n      } else {\n        var minX = Math.min.apply(Math, _toConsumableArray(scale.range()));\n\n        if (position === 'top') {\n          newX = minX;\n        } else {\n          newX = minX + width + padding;\n        }\n\n        newY = newY + height / 2;\n      }\n\n      if (type === 'stackedDiverging') {\n        if (isVertical) {\n          newY = newY / 2;\n        } else {\n          newX = newX / 2;\n        }\n      }\n\n      return {\n        translateY: newY,\n        translateX: newX,\n        opacity: 0\n      };\n    }, [height, isVertical, padding, position, scale, type, width, x, y]);\n    var delay = react.useMemo(function () {\n      var delay = 0;\n\n      if (animated) {\n        if (layout === 'vertical') {\n          return index / barCount * 0.5;\n        } else {\n          return (barCount - index) / barCount * 0.5;\n        }\n      }\n\n      return delay;\n    }, [animated, barCount, index, layout]);\n    return jsxRuntime.jsx(framerMotion.motion.g, Object.assign({\n      initial: exitProps,\n      animate: enterProps,\n      exit: exitProps,\n      transition: Object.assign(Object.assign({}, DEFAULT_TRANSITION), {\n        delay: delay\n      }),\n      fontSize: fontSize,\n      fontFamily: fontFamily\n    }, {\n      children: jsxRuntime.jsx(\"text\", Object.assign({\n        fill: fill,\n        className: className,\n        textAnchor: textAnchor\n      }, {\n        children: text\n      }), void 0)\n    }), void 0);\n  };\n\n  BarLabel.defaultProps = {\n    position: 'top',\n    layout: 'vertical',\n    fontSize: 13,\n    padding: 5,\n    fontFamily: 'sans-serif',\n    fill: '#000'\n  };\n\n  var HistogramBarSeries = function HistogramBarSeries(_a) {\n    var rest = __rest(_a, [\"type\"]);\n\n    return jsxRuntime.jsx(BarSeries, Object.assign({}, rest), void 0);\n  };\n\n  HistogramBarSeries.defaultProps = Object.assign(Object.assign({}, BarSeries.defaultProps), {\n    colorScheme: schemes.cybertron[0],\n    tooltip: jsxRuntime.jsx(TooltipArea, {\n      tooltip: jsxRuntime.jsx(ChartTooltip, {\n        followCursor: true,\n        modifiers: {\n          offset: '5px, 5px'\n        },\n        content: function content(point, color) {\n          var data = Object.assign(Object.assign({}, point), {\n            x: \"\".concat(formatValue(point.x0), \" - \").concat(formatValue(point.x1)),\n            value: point.y\n          });\n          return jsxRuntime.jsx(TooltipTemplate, {\n            value: data,\n            color: color\n          }, void 0);\n        }\n      }, void 0)\n    }, void 0)\n  });\n\n  var GuideBar = function GuideBar(_a) {\n    var active = _a.active,\n        _a$opacity = _a.opacity,\n        opacity = _a$opacity === void 0 ? 0.15 : _a$opacity,\n        rest = __rest(_a, [\"active\", \"opacity\"]);\n\n    var x = rest.x,\n        y = rest.y,\n        other = __rest(rest, [\"x\", \"y\"]);\n\n    return jsxRuntime.jsx(framerMotion.motion.rect, Object.assign({}, other, {\n      pointerEvents: \"none\",\n      initial: \"hidden\",\n      animate: active ? 'visible' : 'hidden',\n      variants: {\n        hidden: {\n          opacity: 0,\n          attrX: x,\n          attrY: y\n        },\n        visible: {\n          opacity: opacity,\n          attrX: x,\n          attrY: y\n        }\n      }\n    }), void 0);\n  };\n\n  GuideBar.defaultProps = {\n    fill: '#eee',\n    opacity: 0.15\n  };\n  var css_248z$e = \".BarChart-module_barChart__36biH {\\n  overflow: visible;\\n}\\n\\n  .BarChart-module_barChart__36biH.BarChart-module_stackedNormalized__3l5Vx .bar, .BarChart-module_barChart__36biH.BarChart-module_stacked__12DMR .bar, .BarChart-module_barChart__36biH.BarChart-module_marimekko__33Uhg .bar {\\n      stroke: var(--color-background);\\n      stroke-width: 0.2;\\n    }\\n\";\n  var css$e = {\n    \"barChart\": \"BarChart-module_barChart__36biH\",\n    \"stackedNormalized\": \"BarChart-module_stackedNormalized__3l5Vx\",\n    \"stacked\": \"BarChart-module_stacked__12DMR\",\n    \"marimekko\": \"BarChart-module_marimekko__33Uhg\"\n  };\n  styleInject(css_248z$e);\n\n  var BarChart = function BarChart(_ref40) {\n    var id = _ref40.id,\n        width = _ref40.width,\n        height = _ref40.height,\n        margins = _ref40.margins,\n        className = _ref40.className,\n        data = _ref40.data,\n        xAxis = _ref40.xAxis,\n        yAxis = _ref40.yAxis,\n        series = _ref40.series,\n        brush = _ref40.brush,\n        gridlines = _ref40.gridlines,\n        secondaryAxis = _ref40.secondaryAxis,\n        containerClassName = _ref40.containerClassName;\n    var isVertical = react.useMemo(function () {\n      return series.props.layout === 'vertical';\n    }, [series]);\n    var keyAxis = react.useMemo(function () {\n      return isVertical ? xAxis : yAxis;\n    }, [yAxis, xAxis, isVertical]);\n    var isDiverging = react.useMemo(function () {\n      return series.props.type === 'stackedDiverging';\n    }, [series.props.type]);\n    var getMarimekkoGroupScales = react.useCallback(function (aggregatedData, axis, width) {\n      var keyScale = getMarimekkoScale(width, axis.props.roundDomains);\n      var groupScale = getMarimekkoGroupScale({\n        width: width,\n        padding: series.props.padding,\n        data: aggregatedData,\n        valueScale: keyScale\n      });\n      return {\n        keyScale: keyScale,\n        groupScale: groupScale\n      };\n    }, [series.props.padding]);\n    var getMultiGroupScales = react.useCallback(function (aggregatedData, height, width) {\n      var _series$props = series.props,\n          groupPadding = _series$props.groupPadding,\n          layout = _series$props.layout;\n      var groupScale = getGroupScale({\n        dimension: isVertical ? width : height,\n        direction: layout,\n        padding: groupPadding,\n        data: aggregatedData\n      });\n      var keyScale = getInnerScale({\n        groupScale: groupScale,\n        padding: series.props.padding,\n        data: aggregatedData,\n        prop: isVertical ? 'x' : 'y'\n      });\n      return {\n        groupScale: groupScale,\n        keyScale: keyScale\n      };\n    }, [isVertical, series.props]);\n    var getKeyScale = react.useCallback(function (aggregatedData, axis, isMultiSeries, width) {\n      return getXScale({\n        width: width,\n        type: axis.props.type,\n        roundDomains: axis.props.roundDomains,\n        data: aggregatedData,\n        padding: series.props.padding,\n        domain: axis.props.domain,\n        isMultiSeries: isMultiSeries,\n        isDiverging: isDiverging\n      });\n    }, [isDiverging, series]);\n    var getValueScale = react.useCallback(function (aggregatedData, axis, isMultiSeries, height) {\n      return getYScale({\n        roundDomains: axis.props.roundDomains,\n        padding: series.props.padding,\n        type: axis.props.type,\n        height: height,\n        data: aggregatedData,\n        domain: axis.props.domain,\n        isMultiSeries: isMultiSeries,\n        isDiverging: isDiverging\n      });\n    }, [isDiverging, series]);\n    var getScalesAndData = react.useCallback(function (chartHeight, chartWidth) {\n      var _series$props2 = series.props,\n          type = _series$props2.type,\n          layout = _series$props2.layout;\n      var isMarimekko = type === 'marimekko';\n      var isGrouped = type === 'grouped';\n      var isStacked = type === 'stacked' || type === 'stackedNormalized' || type === 'stackedDiverging';\n      var isMultiSeries = isGrouped || isStacked;\n      var aggregatedData;\n\n      if (isStacked) {\n        var distroType = 'default';\n\n        if (type === 'stackedNormalized') {\n          distroType = 'expand';\n        } else if (type === 'stackedDiverging') {\n          distroType = 'diverging';\n        }\n\n        aggregatedData = buildBarStackData(data, distroType, layout);\n      } else if (type === 'waterfall') {\n        aggregatedData = buildWaterfall(data, layout, series.props.binSize);\n      } else if (isMarimekko) {\n        aggregatedData = buildMarimekkoData(data);\n      } else if (isGrouped) {\n        aggregatedData = buildNestedChartData(data, false, layout);\n      } else {\n        aggregatedData = buildShallowChartData(data, layout, series.props.binSize);\n      }\n\n      var yScale;\n      var xScale;\n      var xScale1;\n\n      if (isVertical) {\n        if (isGrouped) {\n          var _getMultiGroupScales = getMultiGroupScales(aggregatedData, chartHeight, chartWidth),\n              keyScale = _getMultiGroupScales.keyScale,\n              groupScale = _getMultiGroupScales.groupScale;\n\n          xScale = groupScale;\n          xScale1 = keyScale;\n        } else if (isMarimekko) {\n          var _getMarimekkoGroupSca = getMarimekkoGroupScales(aggregatedData, xAxis, chartWidth),\n              _keyScale = _getMarimekkoGroupSca.keyScale,\n              _groupScale = _getMarimekkoGroupSca.groupScale;\n\n          xScale = _groupScale;\n          xScale1 = _keyScale;\n        } else {\n          xScale = getKeyScale(aggregatedData, xAxis, isMultiSeries, chartWidth);\n        }\n\n        yScale = getValueScale(aggregatedData, yAxis, isMultiSeries, chartHeight);\n      } else {\n        if (isGrouped) {\n          var _getMultiGroupScales2 = getMultiGroupScales(aggregatedData, chartHeight, chartWidth),\n              _keyScale2 = _getMultiGroupScales2.keyScale,\n              _groupScale2 = _getMultiGroupScales2.groupScale;\n\n          yScale = _groupScale2;\n          xScale1 = _keyScale2;\n          xScale = getKeyScale(aggregatedData, xAxis, isMultiSeries, chartWidth);\n        } else if (isMarimekko) {\n          throw new Error('Marimekko is currently not supported for horizontal layouts');\n        } else {\n          xScale = getKeyScale(aggregatedData, xAxis, isMultiSeries, chartWidth);\n          yScale = getValueScale(aggregatedData, yAxis, isMultiSeries, chartHeight);\n        }\n      }\n\n      return {\n        xScale: xScale,\n        xScale1: xScale1,\n        yScale: yScale,\n        aggregatedData: aggregatedData\n      };\n    }, [getKeyScale, data, getMarimekkoGroupScales, getMultiGroupScales, getValueScale, isVertical, series.props, xAxis, yAxis]);\n    var renderChart = react.useCallback(function (containerProps) {\n      var chartHeight = containerProps.chartHeight,\n          chartWidth = containerProps.chartWidth,\n          id = containerProps.id,\n          updateAxes = containerProps.updateAxes,\n          chartSized = containerProps.chartSized;\n\n      var _getScalesAndData = getScalesAndData(chartHeight, chartWidth),\n          xScale = _getScalesAndData.xScale,\n          xScale1 = _getScalesAndData.xScale1,\n          yScale = _getScalesAndData.yScale,\n          aggregatedData = _getScalesAndData.aggregatedData;\n\n      var isCategorical = keyAxis.props.type === 'category';\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [chartSized && gridlines && jsxRuntime.jsx(rdk.CloneElement, {\n          element: gridlines,\n          height: chartHeight,\n          width: chartWidth,\n          yScale: yScale,\n          xScale: xScale,\n          yAxis: yAxis.props,\n          xAxis: xAxis.props\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: xAxis,\n          height: chartHeight,\n          width: chartWidth,\n          scale: xScale,\n          onDimensionsChange: function onDimensionsChange(event) {\n            return updateAxes(isVertical ? 'horizontal' : 'vertical', event);\n          }\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: yAxis,\n          height: chartHeight,\n          width: chartWidth,\n          scale: yScale,\n          onDimensionsChange: function onDimensionsChange(event) {\n            return updateAxes(isVertical ? 'vertical' : 'horizontal', event);\n          }\n        }, void 0), secondaryAxis && secondaryAxis.map(function (axis, i) {\n          return jsxRuntime.jsx(rdk.CloneElement, {\n            element: axis,\n            height: chartHeight,\n            width: chartWidth,\n            onDimensionsChange: function onDimensionsChange(event) {\n              return updateAxes('horizontal', event);\n            }\n          }, i);\n        }), chartSized && jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n          element: brush,\n          height: chartHeight,\n          width: chartWidth,\n          scale: xScale\n        }, {\n          children: jsxRuntime.jsx(rdk.CloneElement, {\n            element: series,\n            id: \"bar-series-\".concat(id),\n            data: aggregatedData,\n            height: chartHeight,\n            width: chartWidth,\n            isCategorical: isCategorical,\n            xScale: xScale,\n            xScale1: xScale1,\n            yScale: yScale\n          }, void 0)\n        }), void 0)]\n      }, void 0);\n    }, [brush, getScalesAndData, gridlines, isVertical, keyAxis, secondaryAxis, series, xAxis, yAxis]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      margins: margins,\n      containerClassName: containerClassName,\n      xAxisVisible: isAxisVisible(xAxis.props),\n      yAxisVisible: isAxisVisible(yAxis.props),\n      className: classNames__default['default'](css$e.barChart, className, css$e[series.props.type])\n    }, {\n      children: renderChart\n    }), void 0);\n  };\n\n  BarChart.defaultProps = {\n    data: [],\n    xAxis: jsxRuntime.jsx(LinearXAxis, {\n      type: \"category\",\n      tickSeries: jsxRuntime.jsx(LinearXAxisTickSeries, {\n        tickSize: 20\n      }, void 0)\n    }, void 0),\n    yAxis: jsxRuntime.jsx(LinearYAxis, {\n      type: \"value\"\n    }, void 0),\n    series: jsxRuntime.jsx(BarSeries, {}, void 0),\n    gridlines: jsxRuntime.jsx(GridlineSeries, {}, void 0),\n    brush: null\n  };\n\n  var MarimekkoChart = function MarimekkoChart(props) {\n    return jsxRuntime.jsx(BarChart, Object.assign({}, props), void 0);\n  };\n\n  MarimekkoChart.defaultProps = {\n    series: jsxRuntime.jsx(MarimekkoBarSeries, {}, void 0),\n    xAxis: jsxRuntime.jsx(LinearXAxis, {\n      type: \"category\",\n      tickSeries: jsxRuntime.jsx(LinearXAxisTickSeries, {\n        tickSize: 15\n      }, void 0)\n    }, void 0),\n    yAxis: jsxRuntime.jsx(LinearYAxis, {\n      type: \"value\",\n      tickSeries: jsxRuntime.jsx(LinearYAxisTickSeries, {\n        label: jsxRuntime.jsx(LinearYAxisTickLabel, {\n          rotation: false,\n          format: function format(data) {\n            return \"\".concat(data * 100, \"%\");\n          }\n        }, void 0)\n      }, void 0)\n    }, void 0)\n  };\n\n  var StackedBarChart = function StackedBarChart(props) {\n    return jsxRuntime.jsx(BarChart, Object.assign({}, props), void 0);\n  };\n\n  StackedBarChart.defaultProps = {\n    series: jsxRuntime.jsx(StackedBarSeries, {}, void 0)\n  };\n\n  var StackedNormalizedBarChart = function StackedNormalizedBarChart(props) {\n    return jsxRuntime.jsx(BarChart, Object.assign({}, props), void 0);\n  };\n\n  StackedNormalizedBarChart.defaultProps = {\n    series: jsxRuntime.jsx(StackedNormalizedBarSeries, {}, void 0),\n    yAxis: jsxRuntime.jsx(LinearYAxis, {\n      type: \"value\",\n      tickSeries: jsxRuntime.jsx(LinearYAxisTickSeries, {\n        label: jsxRuntime.jsx(LinearYAxisTickLabel, {\n          rotation: false,\n          format: function format(data) {\n            return \"\".concat(data * 100, \"%\");\n          }\n        }, void 0)\n      }, void 0)\n    }, void 0)\n  };\n\n  var HistogramBarChart = function HistogramBarChart(props) {\n    return jsxRuntime.jsx(BarChart, Object.assign({}, props), void 0);\n  };\n\n  HistogramBarChart.defaultProps = {\n    series: jsxRuntime.jsx(HistogramBarSeries, {}, void 0)\n  };\n  var css_248z$d = \".HiveNode-module_node__3bcfx {\\n  transition: opacity 100ms ease-in-out;\\n  cursor: pointer;\\n}\\n\\n.HiveNode-module_inactive__2bS6R {\\n  opacity: 0.2;\\n}\\n\";\n  var css$d = {\n    \"node\": \"HiveNode-module_node__3bcfx\",\n    \"inactive\": \"HiveNode-module_inactive__2bS6R\"\n  };\n  styleInject(css_248z$d);\n\n  var HiveNode = function HiveNode(_ref41) {\n    var angle = _ref41.angle,\n        radius = _ref41.radius,\n        node = _ref41.node,\n        color = _ref41.color,\n        onClick = _ref41.onClick,\n        onMouseOver = _ref41.onMouseOver,\n        onMouseOut = _ref41.onMouseOut,\n        active = _ref41.active,\n        disabled = _ref41.disabled;\n    // If the size exists on the node, use it to specify the node size.\n    // Otherwise, calculate a relative size using the node count.\n    var size = node.size;\n\n    if (size === undefined) {\n      size = node.count || 0;\n    }\n\n    return jsxRuntime.jsx(\"circle\", {\n      className: classNames__default['default'](css$d.node, _defineProperty({}, css$d.inactive, !active)),\n      transform: \"rotate(\".concat(getDegrees(angle(node.x)), \")\"),\n      cx: radius(node.y),\n      r: size,\n      style: {\n        cursor: disabled ? 'initial' : 'cursor'\n      },\n      fill: color(node.x),\n      onClick: onClick,\n      onMouseOver: onMouseOver,\n      onMouseOut: onMouseOut\n    }, void 0);\n  };\n\n  var css_248z$c = \".HiveAxis-module_axis__4FERZ {\\n  stroke: #575f67;\\n  stroke-width: 1.5px;\\n}\\n\";\n  var css$c = {\n    \"axis\": \"HiveAxis-module_axis__4FERZ\"\n  };\n  styleInject(css_248z$c);\n\n  var HiveAxis = function HiveAxis(_ref42) {\n    var radius = _ref42.radius,\n        index = _ref42.index,\n        angle = _ref42.angle,\n        color = _ref42.color;\n\n    var _radius$range = radius.range(),\n        _radius$range2 = _slicedToArray(_radius$range, 2),\n        axisStart = _radius$range2[0],\n        axisEnd = _radius$range2[1];\n\n    var axisLength = axisEnd - axisStart;\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [jsxRuntime.jsx(\"line\", {\n        className: css$c.axis,\n        style: {\n          stroke: color(index)\n        },\n        transform: \"rotate(\".concat(getDegrees(angle(index)), \")\"),\n        x1: axisStart,\n        x2: axisEnd\n      }, void 0), jsxRuntime.jsx(\"line\", {\n        className: css$c.axis,\n        style: {\n          stroke: color(index)\n        },\n        transform: \"rotate(\".concat(getDegrees(angle(index)) + 90, \")\"),\n        x1: -axisLength / 20,\n        x2: axisLength / 20,\n        y1: -axisEnd,\n        y2: -axisEnd\n      }, void 0), jsxRuntime.jsx(\"line\", {\n        className: css$c.axis,\n        style: {\n          stroke: color(index)\n        },\n        transform: \"rotate(\".concat(getDegrees(angle(index)) + 90, \")\"),\n        x1: -axisStart / 3,\n        x2: 0,\n        y1: axisStart * -0.8,\n        y2: axisStart * -1\n      }, void 0), jsxRuntime.jsx(\"line\", {\n        className: css$c.axis,\n        style: {\n          stroke: color(index)\n        },\n        transform: \"rotate(\".concat(getDegrees(angle(index)) + 90, \")\"),\n        x1: 0,\n        x2: axisStart / 3,\n        y1: -axisStart,\n        y2: axisStart * -0.8\n      }, void 0)]\n    }, void 0);\n  };\n  /**\r\n   * Hive layout\r\n   * Original: https://github.com/d3/d3-plugins/tree/master/hive\r\n   */\n\n\n  function hiveLayout() {\n    var _this14 = this;\n\n    var source = function source(d) {\n      return d.source;\n    };\n\n    var target = function target(d) {\n      return d.target;\n    };\n\n    var angle = function angle(d) {\n      return d.angle;\n    };\n\n    var startRadius = function startRadius(d) {\n      return d.radius;\n    };\n\n    var endRadius = startRadius;\n    var arcOffset = -Math.PI / 2;\n\n    var link = function link(d, i) {\n      var s = node(source, _this14, d, i);\n      var t = node(target, _this14, d, i);\n      var x;\n\n      if (t.a < s.a) {\n        x = t;\n        t = s;\n        s = x;\n      }\n\n      if (t.a - s.a > Math.PI) {\n        s.a += 2 * Math.PI;\n      }\n\n      var a1 = s.a + (t.a - s.a) / 3;\n      var a2 = t.a - (t.a - s.a) / 3;\n      return s.r0 - s.r1 || t.r0 - t.r1 ? 'M' + Math.cos(s.a) * s.r0 + ',' + Math.sin(s.a) * s.r0 + 'L' + Math.cos(s.a) * s.r1 + ',' + Math.sin(s.a) * s.r1 + 'C' + Math.cos(a1) * s.r1 + ',' + Math.sin(a1) * s.r1 + ' ' + Math.cos(a2) * t.r1 + ',' + Math.sin(a2) * t.r1 + ' ' + Math.cos(t.a) * t.r1 + ',' + Math.sin(t.a) * t.r1 + 'L' + Math.cos(t.a) * t.r0 + ',' + Math.sin(t.a) * t.r0 + 'C' + Math.cos(a2) * t.r0 + ',' + Math.sin(a2) * t.r0 + ' ' + Math.cos(a1) * s.r0 + ',' + Math.sin(a1) * s.r0 + ' ' + Math.cos(s.a) * s.r0 + ',' + Math.sin(s.a) * s.r0 : 'M' + Math.cos(s.a) * s.r0 + ',' + Math.sin(s.a) * s.r0 + 'C' + Math.cos(a1) * s.r1 + ',' + Math.sin(a1) * s.r1 + ' ' + Math.cos(a2) * t.r1 + ',' + Math.sin(a2) * t.r1 + ' ' + Math.cos(t.a) * t.r1 + ',' + Math.sin(t.a) * t.r1;\n    };\n\n    var node = function node(method, thiz, d, i) {\n      var n = method.call(thiz, d, i);\n      var a = +(typeof angle === 'function' ? angle.call(thiz, n, i) : angle) + arcOffset;\n      var r0 = +(typeof startRadius === 'function' ? startRadius.call(thiz, n, i) : startRadius);\n      var r1 = startRadius === endRadius ? r0 : +(typeof endRadius === 'function' ? endRadius.call(thiz, n, i) : endRadius);\n      return {\n        r0: r0,\n        r1: r1,\n        a: a\n      };\n    };\n\n    link.source = function (s) {\n      if (!s) {\n        return source;\n      }\n\n      source = s;\n      return link;\n    };\n\n    link.target = function (t) {\n      if (!t) {\n        return target;\n      }\n\n      target = t;\n      return link;\n    };\n\n    link.angle = function (a) {\n      if (!a) {\n        return angle;\n      }\n\n      angle = a;\n      return link;\n    };\n\n    link.radius = function (r) {\n      if (!r) {\n        return startRadius;\n      }\n\n      startRadius = endRadius = r;\n      return link;\n    };\n\n    link.startRadius = function (r) {\n      if (!r) {\n        return startRadius;\n      }\n\n      startRadius = r;\n      return link;\n    };\n\n    link.endRadius = function (r) {\n      if (!r) {\n        return endRadius;\n      }\n\n      endRadius = r;\n      return link;\n    };\n\n    return link;\n  }\n\n  var css_248z$b = \".HiveLink-module_link__3WwlJ {\\n  fill: none;\\n  stroke-width: 1.5px;\\n  stroke-opacity: 0.5;\\n  transition: opacity 100ms ease-in-out;\\n}\\n\\n.HiveLink-module_inactive__3KKt1 {\\n  opacity: 0.7;\\n}\\n\";\n  var css$b = {\n    \"link\": \"HiveLink-module_link__3WwlJ\",\n    \"inactive\": \"HiveLink-module_inactive__3KKt1\"\n  };\n  styleInject(css_248z$b);\n\n  var HiveLink = function HiveLink(_ref43) {\n    var angle = _ref43.angle,\n        radius = _ref43.radius,\n        link = _ref43.link,\n        color = _ref43.color,\n        active = _ref43.active,\n        onMouseOver = _ref43.onMouseOver,\n        onMouseOut = _ref43.onMouseOut;\n\n    var prepareData = function prepareData() {\n      var hive = hiveLayout();\n      return {\n        hiveAngle: hive.angle(function (d) {\n          return angle(d.x);\n        }),\n        hiveRadius: hive.radius(function (d) {\n          return radius(d.y);\n        })\n      };\n    };\n\n    var _react$useMemo4 = react.useMemo(function () {\n      return prepareData();\n    }, [angle, radius]),\n        hiveAngle = _react$useMemo4.hiveAngle,\n        hiveRadius = _react$useMemo4.hiveRadius;\n\n    var stroke = typeof color === 'string' ? color : color(link.source.x);\n    return jsxRuntime.jsx(\"path\", {\n      className: classNames__default['default'](css$b.link, _defineProperty({}, css$b.inactive, !active)),\n      d: \"\".concat(hiveAngle(link), \" \").concat(hiveRadius(link)),\n      stroke: stroke,\n      onMouseOver: onMouseOver,\n      onMouseOut: onMouseOut\n    }, void 0);\n  };\n\n  var css_248z$a = \".HiveLabel-module_label__2I6Uz {\\n  fill: rgba(255, 255, 255, 0.5);\\n  font-size: 12px;\\n  text-transform: uppercase;\\n}\\n\";\n  var css$a = {\n    \"label\": \"HiveLabel-module_label__2I6Uz\"\n  };\n  styleInject(css_248z$a);\n\n  var degrees = function degrees(radians) {\n    var res = radians / Math.PI * 180;\n    return res > 90 ? res + 180 : res;\n  };\n\n  var translate = function translate(d, outerRadius, padding) {\n    return d > 90 ? outerRadius + 8 + padding : -(outerRadius + padding);\n  };\n\n  var HiveLabel = function HiveLabel(_ref44) {\n    var index = _ref44.index,\n        text = _ref44.text,\n        angle = _ref44.angle,\n        outerRadius = _ref44.outerRadius,\n        label = _ref44.label;\n    var transform = react.useMemo(function () {\n      return degrees(angle(index));\n    }, [angle, index]);\n    return jsxRuntime.jsx(\"text\", Object.assign({\n      dy: translate(transform, outerRadius, label.padding),\n      className: css$a.label,\n      strokeWidth: \"0.01\",\n      textAnchor: \"middle\",\n      transform: \"rotate(\".concat(transform, \")\")\n    }, {\n      children: text\n    }), void 0);\n  };\n\n  var css_248z$9 = \".HiveTooltip-module_label__3PblP {\\n  font-size: 16px;\\n  margin-bottom: 3px;\\n}\\n\\n.HiveTooltip-module_value__326K_ {\\n  font-size: 13px;\\n  color: rgba(255, 255, 255, 0.7);\\n}\\n\";\n  var css$9 = {\n    \"label\": \"HiveTooltip-module_label__3PblP\",\n    \"value\": \"HiveTooltip-module_value__326K_\"\n  };\n  styleInject(css_248z$9);\n\n  var HiveTooltip = function HiveTooltip(_ref45) {\n    var axis = _ref45.axis,\n        nodes = _ref45.nodes,\n        node = _ref45.node;\n    var label = axis[node.x].label;\n    var count = nodes.filter(function (n) {\n      return n.value === node.value;\n    }).length;\n    return jsxRuntime.jsxs(jsxRuntime.Fragment, {\n      children: [jsxRuntime.jsxs(\"div\", Object.assign({\n        className: css$9.label\n      }, {\n        children: [label, \" - \", formatValue(node.value)]\n      }), void 0), jsxRuntime.jsxs(\"div\", Object.assign({\n        className: css$9.value\n      }, {\n        children: [formatValue(count), \" Total\"]\n      }), void 0)]\n    }, void 0);\n  };\n\n  var HivePlot = function HivePlot(_ref46) {\n    var _ref46$axis = _ref46.axis,\n        axis = _ref46$axis === void 0 ? [] : _ref46$axis,\n        _ref46$nodes = _ref46.nodes,\n        nodes = _ref46$nodes === void 0 ? [] : _ref46$nodes,\n        _ref46$links = _ref46.links,\n        links = _ref46$links === void 0 ? [] : _ref46$links,\n        _ref46$disabled = _ref46.disabled,\n        disabled = _ref46$disabled === void 0 ? false : _ref46$disabled,\n        _ref46$activeIds = _ref46.activeIds,\n        activeIds = _ref46$activeIds === void 0 ? [] : _ref46$activeIds,\n        _ref46$label = _ref46.label,\n        label = _ref46$label === void 0 ? {\n      show: true,\n      padding: 10\n    } : _ref46$label,\n        width = _ref46.width,\n        height = _ref46.height,\n        _ref46$innerRadius = _ref46.innerRadius,\n        innerRadius = _ref46$innerRadius === void 0 ? 20 : _ref46$innerRadius,\n        className = _ref46.className,\n        _ref46$onNodeClick = _ref46.onNodeClick,\n        onNodeClick = _ref46$onNodeClick === void 0 ? function () {\n      return undefined;\n    } : _ref46$onNodeClick,\n        _ref46$onNodeMouseOve = _ref46.onNodeMouseOver,\n        onNodeMouseOver = _ref46$onNodeMouseOve === void 0 ? function () {\n      return undefined;\n    } : _ref46$onNodeMouseOve,\n        _ref46$onLinkMouseOve = _ref46.onLinkMouseOver,\n        onLinkMouseOver = _ref46$onLinkMouseOve === void 0 ? function () {\n      return undefined;\n    } : _ref46$onLinkMouseOve,\n        _ref46$onNodeMouseOut = _ref46.onNodeMouseOut,\n        onNodeMouseOut = _ref46$onNodeMouseOut === void 0 ? function () {\n      return undefined;\n    } : _ref46$onNodeMouseOut,\n        _ref46$onLinkMouseOut = _ref46.onLinkMouseOut,\n        onLinkMouseOut = _ref46$onLinkMouseOut === void 0 ? function () {\n      return undefined;\n    } : _ref46$onLinkMouseOut,\n        _ref46$tooltip = _ref46.tooltip,\n        tooltip = _ref46$tooltip === void 0 ? {\n      show: true,\n      placement: 'top',\n      formatter: function formatter(attr) {\n        return attr.value;\n      }\n    } : _ref46$tooltip,\n        _ref46$colorScheme = _ref46.colorScheme,\n        colorScheme = _ref46$colorScheme === void 0 ? {\n      axis: ['#b1b2b6'],\n      domain: ['#b1b2b6']\n    } : _ref46$colorScheme;\n\n    var _react$useState35 = react.useState(null),\n        _react$useState36 = _slicedToArray(_react$useState35, 2),\n        tooltipReference = _react$useState36[0],\n        setTooltipReference = _react$useState36[1];\n\n    var _react$useState37 = react.useState(null),\n        _react$useState38 = _slicedToArray(_react$useState37, 2),\n        nodeTooltipData = _react$useState38[0],\n        setNodeTooltipData = _react$useState38[1];\n\n    var _react$useState39 = react.useState(null),\n        _react$useState40 = _slicedToArray(_react$useState39, 2),\n        linkTooltipData = _react$useState40[0],\n        setLinkTooltipData = _react$useState40[1];\n\n    var _react$useState41 = react.useState(null),\n        _react$useState42 = _slicedToArray(_react$useState41, 2),\n        active = _react$useState42[0],\n        setActive = _react$useState42[1];\n\n    var onNodeMouseOverLocal = react.useCallback(function (node, event) {\n      if (!disabled) {\n        var activeNodeIndex = nodes.indexOf(node);\n        var activeNodes = {};\n\n        var _iterator25 = _createForOfIteratorHelper(links),\n            _step25;\n\n        try {\n          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n            var link = _step25.value;\n            var source = link.source,\n                target = link.target;\n\n            if (source.value === node.value || target.value === node.value) {\n              var next = target.value === node.value ? source : target;\n              var idx = nodes.indexOf(next);\n              activeNodes[\"node-\".concat(idx)] = true;\n            }\n          }\n        } catch (err) {\n          _iterator25.e(err);\n        } finally {\n          _iterator25.f();\n        }\n\n        setTooltipReference(event.target);\n        setNodeTooltipData(node);\n        setActive(Object.assign(Object.assign(_defineProperty({}, \"node-\".concat(activeNodeIndex), true), activeNodes), links.reduce(function (accumulator, link, i) {\n          if (link.source.value === node.value || link.target.value === node.value) {\n            accumulator[\"link-\".concat(i)] = true;\n          }\n\n          return accumulator;\n        }, {})));\n      }\n\n      onNodeMouseOver({\n        nativeEvent: event,\n        node: node,\n        links: getLinksForNode(node)\n      });\n    }, [links, nodes, onNodeMouseOver, disabled]);\n    var activateAdjacentLinks = react.useCallback(function (links, target, accumulator) {\n      var activeLinks = [];\n      links.forEach(function (childLink, index) {\n        if (target === childLink.source) {\n          if (!accumulator[\"link-\".concat(index)]) {\n            accumulator[\"link-\".concat(index)] = true;\n            activeLinks.push.apply(activeLinks, [childLink].concat(_toConsumableArray(activateAdjacentLinks(links, childLink.target, accumulator))));\n          }\n        }\n      });\n      return activeLinks;\n    }, []);\n    var activateLink = react.useCallback(function (link) {\n      var activeLinkIndex = links.indexOf(link);\n\n      var activeLinksMap = _defineProperty({}, \"link-\".concat(activeLinkIndex), true);\n\n      var activeLinks = [link].concat(_toConsumableArray(activateAdjacentLinks(links, link.target, activeLinksMap)));\n      setActive(Object.assign(Object.assign({}, activeLinksMap), nodes.reduce(function (accumulator, node, i) {\n        var _iterator26 = _createForOfIteratorHelper(activeLinks),\n            _step26;\n\n        try {\n          for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n            var activeLink = _step26.value;\n            var source = activeLink.source,\n                target = activeLink.target;\n\n            if (node === source || node === target) {\n              accumulator[\"node-\".concat(i)] = true;\n            }\n          }\n        } catch (err) {\n          _iterator26.e(err);\n        } finally {\n          _iterator26.f();\n        }\n\n        return accumulator;\n      }, {})));\n    }, [nodes, links]);\n    var onLinkMouseOverLocal = react.useCallback(function (link, event) {\n      if (!disabled) {\n        setTooltipReference(event.target);\n        setLinkTooltipData(link);\n        activateLink(link);\n      }\n\n      onLinkMouseOver({\n        nativeEvent: event,\n        link: link\n      });\n    }, [onLinkMouseOver, disabled]);\n    var getLinksForNode = react.useCallback(function (node) {\n      return links.filter(function (link) {\n        return link.source.value === node.value || link.target.value === node.value;\n      });\n    }, [links]);\n    var resetActive = react.useCallback(function () {\n      setActive(null);\n      setLinkTooltipData(null);\n      setNodeTooltipData(null);\n      setTooltipReference(null);\n    }, []);\n    var onNodeMouseOutLocal = react.useCallback(function (node, event) {\n      resetActive();\n      onNodeMouseOut({\n        nativeEvent: event,\n        node: node,\n        links: getLinksForNode(node)\n      });\n    }, [onNodeMouseOut]);\n    var onLinkMouseOutLocal = react.useCallback(function (link, event) {\n      resetActive();\n      onLinkMouseOut({\n        nativeEvent: event,\n        link: link\n      });\n    }, [onLinkMouseOut]);\n    var onNodeClickLocal = react.useCallback(function (node, event) {\n      if (!disabled) {\n        onNodeClick({\n          nativeEvent: event,\n          node: node,\n          links: getLinksForNode(node)\n        });\n      }\n    }, [disabled, onNodeClick]);\n    var prepareData = react.useCallback(function (_ref47) {\n      var dimension = _ref47.dimension,\n          innerRadius = _ref47.innerRadius,\n          colorScheme = _ref47.colorScheme,\n          axis = _ref47.axis,\n          label = _ref47.label;\n      var outerRadius = dimension / 2;\n\n      if (label.show) {\n        outerRadius = outerRadius - (10 + label.padding);\n      }\n\n      return {\n        angle: d3Scale.scalePoint().domain(d3Array.range(axis.length + 1)).range([0, 2 * Math.PI]),\n        radius: d3Scale.scaleLinear().range([innerRadius, outerRadius]),\n        axisColor: d3Scale.scaleOrdinal(colorScheme.axis).domain(d3Array.range(20)),\n        domainColor: d3Scale.scaleOrdinal(colorScheme.domain).domain(d3Array.range(20)),\n        outerRadius: outerRadius\n      };\n    }, []);\n    var renderAxis = react.useCallback(function (_ref48) {\n      var angle = _ref48.angle,\n          radius = _ref48.radius,\n          axisColor = _ref48.axisColor,\n          outerRadius = _ref48.outerRadius;\n      return jsxRuntime.jsx(react.Fragment, {\n        children: axis.map(function (a, i) {\n          return jsxRuntime.jsxs(\"g\", {\n            children: [jsxRuntime.jsx(HiveAxis, {\n              angle: angle,\n              index: i,\n              color: axisColor,\n              radius: radius\n            }, void 0), label.show && jsxRuntime.jsx(HiveLabel, {\n              index: i,\n              text: a.label,\n              label: label,\n              outerRadius: outerRadius,\n              angle: angle\n            }, void 0)]\n          }, \"axis-\".concat(a.attribute));\n        })\n      }, void 0);\n    }, [axis, label]);\n    var isActive = react.useCallback(function (nodeOrLink, index, type) {\n      // If no there is nothing active, then everything is active.\n      if (!active && !activeIds.length) {\n        return true;\n      } // If this node is active because it is being hovered\n\n\n      if (active && active[\"\".concat(type, \"-\").concat(index)]) {\n        return true;\n      } // If the ID matches one of the active IDs passed in the props\n\n\n      if (!!activeIds.length && !!nodeOrLink.id && activeIds.includes(nodeOrLink.id)) {\n        return true;\n      }\n\n      return false;\n    }, [activeIds, active]);\n    var renderLinks = react.useCallback(function (_ref49) {\n      var angle = _ref49.angle,\n          radius = _ref49.radius,\n          domainColor = _ref49.domainColor;\n      return jsxRuntime.jsx(react.Fragment, {\n        children: links.map(function (link, i) {\n          return jsxRuntime.jsx(HiveLink, {\n            color: link.color || domainColor,\n            active: isActive(link, i, 'link'),\n            angle: angle,\n            radius: radius,\n            link: link,\n            onMouseOver: function onMouseOver(event) {\n              return onLinkMouseOverLocal(link, event);\n            },\n            onMouseOut: function onMouseOut(event) {\n              return onLinkMouseOutLocal(link, event);\n            }\n          }, \"\".concat(link.value, \"-\").concat(i));\n        })\n      }, void 0);\n    }, [links]);\n    var renderNodes = react.useCallback(function (_ref50) {\n      var angle = _ref50.angle,\n          radius = _ref50.radius,\n          domainColor = _ref50.domainColor;\n      return jsxRuntime.jsx(react.Fragment, {\n        children: nodes.map(function (node, i) {\n          return jsxRuntime.jsx(HiveNode, {\n            node: node,\n            active: isActive(node, i, 'node'),\n            color: domainColor,\n            radius: radius,\n            angle: angle,\n            disabled: disabled,\n            onMouseOver: function onMouseOver(event) {\n              return onNodeMouseOverLocal(node, event);\n            },\n            onMouseOut: function onMouseOut(event) {\n              return onNodeMouseOutLocal(node, event);\n            },\n            onClick: function onClick(event) {\n              return onNodeClickLocal(node, event);\n            }\n          }, \"\".concat(node.value, \"-\").concat(i));\n        })\n      }, void 0);\n    }, [nodes, disabled]);\n    var renderTooltip = react.useCallback(function () {\n      var formatter = tooltip.formatter,\n          placement = tooltip.placement,\n          show = tooltip.show;\n      return jsxRuntime.jsx(react.Fragment, {\n        children: !disabled && show && jsxRuntime.jsx(realayers.Tooltip, {\n          visible: !!active,\n          reference: tooltipReference,\n          placement: placement,\n          content: function content() {\n            return formatter(axis, nodes, linkTooltipData, nodeTooltipData) || (nodeTooltipData ? jsxRuntime.jsx(HiveTooltip, {\n              node: nodeTooltipData,\n              nodes: nodes,\n              axis: axis\n            }, void 0) : null);\n          }\n        }, void 0)\n      }, void 0);\n    }, [tooltip, disabled, axis, nodes, active, tooltipReference, linkTooltipData, nodeTooltipData]);\n    var renderChart = react.useCallback(function (_ref51) {\n      var containerHeight = _ref51.height,\n          containerWidth = _ref51.width;\n      var data = prepareData({\n        dimension: Math.min(containerHeight, containerWidth),\n        innerRadius: innerRadius,\n        colorScheme: colorScheme,\n        axis: axis,\n        label: label\n      });\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [jsxRuntime.jsx(\"svg\", Object.assign({\n          width: containerWidth,\n          height: containerHeight,\n          className: classNames__default['default'](className)\n        }, {\n          children: jsxRuntime.jsxs(\"g\", Object.assign({\n            transform: \"translate(\".concat(containerWidth / 2, \", \").concat(containerHeight / 2 + innerRadius, \")\")\n          }, {\n            children: [renderAxis(data), renderLinks(data), renderNodes(data)]\n          }), void 0)\n        }), void 0), renderTooltip()]\n      }, void 0);\n    }, [innerRadius, axis, colorScheme, label, className]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      height: height,\n      width: width\n    }, {\n      children: renderChart\n    }), void 0);\n  };\n\n  var LineSeries = function LineSeries(props) {\n    return jsxRuntime.jsx(AreaSeries, Object.assign({}, props), void 0);\n  };\n\n  LineSeries.defaultProps = Object.assign(Object.assign({}, AreaSeries.defaultProps), {\n    area: null,\n    line: jsxRuntime.jsx(Line, {\n      strokeWidth: 3\n    }, void 0)\n  });\n\n  var LineChart = function LineChart(props) {\n    return jsxRuntime.jsx(AreaChart, Object.assign({}, props), void 0);\n  };\n\n  LineChart.defaultProps = Object.assign(Object.assign({}, AreaChart.defaultProps), {\n    series: jsxRuntime.jsx(LineSeries, {}, void 0)\n  });\n\n  var Map$1 = function Map$1(_ref52) {\n    var id = _ref52.id,\n        width = _ref52.width,\n        height = _ref52.height,\n        margins = _ref52.margins,\n        className = _ref52.className,\n        containerClassName = _ref52.containerClassName,\n        markers = _ref52.markers,\n        data = _ref52.data,\n        fill = _ref52.fill;\n    var getProjection = react.useCallback(function (_ref53) {\n      var chartWidth = _ref53.chartWidth,\n          chartHeight = _ref53.chartHeight;\n      return d3Geo.geoMercator().fitSize([chartWidth, chartHeight], data).center([0, 35]);\n    }, [data]);\n    var renderMarker = react.useCallback(function (marker, index, projection) {\n      var position = projection(marker.props.coordinates);\n\n      if (!position) {\n        console.warn(\"Position for \".concat(marker.props.coordinates.toString(), \" not found.\"));\n        return null;\n      }\n\n      return jsxRuntime.jsx(rdk.CloneElement, {\n        element: marker,\n        cx: position[0],\n        cy: position[1],\n        index: index\n      }, void 0);\n    }, []);\n    var renderCountry = react.useCallback(function (point, index, path) {\n      // Exclude ATA\n      if (point.id === '010') {\n        return null;\n      }\n\n      return jsxRuntime.jsx(\"path\", {\n        d: path(point),\n        fill: fill\n      }, \"path-\".concat(index));\n    }, [fill]);\n    var renderChart = react.useCallback(function (containerProps) {\n      if (!data) {\n        return null;\n      }\n\n      var projection = getProjection(containerProps);\n      var path = d3Geo.geoPath().projection(projection);\n      return jsxRuntime.jsxs(framerMotion.motion.g, Object.assign({\n        initial: {\n          opacity: 0\n        },\n        animate: {\n          opacity: 1\n        }\n      }, {\n        children: [data.features.map(function (point, index) {\n          return renderCountry(point, index, path);\n        }), markers && markers.map(function (marker, index) {\n          return jsxRuntime.jsx(react.Fragment, {\n            children: renderMarker(marker, index, projection)\n          }, \"marker-\".concat(index));\n        })]\n      }), void 0);\n    }, [data, getProjection, markers, renderCountry, renderMarker]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      margins: margins,\n      containerClassName: containerClassName,\n      xAxisVisible: false,\n      yAxisVisible: false,\n      className: className\n    }, {\n      children: function children(props) {\n        return renderChart(props);\n      }\n    }), void 0);\n  };\n\n  Map$1.defaultProps = {\n    fill: 'rgba(255, 255, 255, 0.3)'\n  };\n  var css_248z$8 = \".MapMarker-module_marker__3uyJu {\\n  fill: var(--color-primary);\\n  cursor: pointer;\\n}\\n\";\n  var css$8 = {\n    \"marker\": \"MapMarker-module_marker__3uyJu\"\n  };\n  styleInject(css_248z$8); // Set padding modifier for the tooltips\n\n  var modifiers$1 = {\n    offset: {\n      offset: '0, 3px'\n    }\n  };\n\n  var MapMarker = function MapMarker(_ref54) {\n    var _ref54$size = _ref54.size,\n        size = _ref54$size === void 0 ? 3 : _ref54$size,\n        index = _ref54.index,\n        tooltip = _ref54.tooltip,\n        cx = _ref54.cx,\n        cy = _ref54.cy,\n        _ref54$onClick = _ref54.onClick,\n        onClick = _ref54$onClick === void 0 ? function () {\n      return undefined;\n    } : _ref54$onClick;\n    var ref = react.useRef(null);\n\n    var _react$useState43 = react.useState(false),\n        _react$useState44 = _slicedToArray(_react$useState43, 2),\n        active = _react$useState44[0],\n        setActive = _react$useState44[1];\n\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [jsxRuntime.jsx(framerMotion.motion.circle, {\n        initial: {\n          opacity: 0,\n          scale: 0.02\n        },\n        animate: {\n          opacity: 1,\n          scale: 1\n        },\n        transition: {\n          delay: index * 0.3\n        },\n        ref: ref,\n        className: css$8.marker,\n        cx: cx,\n        cy: cy,\n        r: size,\n        onMouseEnter: function onMouseEnter() {\n          return setActive(true);\n        },\n        onMouseLeave: function onMouseLeave() {\n          return setActive(false);\n        },\n        onClick: onClick\n      }, void 0), tooltip && jsxRuntime.jsx(realayers.Tooltip, {\n        visible: active,\n        reference: ref,\n        modifiers: modifiers$1,\n        content: tooltip\n      }, void 0)]\n    }, void 0);\n  };\n\n  var useInterpolate$1 = function useInterpolate$1(_ref55) {\n    var data = _ref55.data,\n        animated = _ref55.animated,\n        arc = _ref55.arc;\n    var prevEnter = react.useRef(null);\n    var exit = react.useMemo(function () {\n      var startAngle = data.startAngle;\n      var endAngle = animated ? startAngle : data.endAngle;\n      return Object.assign(Object.assign({}, data), {\n        startAngle: startAngle,\n        endAngle: endAngle\n      });\n    }, [data, animated]);\n    var transition = react.useMemo(function () {\n      return animated ? Object.assign({}, DEFAULT_TRANSITION) : {\n        delay: 0\n      };\n    }, [animated]); // Cache the previous for transition use later\n\n    var previousEnter = prevEnter.current ? Object.assign({}, prevEnter.current) : undefined;\n    prevEnter.current = Object.assign({}, data);\n    var d = framerMotion.useMotionValue('');\n    var prevPath = framerMotion.useMotionValue(exit);\n    var spring = framerMotion.useSpring(prevPath, Object.assign(Object.assign({}, DEFAULT_TRANSITION), {\n      from: 0,\n      to: 1\n    }));\n    react.useEffect(function () {\n      var from = previousEnter || prevPath.get();\n      var interpolator = d3Interpolate.interpolate(from, data);\n      var unsub = spring.onChange(function (v) {\n        return d.set(arc(interpolator(v)));\n      });\n      prevPath.set(data);\n      return unsub;\n    }, [arc, data]);\n    return {\n      d: d,\n      transition: transition\n    };\n  };\n\n  var PieArc = function PieArc(_ref56) {\n    var color = _ref56.color,\n        data = _ref56.data,\n        arc = _ref56.arc,\n        cursor = _ref56.cursor,\n        animated = _ref56.animated,\n        disabled = _ref56.disabled,\n        _onClick2 = _ref56.onClick,\n        _onMouseEnter2 = _ref56.onMouseEnter,\n        _onMouseLeave2 = _ref56.onMouseLeave,\n        tooltip = _ref56.tooltip;\n    var arcRef = react.useRef(null);\n\n    var _useInterpolate$ = useInterpolate$1({\n      animated: animated,\n      arc: arc,\n      data: data\n    }),\n        transition = _useInterpolate$.transition,\n        d = _useInterpolate$.d;\n\n    var _react$useState45 = react.useState(false),\n        _react$useState46 = _slicedToArray(_react$useState45, 2),\n        active = _react$useState46[0],\n        setActive = _react$useState46[1];\n\n    var fill = react.useMemo(function () {\n      return active ? chroma__default['default'](color).brighten(0.5) : color;\n    }, [color, active]);\n    return jsxRuntime.jsxs(\"g\", Object.assign({\n      ref: arcRef\n    }, {\n      children: [jsxRuntime.jsx(framerMotion.motion.path, {\n        role: \"graphics-symbol\",\n        transition: transition,\n        d: d,\n        style: {\n          cursor: cursor\n        },\n        fill: fill,\n        onMouseEnter: function onMouseEnter(event) {\n          if (!disabled) {\n            setActive(true);\n\n            _onMouseEnter2({\n              value: data.data,\n              nativeEvent: event\n            });\n          }\n        },\n        onMouseLeave: function onMouseLeave(event) {\n          if (!disabled) {\n            setActive(false);\n\n            _onMouseLeave2({\n              value: data.data,\n              nativeEvent: event\n            });\n          }\n        },\n        onClick: function onClick(event) {\n          if (!disabled) {\n            _onClick2({\n              value: data.data,\n              nativeEvent: event\n            });\n          }\n        }\n      }, void 0), tooltip && !tooltip.props.disabled && jsxRuntime.jsx(rdk.CloneElement, {\n        element: tooltip,\n        visible: !!active,\n        reference: arcRef,\n        value: {\n          y: data.data.data,\n          x: data.data.key\n        }\n      }, void 0)]\n    }), void 0);\n  };\n\n  PieArc.defaultProps = {\n    cursor: 'initial',\n    animated: true,\n    disabled: false,\n    onClick: function onClick() {\n      return undefined;\n    },\n    onMouseEnter: function onMouseEnter() {\n      return undefined;\n    },\n    onMouseLeave: function onMouseLeave() {\n      return undefined;\n    },\n    tooltip: jsxRuntime.jsx(ChartTooltip, {}, void 0)\n  };\n  /**\r\n   * Finds intermediate point between two points so that this three points\r\n   * can be nicely connected by two lines. One of this lines must be horizontal\r\n   */\n\n  function findBreakPoint(_ref57, _ref58) {\n    var _ref59 = _slicedToArray(_ref57, 2),\n        startX = _ref59[0],\n        startY = _ref59[1];\n\n    var _ref60 = _slicedToArray(_ref58, 2),\n        endX = _ref60[0],\n        endY = _ref60[1];\n\n    var breakPoint = [0, 0]; // whether we should create breakpoint near pie or near label\n\n    var breakPointCondition = (endY - startY) * Math.sign(startY) >= 0;\n\n    if (breakPointCondition) {\n      // extend the line starting from startY till the endY\n      var scale = Math.abs(endY / startY) || 1;\n      var minScale = 1;\n      var maxScale = Math.abs(endX / startX) || 1;\n      scale = Math.max(Math.min(maxScale, scale), minScale);\n      breakPoint = [startX * scale, endY];\n    } else {\n      // some arbitrary scale to ensure that break point will be placed\n      // at some horizontal distance from the end point\n      var _scale = 0.85;\n\n      var _minScale = Math.abs(startX / endX) || 1;\n\n      var _maxScale = 1;\n      _scale = Math.max(Math.min(_maxScale, _scale), _minScale);\n      breakPoint = [endX * _scale, startY];\n    }\n\n    return breakPoint;\n  }\n\n  var getTextAnchor = function getTextAnchor(_ref61) {\n    var startAngle = _ref61.startAngle,\n        endAngle = _ref61.endAngle;\n    return (// we could also use the sign of position[0]\n      startAngle + (endAngle - startAngle) / 2 < Math.PI ? 'start' : 'end'\n    );\n  };\n\n  var PieArcLabel = function PieArcLabel(_ref62) {\n    var centroid = _ref62.centroid,\n        data = _ref62.data,\n        lineStroke = _ref62.lineStroke,\n        padding = _ref62.padding,\n        fontSize = _ref62.fontSize,\n        fontFill = _ref62.fontFill,\n        format = _ref62.format,\n        fontFamily = _ref62.fontFamily,\n        position = _ref62.position,\n        outerRadius = _ref62.outerRadius,\n        width = _ref62.width,\n        height = _ref62.height;\n    var textAnchor = getTextAnchor(data);\n    var text = format ? format(Object.assign(Object.assign({}, data.data), {\n      textAnchor: textAnchor\n    })) : formatValue(data.data.key);\n\n    var _position = _slicedToArray(position, 2),\n        posX = _position[0],\n        posY = _position[1]; // we want to have at least some pixels of straight line (margin)\n    // from pie section till we start to change line direction\n\n\n    var minRadius = outerRadius + 4;\n    var startPoint = centroid(data);\n    var innerPoint = d3Shape.arc().innerRadius(minRadius).outerRadius(minRadius).centroid(data);\n    var breakPoint = findBreakPoint(innerPoint, position);\n    return jsxRuntime.jsxs(framerMotion.motion.g, Object.assign({\n      initial: {\n        opacity: 0\n      },\n      animate: {\n        opacity: 1\n      },\n      exit: {\n        opacity: 0\n      },\n      transition: {\n        duration: 0.1\n      }\n    }, {\n      children: [typeof text === 'string' ? jsxRuntime.jsxs(jsxRuntime.Fragment, {\n        children: [jsxRuntime.jsx(\"title\", {\n          children: text\n        }, void 0), jsxRuntime.jsx(\"text\", Object.assign({\n          dy: padding,\n          fill: fontFill,\n          fontSize: fontSize,\n          fontFamily: fontFamily,\n          textAnchor: textAnchor,\n          style: {\n            shapeRendering: 'crispEdges',\n            transform: \"translate3d(\".concat(posX, \"px,\").concat(posY, \"px, 0)\")\n          }\n        }, {\n          children: text\n        }), void 0)]\n      }, void 0) : jsxRuntime.jsx(\"foreignObject\", Object.assign({\n        width: width,\n        height: height,\n        style: {\n          transform: \"translate3d(\".concat(textAnchor === 'start' ? posX : posX - width, \"px,\").concat(posY - height / 2, \"px, 0)\"),\n          color: fontFill,\n          fontFamily: fontFamily,\n          fontSize: fontSize\n        }\n      }, {\n        children: text\n      }), void 0), jsxRuntime.jsx(\"polyline\", {\n        fill: \"none\",\n        stroke: lineStroke,\n        points: \"\".concat(startPoint, \",\").concat(innerPoint, \",\").concat(breakPoint, \",\").concat(position)\n      }, void 0)]\n    }), void 0);\n  };\n\n  PieArcLabel.defaultProps = {\n    format: undefined,\n    lineStroke: 'rgba(127,127,127,0.5)',\n    fontFill: '#8F979F',\n    fontSize: 11,\n    fontFamily: 'sans-serif',\n    padding: '.35em',\n    height: 11\n  };\n  var factor = 1.2;\n\n  var midAngle = function midAngle(d) {\n    return d.startAngle + (d.endAngle - d.startAngle) / 2;\n  };\n\n  var labelVisible = function labelVisible(arc) {\n    return arc.endAngle - arc.startAngle > Math.PI / 30;\n  };\n\n  function shouldDisplayLabel(displayAllLabels, arcData) {\n    return displayAllLabels || labelVisible(arcData);\n  }\n\n  function calculateOuterRadius(outerRadius, data, point, explode) {\n    if (!explode || data === undefined) {\n      return outerRadius;\n    }\n\n    var maxVal = d3Array.max(data, function (d) {\n      return d.value;\n    });\n    return outerRadius * point.value / maxVal;\n  }\n\n  function calculateCentroid(data, innerRadius, outerRadius, explode) {\n    return function (point) {\n      var newOuter = calculateOuterRadius(outerRadius, data, point, explode);\n      return d3Shape.arc().innerRadius(innerRadius).outerRadius(newOuter).centroid(point);\n    };\n  }\n\n  function calculateRadius(height, width, label, arcWidth, doughnut) {\n    var minDimension = Math.min(width, height);\n    var outerRadius = minDimension / 2;\n    var labelWidth = 0;\n\n    if (label) {\n      labelWidth = label.props.width;\n\n      if (labelWidth) {\n        var outerArcRadius = width / 2 - labelWidth;\n        outerRadius = Math.min(outerArcRadius / factor, height / 2);\n      } else {\n        outerRadius = minDimension / 3;\n        labelWidth = width / 2 - outerRadius * factor;\n      }\n    }\n\n    var innerRadius = doughnut ? outerRadius * (1 - arcWidth) : 0;\n    return {\n      outerRadius: outerRadius,\n      innerRadius: innerRadius,\n      labelWidth: labelWidth\n    };\n  }\n\n  function calculateInnerArc(data, innerRadius, outerRadius, cornerRadius, padAngle, padRadius, explode) {\n    return function (point) {\n      var newOuter = calculateOuterRadius(outerRadius, data, point, explode);\n      return d3Shape.arc().innerRadius(innerRadius).outerRadius(newOuter).cornerRadius(cornerRadius).padRadius(padRadius).padAngle(padAngle)(point);\n    };\n  }\n\n  function calculateLabelPositions(data, outerRadius, minDistance, cornerRadius, padAngle, padRadius, displayAllLabels) {\n    var outerArcRadius = outerRadius * factor;\n    var outerArc = d3Shape.arc().innerRadius(outerArcRadius).outerRadius(outerArcRadius).cornerRadius(cornerRadius).padAngle(padAngle).padRadius(padRadius);\n    var positions = data.map(function (d) {\n      if (!shouldDisplayLabel(displayAllLabels, d)) {\n        return null;\n      }\n\n      var pos = outerArc.centroid(d); // reposition the labels to the left/right from outerArc centroid\n      // so that all labels won't collide with pie\n      // when we will vertically reposition them\n\n      pos[0] = outerArcRadius * (midAngle(d) < Math.PI ? 1 : -1);\n      return pos;\n    });\n\n    for (var i = 0; i < data.length - 1; i++) {\n      if (!positions[i]) {\n        continue;\n      }\n\n      var _positions$i = _slicedToArray(positions[i], 2),\n          aPosX = _positions$i[0],\n          aPosY = _positions$i[1];\n\n      for (var j = i + 1; j < data.length; j++) {\n        if (!positions[j]) {\n          continue;\n        }\n\n        var _positions$j = _slicedToArray(positions[j], 2),\n            bPosX = _positions$j[0],\n            bPosY = _positions$j[1]; // if they're on the same side (both with - or + sign)\n\n\n        if (bPosX * aPosX > 0) {\n          // if they're overlapping\n          var overlap = minDistance - Math.abs(bPosY - aPosY);\n\n          if (overlap > 0) {\n            // push the second up or down\n            positions[j][1] += Math.sign(bPosX) * overlap;\n          }\n        }\n      }\n    }\n\n    return positions;\n  }\n\n  var PieArcSeries = function PieArcSeries(_ref63) {\n    var doughnut = _ref63.doughnut,\n        arcWidth = _ref63.arcWidth,\n        label = _ref63.label,\n        colorScheme = _ref63.colorScheme,\n        width = _ref63.width,\n        displayAllLabels = _ref63.displayAllLabels,\n        height = _ref63.height,\n        explode = _ref63.explode,\n        animated = _ref63.animated,\n        cornerRadius = _ref63.cornerRadius,\n        padAngle = _ref63.padAngle,\n        padRadius = _ref63.padRadius,\n        arc = _ref63.arc,\n        data = _ref63.data;\n\n    var _calculateRadius = calculateRadius(height, width, label, arcWidth, doughnut),\n        outerRadius = _calculateRadius.outerRadius,\n        innerRadius = _calculateRadius.innerRadius,\n        labelWidth = _calculateRadius.labelWidth;\n\n    var innerArc = calculateInnerArc(data, innerRadius, outerRadius, cornerRadius, padAngle, padRadius, explode);\n    var positions = label ? calculateLabelPositions(data, outerRadius, // 4 is for vertical margins between labels\n    label.props.height + 4, cornerRadius, padAngle, padRadius, displayAllLabels) : [];\n    var centroid = calculateCentroid(data, innerRadius, outerRadius, explode);\n    return jsxRuntime.jsx(react.Fragment, {\n      children: data.map(function (arcData, index) {\n        return jsxRuntime.jsxs(react.Fragment, {\n          children: [positions[index] && jsxRuntime.jsx(rdk.CloneElement, {\n            element: label,\n            data: arcData,\n            centroid: centroid,\n            outerRadius: outerRadius,\n            width: labelWidth,\n            position: positions[index]\n          }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n            element: arc,\n            data: arcData,\n            animated: animated,\n            arc: innerArc,\n            color: getColor({\n              data: data,\n              colorScheme: colorScheme,\n              point: arcData.data,\n              index: index\n            })\n          }, void 0)]\n        }, arcData.data.key.toString());\n      })\n    }, void 0);\n  };\n\n  PieArcSeries.defaultProps = {\n    animated: true,\n    colorScheme: 'cybertron',\n    innerRadius: 0,\n    cornerRadius: 0,\n    padAngle: 0,\n    padRadius: 0,\n    explode: false,\n    displayAllLabels: false,\n    arcWidth: 0.25,\n    label: jsxRuntime.jsx(PieArcLabel, {}, void 0),\n    arc: jsxRuntime.jsx(PieArc, {}, void 0)\n  };\n\n  var PieChart = function PieChart(_ref64) {\n    var id = _ref64.id,\n        width = _ref64.width,\n        height = _ref64.height,\n        className = _ref64.className,\n        containerClassName = _ref64.containerClassName,\n        displayAllLabels = _ref64.displayAllLabels,\n        _ref64$data = _ref64.data,\n        data = _ref64$data === void 0 ? [] : _ref64$data,\n        margins = _ref64.margins,\n        series = _ref64.series;\n    var getData = react.useMemo(function () {\n      var pieLayout = d3Shape.pie().value(function (d) {\n        return Number(d.data);\n      }); // Explode sort doesn't work right...\n\n      if (!series.props.explode) {\n        pieLayout.sort(null);\n      }\n\n      return pieLayout(data);\n    }, [data, series]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      margins: margins,\n      containerClassName: containerClassName,\n      xAxisVisible: false,\n      yAxisVisible: false,\n      center: true,\n      className: classNames__default['default'](className)\n    }, {\n      children: function children(_ref65) {\n        var chartWidth = _ref65.chartWidth,\n            chartHeight = _ref65.chartHeight;\n        return jsxRuntime.jsx(rdk.CloneElement, {\n          element: series,\n          data: getData,\n          height: chartHeight,\n          width: chartWidth,\n          displayAllLabels: displayAllLabels\n        }, void 0);\n      }\n    }), void 0);\n  };\n\n  PieChart.defaultProps = {\n    margins: 10,\n    series: jsxRuntime.jsx(PieArcSeries, {}, void 0)\n  };\n  var JUSTIFICATION = {\n    justify: d3Sankey.sankeyJustify,\n    center: d3Sankey.sankeyCenter,\n    left: d3Sankey.sankeyLeft,\n    right: d3Sankey.sankeyRight\n  };\n\n  var Sankey = /*#__PURE__*/function (_react$Component24) {\n    _inherits(Sankey, _react$Component24);\n\n    function Sankey() {\n      var _this15;\n\n      _classCallCheck(this, Sankey);\n\n      _this15 = _possibleConstructorReturn(this, _getPrototypeOf(Sankey).apply(this, arguments));\n      _this15.state = {\n        activeNodes: [],\n        activeLinks: []\n      };\n      return _this15;\n    }\n\n    _createClass(Sankey, [{\n      key: \"getNodeColor\",\n      value: function getNodeColor(node, index) {\n        var _this$props46 = this.props,\n            colorScheme = _this$props46.colorScheme,\n            nodes = _this$props46.nodes;\n\n        if (colorScheme) {\n          return getColor({\n            data: nodes,\n            colorScheme: colorScheme,\n            point: nodes[index],\n            index: index\n          });\n        } else {\n          return node.props.color;\n        }\n      }\n    }, {\n      key: \"onNodeActive\",\n      value: function onNodeActive(node) {\n        var activeNodes = [node];\n        var activeLinks = [];\n\n        if (node.sourceLinks) {\n          activeLinks.push.apply(activeLinks, _toConsumableArray(node.sourceLinks));\n          node.sourceLinks.forEach(function (sourceLink) {\n            var sourceLinkTarget = sourceLink.target;\n\n            if (sourceLinkTarget.index !== node.index) {\n              activeNodes.push(sourceLinkTarget);\n            }\n          });\n        }\n\n        if (node.targetLinks) {\n          activeLinks.push.apply(activeLinks, _toConsumableArray(node.targetLinks));\n          node.targetLinks.forEach(function (targetLink) {\n            var targetLinkSource = targetLink.source;\n\n            if (targetLinkSource.index !== node.index) {\n              activeNodes.push(targetLinkSource);\n            }\n          });\n        }\n\n        this.setState({\n          activeNodes: activeNodes,\n          activeLinks: activeLinks\n        });\n      }\n    }, {\n      key: \"onLinkActive\",\n      value: function onLinkActive(link) {\n        var activeNodes = [link.source, link.target];\n        var activeLinks = [link];\n        this.setState({\n          activeNodes: activeNodes,\n          activeLinks: activeLinks\n        });\n      }\n    }, {\n      key: \"onInactive\",\n      value: function onInactive() {\n        this.setState({\n          activeNodes: [],\n          activeLinks: []\n        });\n      }\n    }, {\n      key: \"renderNode\",\n      value: function renderNode(computedNode, index, chartWidth, node) {\n        var animated = this.props.animated;\n        var activeNodes = this.state.activeNodes;\n        var active = activeNodes.some(function (node) {\n          return node.index === computedNode.index;\n        });\n        var disabled = activeNodes.length > 0 && !active;\n        return jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n          element: node,\n          active: active,\n          animated: animated,\n          disabled: disabled,\n          chartWidth: chartWidth,\n          onMouseEnter: bind__default['default'](this.onNodeActive, this, computedNode),\n          onMouseLeave: bind__default['default'](this.onInactive, this, computedNode)\n        }, computedNode), \"node-\".concat(index));\n      }\n    }, {\n      key: \"renderNodes\",\n      value: function renderNodes(nodes, chartWidth) {\n        var _this16 = this;\n\n        var nodeMap = new Map();\n        this.props.nodes.forEach(function (node) {\n          return node && nodeMap.set(node.props.title, node);\n        });\n        nodes.sort(function (a, b) {\n          var aX0 = a && a.x0 ? a.x0 : 0;\n          var aY0 = a && a.y0 ? a.y0 : 0;\n          var bX0 = b && b.x0 ? b.x0 : 0;\n          var bY0 = b && b.y0 ? b.y0 : 0;\n          return aX0 - bX0 || aY0 - bY0;\n        });\n        return jsxRuntime.jsx(react.Fragment, {\n          children: nodes.map(function (node, index) {\n            return _this16.renderNode(node, index, chartWidth, nodeMap.get(node.title));\n          })\n        }, void 0);\n      }\n    }, {\n      key: \"renderLink\",\n      value: function renderLink(computedLink, index, chartId) {\n        var _this$props47 = this.props,\n            animated = _this$props47.animated,\n            links = _this$props47.links;\n        var activeLinks = this.state.activeLinks;\n        var active = activeLinks.some(function (link) {\n          return link.index === computedLink.index;\n        });\n        var disabled = activeLinks.length > 0 && !active;\n        return jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n          element: links[index],\n          active: active,\n          animated: animated,\n          chartId: chartId,\n          disabled: disabled\n        }, computedLink, {\n          onMouseEnter: bind__default['default'](this.onLinkActive, this, computedLink),\n          onMouseLeave: bind__default['default'](this.onInactive, this, computedLink)\n        }), \"link-\".concat(index));\n      }\n    }, {\n      key: \"renderChart\",\n      value: function renderChart(containerProps) {\n        var _this17 = this;\n\n        var id = containerProps.id,\n            chartWidth = containerProps.chartWidth,\n            chartHeight = containerProps.chartHeight;\n        var _this$props48 = this.props,\n            justification = _this$props48.justification,\n            nodeWidth = _this$props48.nodeWidth,\n            nodePadding = _this$props48.nodePadding;\n        var nodesCopy = this.props.nodes.map(function (node, index) {\n          return {\n            id: node.props.id,\n            title: node.props.title,\n            color: _this17.getNodeColor(node, index)\n          };\n        });\n        var linksCopy = this.props.links.map(function (link) {\n          return {\n            source: link.props.source,\n            target: link.props.target,\n            value: link.props.value\n          };\n        });\n        var sankeyChart = d3Sankey.sankey().extent([[1, 1], [chartWidth, chartHeight]]).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeAlign(JUSTIFICATION[justification]).nodeId(function (node) {\n          return node.id || node.index;\n        });\n\n        var _sankeyChart = sankeyChart({\n          nodes: nodesCopy,\n          links: linksCopy\n        }),\n            nodes = _sankeyChart.nodes,\n            links = _sankeyChart.links;\n\n        return containerProps.chartSized && jsxRuntime.jsxs(react.Fragment, {\n          children: [links.map(function (link, index) {\n            return _this17.renderLink(link, index, \"sankey-\".concat(id));\n          }), this.renderNodes(nodes, chartWidth)]\n        }, \"group\");\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this18 = this;\n\n        var _this$props49 = this.props,\n            id = _this$props49.id,\n            width = _this$props49.width,\n            height = _this$props49.height,\n            margins = _this$props49.margins,\n            className = _this$props49.className,\n            containerClassName = _this$props49.containerClassName;\n        return jsxRuntime.jsx(ChartContainer, Object.assign({\n          id: id,\n          width: width,\n          containerClassName: containerClassName,\n          height: height,\n          margins: margins,\n          className: className\n        }, {\n          children: function children(props) {\n            return _this18.renderChart(props);\n          }\n        }), void 0);\n      }\n    }]);\n\n    return Sankey;\n  }(react.Component);\n\n  Sankey.defaultProps = {\n    animated: true,\n    justification: 'justify',\n    nodeWidth: 15,\n    nodePadding: 10\n  };\n  var css_248z$7 = \".SankeyLabel-module_label__2_aSZ {\\n  font-size: 12px;\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n      -ms-user-select: none;\\n          user-select: none;\\n  pointer-events: none;\\n}\\n\";\n  var css$7 = {\n    \"label\": \"SankeyLabel-module_label__2_aSZ\"\n  };\n  styleInject(css_248z$7);\n\n  var SankeyLabel = /*#__PURE__*/function (_react$Component25) {\n    _inherits(SankeyLabel, _react$Component25);\n\n    function SankeyLabel() {\n      _classCallCheck(this, SankeyLabel);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(SankeyLabel).apply(this, arguments));\n    }\n\n    _createClass(SankeyLabel, [{\n      key: \"render\",\n      value: function render() {\n        var _this$props50 = this.props,\n            active = _this$props50.active,\n            chartWidth = _this$props50.chartWidth,\n            className = _this$props50.className,\n            fill = _this$props50.fill,\n            node = _this$props50.node,\n            opacity = _this$props50.opacity,\n            padding = _this$props50.padding,\n            visible = _this$props50.visible;\n        var nodePositions = {\n          x0: node && node.x0 ? node.x0 : 0,\n          y0: node && node.y0 ? node.y0 : 0,\n          x1: node && node.x1 ? node.x1 : 0,\n          y1: node && node.y1 ? node.y1 : 0\n        };\n        var width = chartWidth || 0;\n        var showRightSide = nodePositions.x0 < width / 2;\n        var textAnchor = showRightSide ? 'start' : 'end';\n        return visible && node && jsxRuntime.jsx(\"text\", Object.assign({\n          className: classNames__default['default'](css$7.label, className),\n          x: showRightSide ? nodePositions.x1 + 6 : nodePositions.x0 - 6,\n          y: (nodePositions.y1 + nodePositions.y0) / 2,\n          dy: \"0.35em\",\n          textAnchor: textAnchor,\n          fill: fill,\n          opacity: opacity(active),\n          style: {\n            padding: padding\n          }\n        }, {\n          children: node.title\n        }), void 0);\n      }\n    }]);\n\n    return SankeyLabel;\n  }(react.Component);\n\n  SankeyLabel.defaultProps = {\n    active: false,\n    fill: '#fff',\n    location: 'outside',\n    opacity: function opacity(active) {\n      return active ? 1 : 0.5;\n    },\n    visible: true\n  };\n  var DEFAULT_COLOR = 'rgba(255, 255, 255, 0.2)';\n  var css_248z$6 = \".SankeyLink-module_link__hzYa8 {\\n  fill: none;\\n  transition: stroke-opacity 100ms ease-in-out, stroke 100ms ease-in-out;\\n  mix-blend-mode: screen;\\n}\\n\\n.SankeyLink-module_tooltip__28O9b {\\n  text-align: center;\\n  pointer-events: none;\\n}\\n\\n.SankeyLink-module_tooltip__28O9b .SankeyLink-module_tooltipLabel__odxY7 {\\n    font-size: 16px;\\n    margin-bottom: 3px;\\n    color: rgba(255, 255, 255, 1);\\n    text-align: center;\\n  }\\n\\n.SankeyLink-module_tooltip__28O9b .SankeyLink-module_tooltipValue__cTGcv {\\n    font-size: 13px;\\n    color: rgba(255, 255, 255, 0.7);\\n    text-align: center;\\n  }\\n\";\n  var css$6 = {\n    \"link\": \"SankeyLink-module_link__hzYa8\",\n    \"tooltip\": \"SankeyLink-module_tooltip__28O9b\",\n    \"tooltipLabel\": \"SankeyLink-module_tooltipLabel__odxY7\",\n    \"tooltipValue\": \"SankeyLink-module_tooltipValue__cTGcv\"\n  };\n  styleInject(css_248z$6);\n\n  var SankeyLink = /*#__PURE__*/function (_react$Component26) {\n    _inherits(SankeyLink, _react$Component26);\n\n    function SankeyLink() {\n      var _this19;\n\n      _classCallCheck(this, SankeyLink);\n\n      _this19 = _possibleConstructorReturn(this, _getPrototypeOf(SankeyLink).apply(this, arguments));\n      _this19.link = react.createRef();\n      _this19.state = {};\n      return _this19;\n    }\n\n    _createClass(SankeyLink, [{\n      key: \"getEnter\",\n      value: function getEnter() {\n        var path = d3Sankey.sankeyLinkHorizontal();\n        var d = path(this.getLink());\n        var strokeWidth = Math.max(1, this.props.width);\n        return {\n          d: d,\n          strokeWidth: strokeWidth\n        };\n      }\n    }, {\n      key: \"getExit\",\n      value: function getExit() {\n        var path = d3Sankey.sankeyLinkHorizontal();\n        var d = path(Object.assign(Object.assign({}, this.getLink()), {\n          width: 0\n        }));\n        return {\n          d: d,\n          strokeWidth: 0\n        };\n      }\n    }, {\n      key: \"getLink\",\n      value: function getLink() {\n        var _this$props51 = this.props,\n            index = _this$props51.index,\n            value = _this$props51.value,\n            y0 = _this$props51.y0,\n            y1 = _this$props51.y1,\n            source = _this$props51.source,\n            target = _this$props51.target,\n            width = _this$props51.width;\n        return {\n          index: index,\n          y0: y0,\n          y1: y1,\n          value: value,\n          width: width,\n          source: source,\n          target: target\n        };\n      }\n    }, {\n      key: \"getStroke\",\n      value: function getStroke() {\n        var _this$props52 = this.props,\n            color = _this$props52.color,\n            index = _this$props52.index,\n            gradient = _this$props52.gradient,\n            chartId = _this$props52.chartId;\n        return gradient ? \"url(#\".concat(chartId, \"-gradient-\").concat(index, \")\") : color;\n      }\n    }, {\n      key: \"onMouseEnter\",\n      value: function onMouseEnter(event) {\n        this.setState({\n          hovered: true\n        });\n        this.props.onMouseEnter(event);\n      }\n    }, {\n      key: \"onMouseLeave\",\n      value: function onMouseLeave(event) {\n        this.setState({\n          hovered: false\n        });\n        this.props.onMouseLeave(event);\n      }\n    }, {\n      key: \"renderLink\",\n      value: function renderLink() {\n        var _this$props53 = this.props,\n            active = _this$props53.active,\n            className = _this$props53.className,\n            disabled = _this$props53.disabled,\n            index = _this$props53.index,\n            opacity = _this$props53.opacity,\n            style = _this$props53.style,\n            onClick = _this$props53.onClick;\n        var enterProps = this.getEnter();\n        var exitProps = this.getExit();\n        return jsxRuntime.jsx(\"g\", Object.assign({\n          ref: this.link\n        }, {\n          children: jsxRuntime.jsx(framerMotion.motion.path, {\n            className: classNames__default['default'](css$6.link, className),\n            style: style,\n            initial: exitProps,\n            animate: enterProps,\n            exit: exitProps,\n            transition: {\n              duration: 0.5\n            },\n            stroke: this.getStroke(),\n            strokeOpacity: opacity(active, disabled),\n            onClick: onClick,\n            onMouseEnter: bind__default['default'](this.onMouseEnter, this),\n            onMouseLeave: bind__default['default'](this.onMouseLeave, this)\n          }, \"sankey-link-\".concat(enterProps.d, \"-\").concat(index))\n        }), void 0);\n      }\n    }, {\n      key: \"renderTooltipContent\",\n      value: function renderTooltipContent() {\n        var _this$props54 = this.props,\n            source = _this$props54.source,\n            target = _this$props54.target,\n            value = _this$props54.value;\n        return jsxRuntime.jsxs(\"div\", Object.assign({\n          className: css$6.tooltip\n        }, {\n          children: [jsxRuntime.jsx(\"div\", Object.assign({\n            className: css$6.tooltipLabel\n          }, {\n            children: \"\".concat(source.title, \" \\u2192 \").concat(target.title)\n          }), void 0), jsxRuntime.jsx(\"div\", Object.assign({\n            className: css$6.tooltipValue\n          }, {\n            children: formatValue(value)\n          }), void 0)]\n        }), void 0);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props55 = this.props,\n            gradient = _this$props55.gradient,\n            index = _this$props55.index,\n            source = _this$props55.source,\n            target = _this$props55.target,\n            tooltip = _this$props55.tooltip,\n            chartId = _this$props55.chartId;\n        var linkSource = source;\n        var linkTarget = target;\n        return jsxRuntime.jsxs(react.Fragment, {\n          children: [gradient && jsxRuntime.jsxs(\"linearGradient\", Object.assign({\n            id: \"\".concat(chartId, \"-gradient-\").concat(index),\n            gradientUnits: \"userSpaceOnUse\",\n            x1: linkSource.x1,\n            x2: linkTarget.x0\n          }, {\n            children: [jsxRuntime.jsx(\"stop\", {\n              offset: \"0%\",\n              stopColor: linkSource.color\n            }, void 0), jsxRuntime.jsx(\"stop\", {\n              offset: \"100%\",\n              stopColor: linkTarget.color\n            }, void 0)]\n          }), void 0), this.renderLink(), !tooltip.props.disabled && jsxRuntime.jsx(rdk.CloneElement, {\n            content: this.renderTooltipContent.bind(this),\n            element: tooltip,\n            visible: this.state.hovered,\n            reference: this.link\n          }, void 0)]\n        }, void 0);\n      }\n    }]);\n\n    return SankeyLink;\n  }(react.Component);\n\n  SankeyLink.defaultProps = {\n    active: false,\n    animated: true,\n    color: DEFAULT_COLOR,\n    disabled: false,\n    gradient: true,\n    opacity: function opacity(active, disabled) {\n      return active ? 0.5 : disabled ? 0.1 : 0.35;\n    },\n    tooltip: jsxRuntime.jsx(realayers.Tooltip, {\n      followCursor: true,\n      modifiers: {\n        offset: {\n          offset: '0, 5px'\n        }\n      }\n    }, void 0),\n    width: 0,\n    onClick: function onClick() {\n      return undefined;\n    },\n    onMouseEnter: function onMouseEnter() {\n      return undefined;\n    },\n    onMouseLeave: function onMouseLeave() {\n      return undefined;\n    }\n  };\n  var css_248z$5 = \".SankeyNode-module_node__1rkj0 {\\n  transition: opacity 100ms ease-in-out, fill-opacity 100ms ease-in-out;\\n}\\n\\n.SankeyNode-module_tooltip__1SZ4e {\\n  text-align: center;\\n  padding: 0 8px;\\n  pointer-events: none;\\n}\\n\\n.SankeyNode-module_tooltip__1SZ4e .SankeyNode-module_tooltipLabel__HfJ93 {\\n    font-size: 16px;\\n    margin-bottom: 3px;\\n    color: rgba(255, 255, 255, 1);\\n    text-align: center;\\n  }\\n\\n.SankeyNode-module_tooltip__1SZ4e .SankeyNode-module_tooltipValue__lnd_m {\\n    font-size: 13px;\\n    color: rgba(255, 255, 255, 0.7);\\n    text-align: center;\\n  }\\n\";\n  var css$5 = {\n    \"node\": \"SankeyNode-module_node__1rkj0\",\n    \"tooltip\": \"SankeyNode-module_tooltip__1SZ4e\",\n    \"tooltipLabel\": \"SankeyNode-module_tooltipLabel__HfJ93\",\n    \"tooltipValue\": \"SankeyNode-module_tooltipValue__lnd_m\"\n  };\n  styleInject(css_248z$5);\n\n  var SankeyNode = /*#__PURE__*/function (_react$Component27) {\n    _inherits(SankeyNode, _react$Component27);\n\n    function SankeyNode() {\n      var _this20;\n\n      _classCallCheck(this, SankeyNode);\n\n      _this20 = _possibleConstructorReturn(this, _getPrototypeOf(SankeyNode).apply(this, arguments));\n      _this20.state = {};\n      _this20.rect = react.createRef();\n      return _this20;\n    }\n\n    _createClass(SankeyNode, [{\n      key: \"getNode\",\n      value: function getNode() {\n        var _this$props56 = this.props,\n            id = _this$props56.id,\n            title = _this$props56.title,\n            color = _this$props56.color,\n            sourceLinks = _this$props56.sourceLinks,\n            targetLinks = _this$props56.targetLinks,\n            value = _this$props56.value,\n            index = _this$props56.index,\n            x0 = _this$props56.x0,\n            x1 = _this$props56.x1,\n            y0 = _this$props56.y0,\n            y1 = _this$props56.y1;\n        return {\n          id: id,\n          title: title,\n          color: color,\n          sourceLinks: sourceLinks,\n          targetLinks: targetLinks,\n          value: value,\n          index: index,\n          x0: x0,\n          x1: x1,\n          y0: y0,\n          y1: y1\n        };\n      }\n    }, {\n      key: \"onMouseEnter\",\n      value: function onMouseEnter(event) {\n        this.setState({\n          hovered: true\n        });\n        this.props.onMouseEnter(event);\n      }\n    }, {\n      key: \"onMouseLeave\",\n      value: function onMouseLeave(event) {\n        this.setState({\n          hovered: false\n        });\n        this.props.onMouseLeave(event);\n      }\n    }, {\n      key: \"renderNode\",\n      value: function renderNode() {\n        var _this$props57 = this.props,\n            active = _this$props57.active,\n            className = _this$props57.className,\n            color = _this$props57.color,\n            disabled = _this$props57.disabled,\n            index = _this$props57.index,\n            opacity = _this$props57.opacity,\n            style = _this$props57.style,\n            width = _this$props57.width,\n            x0 = _this$props57.x0,\n            x1 = _this$props57.x1,\n            y0 = _this$props57.y0,\n            y1 = _this$props57.y1,\n            onClick = _this$props57.onClick;\n        var nodeWidth = width || (x1 && x0 && x1 - x0 > 0 ? x1 - x0 : 0);\n        var nodeHeight = y1 && y0 && y1 - y0 > 0 ? y1 - y0 : 0;\n        return jsxRuntime.jsx(framerMotion.motion.g, Object.assign({\n          ref: this.rect\n        }, {\n          children: jsxRuntime.jsx(framerMotion.motion.rect, {\n            className: classNames__default['default'](css$5.node, className),\n            fillOpacity: opacity(active, disabled),\n            style: style,\n            width: nodeWidth,\n            height: nodeHeight,\n            fill: color,\n            initial: {\n              opacity: 0,\n              attrX: x0,\n              attrY: y0\n            },\n            animate: {\n              opacity: 1,\n              attrX: x0,\n              attrY: y0\n            },\n            exit: {\n              opacity: 0,\n              attrX: x0,\n              attrY: y0\n            },\n            transition: {\n              duration: 0.1\n            },\n            onClick: onClick,\n            onMouseEnter: bind__default['default'](this.onMouseEnter, this),\n            onMouseLeave: bind__default['default'](this.onMouseLeave, this)\n          }, \"sankey-node-\".concat(x0, \"-\").concat(x1, \"-\").concat(y0, \"-\").concat(y1, \"-\").concat(index))\n        }), void 0);\n      }\n    }, {\n      key: \"renderTooltipContent\",\n      value: function renderTooltipContent() {\n        var _this$props58 = this.props,\n            title = _this$props58.title,\n            value = _this$props58.value;\n        return jsxRuntime.jsxs(\"div\", Object.assign({\n          className: css$5.tooltip\n        }, {\n          children: [jsxRuntime.jsx(\"div\", Object.assign({\n            className: css$5.tooltipLabel\n          }, {\n            children: title\n          }), void 0), jsxRuntime.jsx(\"div\", Object.assign({\n            className: css$5.tooltipValue\n          }, {\n            children: formatValue(value)\n          }), void 0)]\n        }), void 0);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props59 = this.props,\n            active = _this$props59.active,\n            chartWidth = _this$props59.chartWidth,\n            label = _this$props59.label,\n            tooltip = _this$props59.tooltip,\n            showLabel = _this$props59.showLabel;\n        return jsxRuntime.jsxs(react.Fragment, {\n          children: [this.renderNode(), showLabel && jsxRuntime.jsx(rdk.CloneElement, {\n            active: active,\n            element: label,\n            chartWidth: chartWidth,\n            node: this.getNode()\n          }, void 0), !tooltip.props.disabled && jsxRuntime.jsx(rdk.CloneElement, {\n            content: this.renderTooltipContent.bind(this),\n            element: tooltip,\n            visible: this.state.hovered,\n            reference: this.rect\n          }, void 0)]\n        }, void 0);\n      }\n    }]);\n\n    return SankeyNode;\n  }(react.Component);\n\n  SankeyNode.defaultProps = {\n    active: false,\n    animated: true,\n    color: DEFAULT_COLOR,\n    disabled: false,\n    label: jsxRuntime.jsx(SankeyLabel, {}, void 0),\n    opacity: function opacity(active, disabled) {\n      return active ? 1 : disabled ? 0.2 : 0.9;\n    },\n    showLabel: true,\n    tooltip: jsxRuntime.jsx(realayers.Tooltip, {\n      followCursor: true,\n      modifiers: {\n        offset: {\n          offset: '0, 5px'\n        }\n      }\n    }, void 0),\n    onClick: function onClick() {\n      return undefined;\n    },\n    onMouseEnter: function onMouseEnter() {\n      return undefined;\n    },\n    onMouseLeave: function onMouseLeave() {\n      return undefined;\n    }\n  };\n\n  var SparklineChart = function SparklineChart(props) {\n    return jsxRuntime.jsx(LineChart, Object.assign({}, props), void 0);\n  };\n\n  SparklineChart.defaultProps = {\n    gridlines: null,\n    series: jsxRuntime.jsx(AreaSeries, {\n      symbols: jsxRuntime.jsx(PointSeries, {\n        show: \"hover\"\n      }, void 0),\n      interpolation: \"smooth\",\n      markLine: null,\n      area: null,\n      line: jsxRuntime.jsx(Line, {\n        strokeWidth: 2\n      }, void 0)\n    }, void 0),\n    yAxis: jsxRuntime.jsx(LinearYAxis, {\n      scaled: true,\n      type: \"value\",\n      axisLine: null,\n      tickSeries: jsxRuntime.jsx(LinearYAxisTickSeries, {\n        line: null,\n        label: null\n      }, void 0)\n    }, void 0),\n    xAxis: jsxRuntime.jsx(LinearXAxis, {\n      type: \"time\",\n      scaled: true,\n      axisLine: null,\n      tickSeries: jsxRuntime.jsx(LinearXAxisTickSeries, {\n        line: null,\n        label: null\n      }, void 0)\n    }, void 0)\n  };\n\n  var AreaSparklineChart = function AreaSparklineChart(props) {\n    return jsxRuntime.jsx(AreaChart, Object.assign({}, props), void 0);\n  };\n\n  AreaSparklineChart.defaultProps = {\n    gridlines: null,\n    series: jsxRuntime.jsx(AreaSeries, {\n      symbols: jsxRuntime.jsx(PointSeries, {\n        show: \"hover\"\n      }, void 0),\n      interpolation: \"smooth\",\n      markLine: null,\n      area: jsxRuntime.jsx(Area, {\n        mask: jsxRuntime.jsx(Stripes, {}, void 0),\n        gradient: jsxRuntime.jsx(Gradient, {\n          stops: [jsxRuntime.jsx(GradientStop, {\n            offset: \"10%\",\n            stopOpacity: 0\n          }, \"start\"), jsxRuntime.jsx(GradientStop, {\n            offset: \"80%\",\n            stopOpacity: 1\n          }, \"stop\")]\n        }, void 0)\n      }, void 0),\n      line: jsxRuntime.jsx(Line, {\n        strokeWidth: 3\n      }, void 0)\n    }, void 0),\n    yAxis: jsxRuntime.jsx(LinearYAxis, {\n      type: \"value\",\n      scaled: true,\n      axisLine: null,\n      tickSeries: jsxRuntime.jsx(LinearYAxisTickSeries, {\n        line: null,\n        label: null\n      }, void 0)\n    }, void 0),\n    xAxis: jsxRuntime.jsx(LinearXAxis, {\n      type: \"time\",\n      scaled: true,\n      axisLine: null,\n      tickSeries: jsxRuntime.jsx(LinearXAxisTickSeries, {\n        line: null,\n        label: null\n      }, void 0)\n    }, void 0)\n  };\n\n  var BarSparklineChart = function BarSparklineChart(props) {\n    return jsxRuntime.jsx(BarChart, Object.assign({}, props), void 0);\n  };\n\n  BarSparklineChart.defaultProps = {\n    gridlines: null,\n    series: jsxRuntime.jsx(BarSeries, {\n      colorScheme: schemes.cybertron[0]\n    }, void 0),\n    yAxis: jsxRuntime.jsx(LinearYAxis, {\n      type: \"value\",\n      axisLine: null,\n      tickSeries: jsxRuntime.jsx(LinearYAxisTickSeries, {\n        line: null,\n        label: null\n      }, void 0)\n    }, void 0),\n    xAxis: jsxRuntime.jsx(LinearXAxis, {\n      type: \"category\",\n      axisLine: null,\n      tickSeries: jsxRuntime.jsx(LinearXAxisTickSeries, {\n        line: null,\n        label: null\n      }, void 0)\n    }, void 0)\n  };\n\n  var SonarChart = function SonarChart(props) {\n    return jsxRuntime.jsx(StackedBarChart, Object.assign({}, props, {\n      margins: 0,\n      gridlines: null,\n      series: jsxRuntime.jsx(StackedBarSeries, {\n        type: \"stackedDiverging\",\n        colorScheme: \"rgb(17, 207, 247)\",\n        tooltip: jsxRuntime.jsx(TooltipArea, {\n          tooltip: jsxRuntime.jsx(ChartTooltip, {\n            followCursor: true,\n            modifiers: {\n              offset: '5px, 5px'\n            },\n            content: function content(data, color) {\n              return jsxRuntime.jsx(TooltipTemplate, {\n                color: color,\n                value: {\n                  x: formatValue(data.x),\n                  y: \"\".concat(formatValue(Math.abs(data.data[0].y)))\n                }\n              }, void 0);\n            }\n          }, void 0)\n        }, void 0),\n        bar: [jsxRuntime.jsx(Bar, {\n          width: 1,\n          rangeLines: null,\n          minHeight: 1,\n          gradient: jsxRuntime.jsx(Gradient, {\n            stops: [jsxRuntime.jsx(GradientStop, {\n              offset: \"5%\",\n              stopOpacity: 0.7\n            }, \"start\"), jsxRuntime.jsx(GradientStop, {\n              offset: \"90%\",\n              stopOpacity: 1\n            }, \"stop\")]\n          }, void 0)\n        }, \"first\"), jsxRuntime.jsx(Bar, {\n          width: 1,\n          rangeLines: null,\n          minHeight: 1,\n          gradient: jsxRuntime.jsx(Gradient, {\n            stops: [jsxRuntime.jsx(GradientStop, {\n              offset: \"5%\",\n              stopOpacity: 1\n            }, \"stop\"), jsxRuntime.jsx(GradientStop, {\n              offset: \"90%\",\n              stopOpacity: 0.7\n            }, \"start\")]\n          }, void 0)\n        }, \"second\")]\n      }, void 0),\n      yAxis: jsxRuntime.jsx(LinearYAxis, {\n        type: \"value\",\n        axisLine: null,\n        tickSeries: jsxRuntime.jsx(LinearYAxisTickSeries, {\n          line: null,\n          label: null\n        }, void 0)\n      }, void 0),\n      xAxis: jsxRuntime.jsx(LinearXAxis, {\n        type: \"category\",\n        axisLine: null,\n        tickSeries: jsxRuntime.jsx(LinearXAxisTickSeries, {\n          line: null,\n          label: null\n        }, void 0)\n      }, void 0)\n    }), void 0);\n  };\n\n  var RadialArea = function RadialArea(_ref66) {\n    var id = _ref66.id,\n        data = _ref66.data,\n        className = _ref66.className,\n        yScale = _ref66.yScale,\n        color = _ref66.color,\n        animated = _ref66.animated,\n        outerRadius = _ref66.outerRadius,\n        xScale = _ref66.xScale,\n        innerRadius = _ref66.innerRadius,\n        interpolation = _ref66.interpolation,\n        gradient = _ref66.gradient;\n    var transition = react.useMemo(function () {\n      return animated ? Object.assign({}, DEFAULT_TRANSITION) : {\n        type: false,\n        delay: 0\n      };\n    }, [animated]);\n    var getFill = react.useCallback(function (c) {\n      if (!gradient) {\n        return c;\n      }\n\n      return \"url(#\".concat(id, \"-gradient)\");\n    }, [id, gradient]);\n    var getPath = react.useCallback(function (d) {\n      var curve = interpolation === 'smooth' ? d3Shape.curveCardinalClosed : d3Shape.curveLinearClosed;\n      var radialFn = d3Shape.radialArea().angle(function (dd) {\n        return xScale(dd.x);\n      }).innerRadius(function (_) {\n        return innerRadius;\n      }).outerRadius(function (d) {\n        return yScale(d.y);\n      }).curve(curve);\n      return radialFn(d);\n    }, [xScale, yScale, interpolation, innerRadius]);\n    var enter = react.useMemo(function () {\n      return {\n        d: getPath(data),\n        opacity: 1\n      };\n    }, [data, getPath]);\n    var exit = react.useMemo(function () {\n      var _yScale$domain3 = yScale.domain(),\n          _yScale$domain4 = _slicedToArray(_yScale$domain3, 1),\n          yStart = _yScale$domain4[0];\n\n      return {\n        d: getPath(data.map(function (d) {\n          return Object.assign(Object.assign({}, d), {\n            y: yStart\n          });\n        })),\n        opacity: 0\n      };\n    }, [data, getPath, yScale]);\n    var fill = color(data, 0);\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [jsxRuntime.jsx(MotionPath, {\n        custom: {\n          enter: enter,\n          exit: exit\n        },\n        transition: transition,\n        pointerEvents: \"none\",\n        className: className,\n        fill: getFill(color)\n      }, void 0), gradient && jsxRuntime.jsx(rdk.CloneElement, {\n        element: gradient,\n        id: \"\".concat(id, \"-gradient\"),\n        radius: outerRadius,\n        color: fill\n      }, void 0)]\n    }, void 0);\n  };\n\n  RadialArea.defaultProps = {\n    gradient: jsxRuntime.jsx(RadialGradient, {}, void 0)\n  };\n\n  var RadialLine = function RadialLine(_ref67) {\n    var xScale = _ref67.xScale,\n        yScale = _ref67.yScale,\n        className = _ref67.className,\n        color = _ref67.color,\n        data = _ref67.data,\n        interpolation = _ref67.interpolation,\n        strokeWidth = _ref67.strokeWidth,\n        animated = _ref67.animated;\n    var getPath = react.useCallback(function (preData) {\n      var curve = interpolation === 'smooth' ? d3Shape.curveCardinalClosed : d3Shape.curveLinearClosed;\n      var radialFn = d3Shape.radialLine().angle(function (d) {\n        return xScale(d.x);\n      }).radius(function (d) {\n        return yScale(d.y);\n      }).curve(curve);\n      return radialFn(preData);\n    }, [xScale, yScale, interpolation]);\n    var transition = react.useMemo(function () {\n      return animated ? Object.assign({}, DEFAULT_TRANSITION) : {\n        type: false,\n        delay: 0\n      };\n    }, [animated]);\n    var fill = color(data, 0);\n    var enter = react.useMemo(function () {\n      return {\n        d: getPath(data),\n        opacity: 1\n      };\n    }, [data, getPath]);\n    var exit = react.useMemo(function () {\n      var _yScale$domain5 = yScale.domain(),\n          _yScale$domain6 = _slicedToArray(_yScale$domain5, 1),\n          yStart = _yScale$domain6[0];\n\n      return {\n        d: getPath(data.map(function (d) {\n          return Object.assign(Object.assign({}, d), {\n            y: yStart\n          });\n        })),\n        opacity: 0\n      };\n    }, [data, yScale, getPath]);\n    return jsxRuntime.jsx(MotionPath, {\n      custom: {\n        enter: enter,\n        exit: exit\n      },\n      transition: transition,\n      className: className,\n      pointerEvents: \"none\",\n      stroke: fill,\n      fill: \"none\",\n      strokeWidth: strokeWidth\n    }, void 0);\n  };\n\n  RadialLine.defaultProps = {\n    strokeWidth: 2,\n    animated: true\n  };\n\n  var RadialScatterPlot = function RadialScatterPlot(_ref68) {\n    var id = _ref68.id,\n        width = _ref68.width,\n        height = _ref68.height,\n        margins = _ref68.margins,\n        className = _ref68.className,\n        containerClassName = _ref68.containerClassName,\n        innerRadius = _ref68.innerRadius,\n        series = _ref68.series,\n        axis = _ref68.axis,\n        data = _ref68.data;\n    var getScales = react.useCallback(function (aggregatedData, outer, inner) {\n      var yDomain = getYDomain({\n        data: aggregatedData,\n        scaled: false\n      });\n      var xDomain = getXDomain({\n        data: aggregatedData\n      });\n      var xScale = d3Scale.scaleTime().range([0, 2 * Math.PI]).domain(xDomain);\n      var yScale = getRadialYScale(inner, outer, yDomain);\n      return {\n        yScale: yScale,\n        xScale: xScale\n      };\n    }, []);\n    var renderChart = react.useCallback(function (containerProps) {\n      var chartWidth = containerProps.chartWidth,\n          chartHeight = containerProps.chartHeight,\n          id = containerProps.id;\n      var outerRadius = Math.min(chartWidth, chartHeight) / 2;\n      var aggregatedData = buildShallowChartData(data);\n\n      var _getScales3 = getScales(aggregatedData, outerRadius, innerRadius),\n          yScale = _getScales3.yScale,\n          xScale = _getScales3.xScale;\n\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [axis && jsxRuntime.jsx(rdk.CloneElement, {\n          element: axis,\n          xScale: xScale,\n          height: chartHeight,\n          width: chartWidth,\n          innerRadius: innerRadius\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: series,\n          id: id,\n          data: aggregatedData,\n          xScale: xScale,\n          yScale: yScale\n        }, void 0)]\n      }, void 0);\n    }, [data, getScales, innerRadius, series, axis]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      containerClassName: containerClassName,\n      width: width,\n      height: height,\n      margins: margins,\n      xAxisVisible: false,\n      yAxisVisible: false,\n      center: true,\n      className: className\n    }, {\n      children: renderChart\n    }), void 0);\n  };\n\n  var css_248z$4 = \".RadialScatterPoint-module_inactive__1RkCR {\\n  opacity: 0.4;\\n  transition: opacity 200ms ease-in-out;\\n}\\n\";\n  var css$4 = {\n    \"inactive\": \"RadialScatterPoint-module_inactive__1RkCR\"\n  };\n  styleInject(css_248z$4);\n\n  var RadialScatterPoint = function RadialScatterPoint(_a) {\n    var size = _a.size,\n        data = _a.data,\n        color = _a.color,\n        index = _a.index,\n        symbol = _a.symbol,\n        active = _a.active,\n        tooltip = _a.tooltip,\n        yScale = _a.yScale,\n        xScale = _a.xScale,\n        animated = _a.animated,\n        className = _a.className,\n        rest = __rest(_a, [\"size\", \"data\", \"color\", \"index\", \"symbol\", \"active\", \"tooltip\", \"yScale\", \"xScale\", \"animated\", \"className\"]);\n\n    var ref = react.useRef(null);\n\n    var _react$useState47 = react.useState(false),\n        _react$useState48 = _slicedToArray(_react$useState47, 2),\n        hovered = _react$useState48[0],\n        setHovered = _react$useState48[1];\n\n    function onMouseEnter(event) {\n      setHovered(true);\n      rest.onMouseEnter({\n        value: data,\n        nativeEvent: event\n      });\n    }\n\n    function onMouseLeave(event) {\n      setHovered(false);\n      rest.onMouseLeave({\n        value: data,\n        nativeEvent: event\n      });\n    }\n\n    function onClick(event) {\n      rest.onClick({\n        value: data,\n        nativeEvent: event\n      });\n    }\n\n    function getTranslate(data) {\n      var fn = d3Shape.radialLine().radius(function (d) {\n        return yScale(d.y);\n      }).angle(function (d) {\n        return xScale(d.x);\n      }); // Parse the generated path to get point coordinates\n      // Ref: https://bit.ly/2CnZcPl\n\n      var path = fn([data]);\n\n      if (path) {\n        var _path$slice$slice$spl = path.slice(1).slice(0, -1).split(','),\n            _path$slice$slice$spl2 = _slicedToArray(_path$slice$slice$spl, 2),\n            translateX = _path$slice$slice$spl2[0],\n            translateY = _path$slice$slice$spl2[1];\n\n        return {\n          translateX: parseFloat(translateX),\n          translateY: parseFloat(translateY)\n        };\n      }\n    }\n\n    function getTransition() {\n      if (animated) {\n        return Object.assign(Object.assign({}, DEFAULT_TRANSITION), {\n          delay: index * 0.005\n        });\n      } else {\n        return {\n          type: false,\n          delay: 0\n        };\n      }\n    }\n\n    var fill = typeof color === 'function' ? color(data, index) : color;\n    var transform = getTranslate(data);\n    var sizeVal = typeof size === 'function' ? size(data) : size;\n    var transition = getTransition();\n\n    var _yScale$domain7 = yScale.domain(),\n        _yScale$domain8 = _slicedToArray(_yScale$domain7, 1),\n        yStart = _yScale$domain8[0];\n\n    var exitTransform = getTranslate(Object.assign(Object.assign({}, data), {\n      y: yStart\n    }));\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [jsxRuntime.jsxs(framerMotion.motion.g, Object.assign({\n        initial: Object.assign(Object.assign({}, exitTransform), {\n          opacity: 0\n        }),\n        animate: Object.assign(Object.assign({}, transform), {\n          opacity: 1\n        }),\n        exit: Object.assign(Object.assign({}, exitTransform), {\n          opacity: 0\n        }),\n        transition: transition,\n        ref: ref,\n        onMouseEnter: onMouseEnter,\n        onMouseLeave: onMouseLeave,\n        onClick: onClick,\n        className: classNames__default['default'](className, _defineProperty({}, css$4.inactive, !active))\n      }, {\n        children: [symbol && symbol(data), !symbol && jsxRuntime.jsx(\"circle\", {\n          r: sizeVal,\n          fill: fill\n        }, void 0)]\n      }), void 0), tooltip && jsxRuntime.jsx(rdk.CloneElement, {\n        element: tooltip,\n        visible: hovered,\n        reference: ref,\n        value: data\n      }, void 0)]\n    }, void 0);\n  };\n\n  RadialScatterPoint.defaultProps = {\n    size: 3,\n    color: schemes.cybertron[0],\n    tooltip: jsxRuntime.jsx(ChartTooltip, {}, void 0),\n    active: true,\n    onClick: function onClick() {\n      return undefined;\n    },\n    onMouseEnter: function onMouseEnter() {\n      return undefined;\n    },\n    onMouseLeave: function onMouseLeave() {\n      return undefined;\n    }\n  };\n\n  var RadialScatterSeries = function RadialScatterSeries(_ref69) {\n    var data = _ref69.data,\n        point = _ref69.point,\n        xScale = _ref69.xScale,\n        yScale = _ref69.yScale,\n        animated = _ref69.animated,\n        activeIds = _ref69.activeIds;\n\n    var _react$useState49 = react.useState(activeIds),\n        _react$useState50 = _slicedToArray(_react$useState49, 2),\n        internalActiveIds = _react$useState50[0],\n        setInternalActiveIds = _react$useState50[1];\n\n    react.useEffect(function () {\n      setInternalActiveIds(activeIds || []);\n    }, [activeIds]);\n    var onMouseEnter = react.useCallback(function (_ref70) {\n      var value = _ref70.value;\n\n      // Only perform this on unmanaged activations\n      if (!activeIds) {\n        setInternalActiveIds([value.id]);\n      }\n    }, []);\n    var onMouseLeave = react.useCallback(function () {\n      // Only perform this on unmanaged activations\n      if (!activeIds) {\n        setInternalActiveIds([]);\n      }\n    }, []);\n    var renderPoint = react.useCallback(function (d, index) {\n      var dataId;\n\n      if (d.id) {\n        dataId = d.id;\n      } else {\n        console.warn('No \\'id\\' property provided for scatter point; provide one via \\'id\\'.');\n      }\n\n      var key = dataId || index;\n      var active = !(internalActiveIds && internalActiveIds.length) || internalActiveIds.includes(dataId);\n      var visible = point.props.visible;\n\n      if (visible && !visible(d, index)) {\n        return jsxRuntime.jsx(react.Fragment, {}, key);\n      }\n\n      return jsxRuntime.jsx(rdk.CloneElement, {\n        element: point,\n        data: d,\n        index: index,\n        active: active,\n        xScale: xScale,\n        yScale: yScale,\n        animated: animated,\n        onMouseEnter: onMouseEnter,\n        onMouseLeave: onMouseLeave\n      }, key);\n    }, [point, internalActiveIds, xScale, yScale, animated, onMouseEnter, onMouseLeave]);\n    return jsxRuntime.jsx(react.Fragment, {\n      children: data.map(renderPoint)\n    }, void 0);\n  };\n\n  RadialScatterSeries.defaultProps = {\n    point: jsxRuntime.jsx(RadialScatterPoint, {}, void 0),\n    animated: true\n  };\n\n  var RadialPointSeries = function RadialPointSeries(_ref71) {\n    var data = _ref71.data,\n        xScale = _ref71.xScale,\n        yScale = _ref71.yScale,\n        animated = _ref71.animated,\n        color = _ref71.color,\n        activeValues = _ref71.activeValues,\n        show = _ref71.show,\n        point = _ref71.point;\n    var isVisible = react.useCallback(function (point, index) {\n      var isActive = activeValues && point && isEqual__default['default'](activeValues.x, point.x);\n\n      if (show === 'hover') {\n        return isActive;\n      } else if (show === 'first') {\n        if (activeValues) {\n          return isActive;\n        } else {\n          return index === 0;\n        }\n      } else if (show === 'last') {\n        if (activeValues) {\n          return isActive;\n        } else {\n          return index === data.length - 1;\n        }\n      }\n\n      return show;\n    }, [data, activeValues, show]);\n    return jsxRuntime.jsx(RadialScatterSeries, {\n      animated: animated,\n      data: data,\n      xScale: xScale,\n      yScale: yScale,\n      point: jsxRuntime.jsx(rdk.CloneElement, {\n        element: point,\n        color: color,\n        tooltip: null,\n        visible: isVisible\n      }, void 0)\n    }, void 0);\n  };\n\n  RadialPointSeries.defaultProps = {\n    show: 'hover',\n    point: jsxRuntime.jsx(RadialScatterPoint, {}, void 0)\n  };\n\n  var RadialAreaSeries = function RadialAreaSeries(_ref72) {\n    var area = _ref72.area,\n        line = _ref72.line,\n        symbols = _ref72.symbols,\n        tooltip = _ref72.tooltip,\n        xScale = _ref72.xScale,\n        yScale = _ref72.yScale,\n        data = _ref72.data,\n        id = _ref72.id,\n        animated = _ref72.animated,\n        width = _ref72.width,\n        height = _ref72.height,\n        innerRadius = _ref72.innerRadius,\n        outerRadius = _ref72.outerRadius,\n        colorScheme = _ref72.colorScheme,\n        interpolation = _ref72.interpolation;\n\n    var _react$useState51 = react.useState(null),\n        _react$useState52 = _slicedToArray(_react$useState51, 2),\n        activeValues = _react$useState52[0],\n        setActiveValues = _react$useState52[1];\n\n    var getColorForPoint = react.useCallback(function (point, index) {\n      return getColor({\n        colorScheme: colorScheme,\n        data: data,\n        index: index,\n        point: point\n      });\n    }, [colorScheme, data]);\n    var renderArea = react.useCallback(function () {\n      return jsxRuntime.jsx(rdk.CloneElement, {\n        element: area,\n        id: \"\".concat(id, \"-radial-area\"),\n        xScale: xScale,\n        yScale: yScale,\n        animated: animated,\n        color: getColorForPoint,\n        data: data,\n        interpolation: interpolation,\n        outerRadius: outerRadius,\n        innerRadius: innerRadius\n      }, void 0);\n    }, [animated, area, data, getColorForPoint, id, innerRadius, interpolation, outerRadius, xScale, yScale]);\n    var renderLine = react.useCallback(function () {\n      return jsxRuntime.jsx(rdk.CloneElement, {\n        element: line,\n        xScale: xScale,\n        yScale: yScale,\n        animated: animated,\n        interpolation: interpolation,\n        color: getColorForPoint,\n        data: data\n      }, void 0);\n    }, [animated, data, getColorForPoint, interpolation, line, xScale, yScale]);\n    var renderSymbols = react.useCallback(function () {\n      // Animations are only valid for Area\n      var activeSymbols = symbols && symbols.props.activeValues || activeValues;\n      var isAnimated = area !== undefined && animated && !activeSymbols;\n      return jsxRuntime.jsx(rdk.CloneElement, {\n        element: symbols,\n        activeValues: activeValues,\n        xScale: xScale,\n        yScale: yScale,\n        data: data,\n        animated: isAnimated,\n        color: getColorForPoint\n      }, void 0);\n    }, [activeValues, animated, area, data, getColorForPoint, symbols, xScale, yScale]);\n    return jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n      element: tooltip,\n      xScale: xScale,\n      yScale: yScale,\n      data: data,\n      height: height,\n      width: width,\n      isRadial: true,\n      innerRadius: innerRadius,\n      outerRadius: outerRadius,\n      color: getColorForPoint,\n      onValueEnter: function onValueEnter(event) {\n        return setActiveValues(event.value);\n      },\n      onValueLeave: function onValueLeave() {\n        return setActiveValues(null);\n      }\n    }, {\n      children: jsxRuntime.jsxs(\"g\", Object.assign({\n        clipPath: \"url(#\".concat(id, \"-path)\")\n      }, {\n        children: [area && renderArea(), line && renderLine(), symbols && renderSymbols()]\n      }), void 0)\n    }), void 0);\n  };\n\n  RadialAreaSeries.defaultProps = {\n    colorScheme: schemes.cybertron[0],\n    interpolation: 'smooth',\n    animated: true,\n    area: jsxRuntime.jsx(RadialArea, {}, void 0),\n    line: jsxRuntime.jsx(RadialLine, {}, void 0),\n    symbols: jsxRuntime.jsx(RadialPointSeries, {}, void 0),\n    tooltip: jsxRuntime.jsx(TooltipArea, {}, void 0)\n  };\n\n  var RadialAreaChart = function RadialAreaChart(_ref73) {\n    var id = _ref73.id,\n        width = _ref73.width,\n        height = _ref73.height,\n        className = _ref73.className,\n        data = _ref73.data,\n        containerClassName = _ref73.containerClassName,\n        innerRadius = _ref73.innerRadius,\n        series = _ref73.series,\n        axis = _ref73.axis,\n        margins = _ref73.margins;\n    var getScales = react.useCallback(function (preData, outerRadius, innerRadius) {\n      var d = buildShallowChartData(preData);\n      var yDomain = getYDomain({\n        data: d,\n        scaled: false\n      });\n      var xScale;\n\n      if ((axis === null || axis === void 0 ? void 0 : axis.props.type) === 'category') {\n        var xDomain = uniqueBy(d, function (dd) {\n          return dd.x;\n        });\n        xScale = d3Scale.scaleBand().range([0, 2 * Math.PI]).domain(xDomain);\n      } else {\n        var _xDomain = getXDomain({\n          data: d\n        });\n\n        xScale = d3Scale.scaleTime().range([0, 2 * Math.PI]).domain(_xDomain);\n      }\n\n      var yScale = getRadialYScale(innerRadius, outerRadius, yDomain);\n      return {\n        yScale: yScale,\n        xScale: xScale,\n        result: d\n      };\n    }, [axis === null || axis === void 0 ? void 0 : axis.props.type]);\n    var renderChart = react.useCallback(function (containerProps) {\n      var chartWidth = containerProps.chartWidth,\n          chartHeight = containerProps.chartHeight,\n          id = containerProps.id;\n      var outerRadius = Math.min(chartWidth, chartHeight) / 2;\n\n      var _getScales4 = getScales(data, outerRadius, innerRadius),\n          yScale = _getScales4.yScale,\n          xScale = _getScales4.xScale,\n          result = _getScales4.result;\n\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [axis && jsxRuntime.jsx(rdk.CloneElement, {\n          element: axis,\n          xScale: xScale,\n          height: chartHeight,\n          width: chartWidth,\n          innerRadius: innerRadius\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: series,\n          id: id,\n          data: result,\n          xScale: xScale,\n          yScale: yScale,\n          height: chartHeight,\n          width: chartWidth,\n          outerRadius: outerRadius,\n          innerRadius: innerRadius\n        }, void 0)]\n      }, void 0);\n    }, [getScales, data, innerRadius, axis, series]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      containerClassName: containerClassName,\n      margins: margins,\n      xAxisVisible: false,\n      yAxisVisible: false,\n      center: true,\n      className: className\n    }, {\n      children: renderChart\n    }), void 0);\n  };\n\n  RadialAreaChart.defaultProps = {\n    innerRadius: 0.1,\n    series: jsxRuntime.jsx(RadialAreaSeries, {}, void 0),\n    axis: jsxRuntime.jsx(RadialAxis, {}, void 0),\n    margins: 75\n  };\n  var pi = Math.PI,\n      tau = 2 * pi,\n      epsilon = 1e-6,\n      tauEpsilon = tau - epsilon;\n\n  function Path() {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n\n    this._ = \"\";\n  }\n\n  function path() {\n    return new Path();\n  }\n\n  Path.prototype = path.prototype = {\n    constructor: Path,\n    moveTo: function moveTo(x, y) {\n      this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y);\n    },\n    closePath: function closePath() {\n      if (this._x1 !== null) {\n        this._x1 = this._x0, this._y1 = this._y0;\n        this._ += \"Z\";\n      }\n    },\n    lineTo: function lineTo(x, y) {\n      this._ += \"L\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n    },\n    quadraticCurveTo: function quadraticCurveTo(x1, y1, x, y) {\n      this._ += \"Q\" + +x1 + \",\" + +y1 + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n    },\n    bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {\n      this._ += \"C\" + +x1 + \",\" + +y1 + \",\" + +x2 + \",\" + +y2 + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n    },\n    arcTo: function arcTo(x1, y1, x2, y2, r) {\n      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n      var x0 = this._x1,\n          y0 = this._y1,\n          x21 = x2 - x1,\n          y21 = y2 - y1,\n          x01 = x0 - x1,\n          y01 = y0 - y1,\n          l01_2 = x01 * x01 + y01 * y01; // Is the radius negative? Error.\n\n      if (r < 0) throw new Error(\"negative radius: \" + r); // Is this path empty? Move to (x1,y1).\n\n      if (this._x1 === null) {\n        this._ += \"M\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n      } // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n      else if (!(l01_2 > epsilon)) ; // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n      // Equivalently, is (x1,y1) coincident with (x2,y2)?\n      // Or, is the radius zero? Line to (x1,y1).\n      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n        this._ += \"L\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n      } // Otherwise, draw an arc!\n      else {\n        var x20 = x2 - x0,\n            y20 = y2 - y0,\n            l21_2 = x21 * x21 + y21 * y21,\n            l20_2 = x20 * x20 + y20 * y20,\n            l21 = Math.sqrt(l21_2),\n            l01 = Math.sqrt(l01_2),\n            l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n            t01 = l / l01,\n            t21 = l / l21; // If the start tangent is not coincident with (x0,y0), line to.\n\n        if (Math.abs(t01 - 1) > epsilon) {\n          this._ += \"L\" + (x1 + t01 * x01) + \",\" + (y1 + t01 * y01);\n        }\n\n        this._ += \"A\" + r + \",\" + r + \",0,0,\" + +(y01 * x20 > x01 * y20) + \",\" + (this._x1 = x1 + t21 * x21) + \",\" + (this._y1 = y1 + t21 * y21);\n      }\n    },\n    arc: function arc(x, y, r, a0, a1, ccw) {\n      x = +x, y = +y, r = +r, ccw = !!ccw;\n      var dx = r * Math.cos(a0),\n          dy = r * Math.sin(a0),\n          x0 = x + dx,\n          y0 = y + dy,\n          cw = 1 ^ ccw,\n          da = ccw ? a0 - a1 : a1 - a0; // Is the radius negative? Error.\n\n      if (r < 0) throw new Error(\"negative radius: \" + r); // Is this path empty? Move to (x0,y0).\n\n      if (this._x1 === null) {\n        this._ += \"M\" + x0 + \",\" + y0;\n      } // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n      else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n        this._ += \"L\" + x0 + \",\" + y0;\n      } // Is this arc empty? We’re done.\n\n\n      if (!r) return; // Does the angle go the wrong way? Flip the direction.\n\n      if (da < 0) da = da % tau + tau; // Is this a complete circle? Draw two arcs to complete the circle.\n\n      if (da > tauEpsilon) {\n        this._ += \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (x - dx) + \",\" + (y - dy) + \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (this._x1 = x0) + \",\" + (this._y1 = y0);\n      } // Is this arc non-empty? Draw an arc!\n      else if (da > epsilon) {\n        this._ += \"A\" + r + \",\" + r + \",0,\" + +(da >= pi) + \",\" + cw + \",\" + (this._x1 = x + r * Math.cos(a1)) + \",\" + (this._y1 = y + r * Math.sin(a1));\n      }\n    },\n    rect: function rect(x, y, w, h) {\n      this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y) + \"h\" + +w + \"v\" + +h + \"h\" + -w + \"Z\";\n    },\n    toString: function toString() {\n      return this._;\n    }\n  };\n\n  var MotionBar = function MotionBar(_a) {\n    var custom = _a.custom,\n        transition = _a.transition,\n        arc = _a.arc,\n        rest = __rest(_a, [\"custom\", \"transition\", \"arc\"]);\n\n    var d = framerMotion.useMotionValue('');\n    var prevPath = framerMotion.useMotionValue(custom.exit);\n    var spring = framerMotion.useSpring(prevPath, Object.assign(Object.assign({}, DEFAULT_TRANSITION), {\n      from: 0,\n      to: 1\n    }));\n    react.useEffect(function () {\n      var from = custom.previousEnter ? custom.previousEnter.y : prevPath.get().y;\n      var interpolator = d3Interpolate.interpolate(from, custom.enter.y);\n      var unsub = spring.onChange(function (v) {\n        return d.set(arc(Object.assign(Object.assign({}, custom.enter), {\n          y: interpolator(v)\n        })));\n      });\n      prevPath.set(custom.enter);\n      return unsub;\n    });\n\n    var _b = custom.enter,\n        enterD = _b.d,\n        enterRest = __rest(_b, [\"d\"]);\n\n    var _c = custom.exit,\n        exitRest = __rest(_c, [\"d\"]);\n\n    return jsxRuntime.jsx(framerMotion.motion.path, Object.assign({}, rest, {\n      initial: exitRest,\n      exit: exitRest,\n      animate: enterRest,\n      transition: transition,\n      d: transition.type !== false ? d : enterD\n    }), void 0);\n  };\n\n  var RadialGuideBar = function RadialGuideBar(_ref74) {\n    var active = _ref74.active,\n        path = _ref74.path,\n        _ref74$fill = _ref74.fill,\n        fill = _ref74$fill === void 0 ? '#eee' : _ref74$fill,\n        _ref74$opacity = _ref74.opacity,\n        opacity = _ref74$opacity === void 0 ? 0.2 : _ref74$opacity;\n    return jsxRuntime.jsx(framerMotion.motion.path, {\n      d: path,\n      fill: fill,\n      pointerEvents: \"none\",\n      initial: \"hidden\",\n      animate: active ? 'visible' : 'hidden',\n      variants: {\n        hidden: {\n          opacity: 0\n        },\n        visible: {\n          opacity: opacity\n        }\n      }\n    }, void 0);\n  };\n\n  RadialGuideBar.defaultProps = {\n    fill: '#eee',\n    opacity: 0.2\n  };\n\n  var RadialBar = function RadialBar(_ref75) {\n    var animated = _ref75.animated,\n        innerRadius = _ref75.innerRadius,\n        xScale = _ref75.xScale,\n        yScale = _ref75.yScale,\n        curved = _ref75.curved,\n        id = _ref75.id,\n        gradient = _ref75.gradient,\n        barCount = _ref75.barCount,\n        className = _ref75.className,\n        data = _ref75.data,\n        active = _ref75.active,\n        guide = _ref75.guide,\n        index = _ref75.index,\n        color = _ref75.color,\n        _onClick3 = _ref75.onClick,\n        _onMouseEnter3 = _ref75.onMouseEnter,\n        _onMouseLeave3 = _ref75.onMouseLeave;\n    var previousEnter = react.useRef(null);\n    var fill = color(data, index);\n    var currentColorShade = active ? chroma__default['default'](fill).brighten(0.5) : fill;\n    var transition = react.useMemo(function () {\n      // const { animated, barCount, index } = this.props;\n      if (animated) {\n        return Object.assign(Object.assign({}, DEFAULT_TRANSITION), {\n          delay: index / barCount * 0.5\n        });\n      } else {\n        return {\n          type: false,\n          delay: 0\n        };\n      }\n    }, [animated, barCount, index]);\n    var getFill = react.useCallback(function (color) {\n      if (!gradient) {\n        return color;\n      }\n\n      return \"url(#\".concat(id, \"-gradient)\");\n    }, [gradient, id]);\n    var getArc = react.useCallback(function (data) {\n      var outerRadius = yScale(data.y);\n\n      if (curved) {\n        var startAngle = xScale(data.x);\n        var endAngle = startAngle + xScale.bandwidth();\n        var arcFn = d3Shape.arc().innerRadius(innerRadius).outerRadius(outerRadius).startAngle(startAngle).endAngle(endAngle).padAngle(0.01).padRadius(innerRadius);\n        return arcFn(data);\n      } else {\n        var _startAngle = xScale(data.x) - Math.PI * 0.5;\n\n        var _endAngle = _startAngle + xScale.bandwidth();\n\n        var innerAngleDistance = _endAngle - _startAngle;\n        var arcLength = innerRadius * innerAngleDistance;\n        var outerAngleDistance = arcLength / outerRadius;\n        var halfAngleDistanceDelta = (innerAngleDistance - outerAngleDistance) / 2;\n        var pathFn = path();\n        pathFn.arc(0, 0, innerRadius, _startAngle, _endAngle);\n        pathFn.arc(0, 0, outerRadius, _endAngle - halfAngleDistanceDelta, _startAngle + halfAngleDistanceDelta, true);\n        return pathFn.toString();\n      }\n    }, [curved, innerRadius, xScale, yScale]);\n    var renderBar = react.useCallback(function (color) {\n      var fill = getFill(color); // Track previous props\n\n      var prev = previousEnter.current ? Object.assign({}, previousEnter.current) : undefined;\n      previousEnter.current = Object.assign({}, data);\n\n      var _yScale$domain9 = yScale.domain(),\n          _yScale$domain10 = _slicedToArray(_yScale$domain9, 2),\n          yStart = _yScale$domain10[0],\n          yEnd = _yScale$domain10[1];\n\n      var exit = Object.assign(Object.assign({}, data), {\n        y: yStart\n      });\n      var guidePath = getArc(Object.assign(Object.assign({}, data), {\n        y: yEnd\n      }));\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [guide && jsxRuntime.jsx(rdk.CloneElement, {\n          element: guide,\n          active: active,\n          path: guidePath\n        }, void 0), jsxRuntime.jsx(MotionBar, {\n          arc: getArc,\n          custom: {\n            enter: data,\n            exit: exit,\n            previousEnter: prev\n          },\n          transition: transition,\n          fill: fill,\n          className: className,\n          onMouseEnter: function onMouseEnter(event) {\n            return _onMouseEnter3({\n              value: data,\n              nativeEvent: event\n            });\n          },\n          onMouseLeave: function onMouseLeave(event) {\n            return _onMouseLeave3({\n              value: data,\n              nativeEvent: event\n            });\n          },\n          onClick: function onClick(event) {\n            return _onClick3({\n              value: data,\n              nativeEvent: event\n            });\n          }\n        }, void 0)]\n      }, void 0);\n    }, [active, className, data, getArc, getFill, guide, _onClick3, _onMouseEnter3, _onMouseLeave3, transition, yScale]);\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [renderBar(currentColorShade), gradient && jsxRuntime.jsx(Gradient, {\n        id: \"\".concat(id, \"-gradient\"),\n        color: currentColorShade\n      }, void 0)]\n    }, void 0);\n  };\n\n  RadialBar.defaultProps = {\n    gradient: true,\n    curved: false,\n    guide: jsxRuntime.jsx(RadialGuideBar, {}, void 0),\n    onClick: function onClick() {\n      return undefined;\n    },\n    onMouseEnter: function onMouseEnter() {\n      return undefined;\n    },\n    onMouseLeave: function onMouseLeave() {\n      return undefined;\n    }\n  };\n\n  var RadialBarSeries = function RadialBarSeries(_ref76) {\n    var data = _ref76.data,\n        id = _ref76.id,\n        innerRadius = _ref76.innerRadius,\n        outerRadius = _ref76.outerRadius,\n        xScale = _ref76.xScale,\n        yScale = _ref76.yScale,\n        height = _ref76.height,\n        width = _ref76.width,\n        tooltip = _ref76.tooltip,\n        colorScheme = _ref76.colorScheme,\n        bar = _ref76.bar,\n        animated = _ref76.animated;\n\n    var _react$useState53 = react.useState(null),\n        _react$useState54 = _slicedToArray(_react$useState53, 2),\n        activeValues = _react$useState54[0],\n        setActiveValues = _react$useState54[1];\n\n    var renderBar = react.useCallback(function (point, index) {\n      var active = activeValues && data && isEqual__default['default'](activeValues.x, point.x);\n      return jsxRuntime.jsx(react.Fragment, {\n        children: jsxRuntime.jsx(rdk.CloneElement, {\n          element: bar,\n          id: \"radialbar-\".concat(id, \"-\").concat(index),\n          index: index,\n          data: point,\n          xScale: xScale,\n          active: active,\n          yScale: yScale,\n          innerRadius: innerRadius,\n          color: function color(point) {\n            return getColor({\n              data: data,\n              point: point,\n              index: 0,\n              colorScheme: colorScheme\n            });\n          },\n          barCount: data.length,\n          animated: animated\n        }, void 0)\n      }, index);\n    }, [activeValues, animated, bar, colorScheme, data, id, innerRadius, xScale, yScale]);\n    return jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n      element: tooltip,\n      xScale: xScale,\n      yScale: yScale,\n      data: data,\n      height: height,\n      width: width,\n      isRadial: true,\n      innerRadius: innerRadius,\n      outerRadius: outerRadius,\n      onValueEnter: function onValueEnter(event) {\n        return setActiveValues(event.value);\n      },\n      onValueLeave: function onValueLeave() {\n        return setActiveValues(null);\n      },\n      color: function color(point, index) {\n        return getColor({\n          data: data,\n          point: point,\n          index: index,\n          colorScheme: colorScheme\n        });\n      }\n    }, {\n      children: jsxRuntime.jsx(\"g\", Object.assign({\n        clipPath: \"url(#\".concat(id, \"-path)\")\n      }, {\n        children: data.map(renderBar)\n      }), void 0)\n    }), void 0);\n  };\n\n  RadialBarSeries.defaultProps = {\n    colorScheme: schemes.cybertron[0],\n    tooltip: jsxRuntime.jsx(TooltipArea, {\n      tooltip: jsxRuntime.jsx(ChartTooltip, {\n        followCursor: true\n      }, void 0)\n    }, void 0),\n    bar: jsxRuntime.jsx(RadialBar, {}, void 0),\n    animated: true\n  };\n\n  var RadialBarChart = function RadialBarChart(_ref77) {\n    var id = _ref77.id,\n        width = _ref77.width,\n        height = _ref77.height,\n        margins = _ref77.margins,\n        className = _ref77.className,\n        containerClassName = _ref77.containerClassName,\n        data = _ref77.data,\n        innerRadius = _ref77.innerRadius,\n        series = _ref77.series,\n        axis = _ref77.axis;\n    var getScales = react.useCallback(function (preData, innerRadius, outerRadius) {\n      var newData = buildShallowChartData(preData);\n      var xDomain = uniqueBy(newData, function (d) {\n        return d.x;\n      });\n      var yDomain = getYDomain({\n        data: newData,\n        scaled: false\n      });\n      var xScale = d3Scale.scaleBand().range([0, 2 * Math.PI]).domain(xDomain);\n      var yScale = getRadialYScale(innerRadius, outerRadius, yDomain);\n      return {\n        xScale: xScale,\n        yScale: yScale,\n        newData: newData\n      };\n    }, []);\n    var renderChart = react.useCallback(function (_ref78) {\n      var chartWidth = _ref78.chartWidth,\n          chartHeight = _ref78.chartHeight,\n          id = _ref78.id;\n      var outerRadius = Math.min(chartWidth, chartHeight) / 2;\n\n      var _getScales5 = getScales(data, innerRadius, outerRadius),\n          yScale = _getScales5.yScale,\n          xScale = _getScales5.xScale,\n          newData = _getScales5.newData;\n\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [axis && jsxRuntime.jsx(rdk.CloneElement, {\n          element: axis,\n          xScale: xScale,\n          height: chartHeight,\n          width: chartWidth,\n          innerRadius: innerRadius\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: series,\n          id: id,\n          data: newData,\n          height: chartHeight,\n          width: chartWidth,\n          xScale: xScale,\n          yScale: yScale,\n          innerRadius: innerRadius,\n          outerRadius: outerRadius\n        }, void 0)]\n      }, void 0);\n    }, [axis, data, getScales, innerRadius, series]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      margins: margins,\n      xAxisVisible: false,\n      yAxisVisible: false,\n      center: true,\n      className: className,\n      containerClassName: containerClassName\n    }, {\n      children: renderChart\n    }), void 0);\n  };\n\n  RadialBarChart.defaultProps = {\n    innerRadius: 0.1,\n    margins: 75,\n    axis: jsxRuntime.jsx(RadialAxis, {}, void 0),\n    series: jsxRuntime.jsx(RadialBarSeries, {}, void 0)\n  };\n\n  var RadialGaugeArc = function RadialGaugeArc(_ref79) {\n    var data = _ref79.data,\n        startAngle = _ref79.startAngle,\n        endAngle = _ref79.endAngle,\n        innerRadius = _ref79.innerRadius,\n        outerRadius = _ref79.outerRadius,\n        cornerRadius = _ref79.cornerRadius,\n        padAngle = _ref79.padAngle,\n        color = _ref79.color,\n        animated = _ref79.animated,\n        disabled = _ref79.disabled,\n        fill = _ref79.fill,\n        onClick = _ref79.onClick,\n        onMouseEnter = _ref79.onMouseEnter,\n        onMouseLeave = _ref79.onMouseLeave,\n        tooltip = _ref79.tooltip;\n\n    /**\r\n     * This function will generate the arcs\r\n     * https://github.com/d3/d3-shape#arcs\r\n     */\n    var arcGenerator = react.useMemo(function () {\n      return d3Shape.arc().innerRadius(innerRadius).outerRadius(outerRadius).cornerRadius(cornerRadius);\n    }, [innerRadius, outerRadius, cornerRadius]);\n    var arcData = {\n      // @ts-ignore Data must be passed\n      data: data || {},\n      startAngle: startAngle,\n      endAngle: endAngle,\n      padAngle: padAngle\n    };\n    return jsxRuntime.jsxs(\"g\", {\n      children: [fill && jsxRuntime.jsx(\"circle\", {\n        fill: fill,\n        r: outerRadius\n      }, void 0), jsxRuntime.jsx(PieArc, {\n        arc: arcGenerator,\n        data: arcData,\n        animated: animated,\n        color: color,\n        disabled: disabled,\n        tooltip: tooltip,\n        onClick: onClick,\n        onMouseEnter: onMouseEnter,\n        onMouseLeave: onMouseLeave\n      }, void 0)]\n    }, void 0);\n  };\n\n  RadialGaugeArc.defaultProps = {\n    cornerRadius: 0,\n    padAngle: 0,\n    padRadius: 0,\n    color: '#353d44',\n    animated: true,\n    disabled: false,\n    onClick: function onClick() {\n      return undefined;\n    },\n    onMouseEnter: function onMouseEnter() {\n      return undefined;\n    },\n    onMouseLeave: function onMouseLeave() {\n      return undefined;\n    },\n    tooltip: jsxRuntime.jsx(ChartTooltip, {}, void 0)\n  };\n  var css_248z$3 = \".RadialGaugeLabel-module_valueLabel__1WLmV {\\n  font-size: 14px;\\n  font-weight: 400;\\n  fill: var(--color-on-background);\\n  opacity: 0.6;\\n}\\n\";\n  var css$3 = {\n    \"valueLabel\": \"RadialGaugeLabel-module_valueLabel__1WLmV\"\n  };\n  styleInject(css_248z$3);\n\n  var RadialGaugeLabel = function RadialGaugeLabel(_ref80) {\n    var data = _ref80.data,\n        className = _ref80.className,\n        offset = _ref80.offset,\n        _ref80$onClick = _ref80.onClick,\n        _onClick4 = _ref80$onClick === void 0 ? function () {\n      return undefined;\n    } : _ref80$onClick;\n\n    var label = formatValue(data.key);\n    return jsxRuntime.jsx(\"text\", Object.assign({\n      x: \"0\",\n      y: offset,\n      textAnchor: \"middle\",\n      // This is only valid when placed below the chart\n      alignmentBaseline: 'text-after-edge',\n      onClick: function onClick(nativeEvent) {\n        return _onClick4({\n          data: data,\n          nativeEvent: nativeEvent\n        });\n      },\n      className: classNames__default['default'](className, css$3.valueLabel)\n    }, {\n      children: label\n    }), void 0);\n  };\n\n  var css_248z$2 = \".RadialGaugeValueLabel-module_valueLabel__2IASh {\\n  font-size: 18px;\\n  font-weight: 400;\\n  fill: var(--color-on-background);\\n}\\n\";\n  var css$2 = {\n    \"valueLabel\": \"RadialGaugeValueLabel-module_valueLabel__2IASh\"\n  };\n  styleInject(css_248z$2);\n\n  var RadialGaugeValueLabel = function RadialGaugeValueLabel(_ref81) {\n    var data = _ref81.data,\n        className = _ref81.className;\n    var ref = useCount({\n      to: data.data\n    });\n    return jsxRuntime.jsx(\"text\", {\n      dy: \"-0.5em\",\n      x: \"0\",\n      y: \"15\",\n      textAnchor: \"middle\",\n      className: classNames__default['default'](className, css$2.valueLabel),\n      ref: ref\n    }, void 0);\n  };\n\n  var RadialGaugeOuterArc = function RadialGaugeOuterArc(props) {\n    return jsxRuntime.jsx(RadialGaugeArc, Object.assign({}, props), void 0);\n  };\n\n  RadialGaugeOuterArc.defaultProps = {\n    animated: false,\n    disabled: true\n  };\n\n  var RadialGaugeSeries = function RadialGaugeSeries(_a) {\n    var data = _a.data,\n        scale = _a.scale,\n        startAngle = _a.startAngle,\n        endAngle = _a.endAngle,\n        arcWidth = _a.arcWidth,\n        outerArc = _a.outerArc,\n        innerArc = _a.innerArc,\n        label = _a.label,\n        valueLabel = _a.valueLabel,\n        colorScheme = _a.colorScheme,\n        padding = _a.padding,\n        minGaugeWidth = _a.minGaugeWidth,\n        props = __rest(_a, [\"data\", \"scale\", \"startAngle\", \"endAngle\", \"arcWidth\", \"outerArc\", \"innerArc\", \"label\", \"valueLabel\", \"colorScheme\", \"padding\", \"minGaugeWidth\"]);\n\n    var _react$useMemo5 = react.useMemo(function () {\n      var rows = 1;\n      var columns = data.length;\n\n      if (props.width / data.length < minGaugeWidth) {\n        while (props.width / columns < minGaugeWidth) {\n          rows += 1;\n          columns = Math.ceil(data.length / rows);\n        }\n      }\n\n      var xScale = d3Scale.scaleBand();\n      xScale.domain(d3Array.range(columns));\n      xScale.rangeRound([0, props.width], 0.1);\n      var yScale = d3Scale.scaleBand();\n      yScale.domain(d3Array.range(rows));\n      yScale.rangeRound([0, props.height], 0.1);\n      return {\n        columns: columns,\n        xScale: xScale,\n        yScale: yScale,\n        width: xScale.bandwidth(),\n        height: yScale.bandwidth()\n      };\n    }, [data.length, minGaugeWidth, props.height, props.width]),\n        columns = _react$useMemo5.columns,\n        width = _react$useMemo5.width,\n        height = _react$useMemo5.height,\n        xScale = _react$useMemo5.xScale,\n        yScale = _react$useMemo5.yScale;\n\n    var renderGauge = react.useCallback(function (point, index) {\n      var dataEndAngle = scale(point.data);\n      var outerRadius = d3Array.min([width - padding * 2, height - padding * 2]) / 2;\n      var innerRadius = outerRadius - arcWidth;\n      var labelOffset = height / 2;\n      var x = xScale(index % columns);\n      var y = yScale(Math.floor(index / columns));\n      var xOffset = x + width / 2;\n      var yOffset = y + height / 2;\n      return jsxRuntime.jsxs(\"g\", Object.assign({\n        transform: \"translate(\".concat(xOffset, \", \").concat(yOffset, \")\")\n      }, {\n        children: [outerArc && react.cloneElement(outerArc, {\n          outerRadius: outerRadius,\n          innerRadius: innerRadius,\n          startAngle: startAngle,\n          endAngle: endAngle\n        }), innerArc && react.cloneElement(innerArc, {\n          outerRadius: outerRadius,\n          innerRadius: innerRadius,\n          startAngle: startAngle,\n          endAngle: dataEndAngle,\n          data: point,\n          color: getColor({\n            data: data,\n            colorScheme: colorScheme,\n            point: point,\n            index: index\n          })\n        }), valueLabel && react.cloneElement(valueLabel, {\n          data: point\n        }), label && react.cloneElement(label, {\n          data: point,\n          offset: labelOffset\n        })]\n      }), point.key.toLocaleString());\n    }, [arcWidth, colorScheme, columns, data, endAngle, height, innerArc, label, outerArc, padding, scale, startAngle, valueLabel, width, xScale, yScale]);\n    return jsxRuntime.jsx(react.Fragment, {\n      children: data.map(renderGauge)\n    }, void 0);\n  };\n\n  RadialGaugeSeries.defaultProps = {\n    arcWidth: 5,\n    outerArc: jsxRuntime.jsx(RadialGaugeOuterArc, {}, void 0),\n    innerArc: jsxRuntime.jsx(RadialGaugeArc, {}, void 0),\n    label: jsxRuntime.jsx(RadialGaugeLabel, {}, void 0),\n    valueLabel: jsxRuntime.jsx(RadialGaugeValueLabel, {}, void 0),\n    colorScheme: ['#00ECB1'],\n    padding: 20,\n    minGaugeWidth: 50\n  };\n  var css_248z$1 = \".StackedRadialGaugeValueLabel-module_stackedValueLabel__1t9Tt {\\n  font-size: 18px;\\n  font-weight: 400;\\n  fill: var(--color-on-background);\\n}\\n\";\n  var css$1 = {\n    \"stackedValueLabel\": \"StackedRadialGaugeValueLabel-module_stackedValueLabel__1t9Tt\"\n  };\n  styleInject(css_248z$1);\n\n  var StackedRadialGaugeValueLabel = function StackedRadialGaugeValueLabel(_ref82) {\n    var label = _ref82.label,\n        className = _ref82.className,\n        yOffset = _ref82.yOffset;\n    return jsxRuntime.jsx(jsxRuntime.Fragment, {\n      children: label && jsxRuntime.jsx(\"text\", Object.assign({\n        x: \"0\",\n        y: yOffset,\n        textAnchor: \"middle\",\n        alignmentBaseline: \"middle\",\n        className: classNames__default['default'](className, css$1.stackedValueLabel)\n      }, {\n        children: label\n      }), void 0)\n    }, void 0);\n  };\n\n  StackedRadialGaugeValueLabel.defaultProps = {\n    yOffset: 0\n  };\n\n  var StackedRadialGaugeSeries = function StackedRadialGaugeSeries(_ref83) {\n    var data = _ref83.data,\n        width = _ref83.width,\n        height = _ref83.height,\n        scale = _ref83.scale,\n        startAngle = _ref83.startAngle,\n        endAngle = _ref83.endAngle,\n        outerArc = _ref83.outerArc,\n        innerArc = _ref83.innerArc,\n        label = _ref83.label,\n        colorScheme = _ref83.colorScheme,\n        fillFactor = _ref83.fillFactor,\n        arcPadding = _ref83.arcPadding;\n    var radius = Math.min(width, height) / 2;\n    var innerRadius = radius * (1 - Math.min(fillFactor, 1));\n    var rAxis = d3Scale.scaleBand().domain(d3Array.range(data.length)).range([innerRadius, radius]).paddingInner(arcPadding);\n    var renderStackedGauges = react.useCallback(function (point, index) {\n      var dataEndAngle = scale(point.data);\n      var outerRadius = rAxis(index);\n      var innerRadius = outerRadius - rAxis.bandwidth();\n      return jsxRuntime.jsxs(\"g\", {\n        children: [outerArc && react.cloneElement(outerArc, {\n          outerRadius: outerRadius,\n          innerRadius: innerRadius,\n          startAngle: startAngle,\n          endAngle: endAngle\n        }), innerArc && react.cloneElement(innerArc, {\n          outerRadius: outerRadius,\n          innerRadius: innerRadius,\n          startAngle: startAngle,\n          endAngle: dataEndAngle,\n          data: point,\n          color: getColor({\n            data: data,\n            colorScheme: colorScheme,\n            point: point,\n            index: index\n          })\n        })]\n      }, point.key.toLocaleString());\n    }, [rAxis, colorScheme, data, endAngle, innerArc, outerArc, scale, startAngle]);\n    return jsxRuntime.jsx(jsxRuntime.Fragment, {\n      children: jsxRuntime.jsxs(\"g\", Object.assign({\n        transform: \"translate(\".concat(width / 2, \", \").concat(height / 2, \")\")\n      }, {\n        children: [data.map(renderStackedGauges), label]\n      }), void 0)\n    }, void 0);\n  };\n\n  StackedRadialGaugeSeries.defaultProps = {\n    outerArc: jsxRuntime.jsx(RadialGaugeArc, {\n      disabled: true,\n      animated: false\n    }, void 0),\n    innerArc: jsxRuntime.jsx(RadialGaugeArc, {\n      animated: true\n    }, void 0),\n    label: jsxRuntime.jsx(StackedRadialGaugeValueLabel, {}, void 0),\n    colorScheme: ['#00ECB1'],\n    fillFactor: 0.2,\n    arcPadding: 0.15\n  };\n\n  var RadialGauge = function RadialGauge(_ref84) {\n    var id = _ref84.id,\n        width = _ref84.width,\n        height = _ref84.height,\n        margins = _ref84.margins,\n        className = _ref84.className,\n        data = _ref84.data,\n        minValue = _ref84.minValue,\n        maxValue = _ref84.maxValue,\n        startAngle = _ref84.startAngle,\n        endAngle = _ref84.endAngle,\n        series = _ref84.series,\n        containerClassName = _ref84.containerClassName;\n    var scale = d3Scale.scaleLinear().domain([minValue, maxValue]).range([startAngle, endAngle]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      margins: margins,\n      xAxisVisible: false,\n      yAxisVisible: false,\n      className: className,\n      containerClassName: containerClassName\n    }, {\n      children: function children(props) {\n        return react.cloneElement(series, {\n          scale: scale,\n          data: data,\n          startAngle: startAngle,\n          endAngle: endAngle,\n          width: props.width,\n          height: props.height\n        });\n      }\n    }), void 0);\n  };\n\n  RadialGauge.defaultProps = {\n    minValue: 0,\n    maxValue: 100,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    series: jsxRuntime.jsx(RadialGaugeSeries, {}, void 0)\n  };\n  var css_248z = \".HeatmapCell-module_cell__2iO3O {\\n  transition: stroke 150ms ease-in-out;\\n}\\n\";\n  var css = {\n    \"cell\": \"HeatmapCell-module_cell__2iO3O\"\n  };\n  styleInject(css_248z); // Set padding modifier for the tooltips\n\n  var modifiers = {\n    offset: {\n      offset: '0, 3px'\n    }\n  };\n\n  var HeatmapCell = function HeatmapCell(_a) {\n    var rx = _a.rx,\n        ry = _a.ry,\n        cursor = _a.cursor,\n        tooltip = _a.tooltip,\n        onClick = _a.onClick,\n        onMouseEnter = _a.onMouseEnter,\n        onMouseLeave = _a.onMouseLeave,\n        data = _a.data,\n        animated = _a.animated,\n        cellIndex = _a.cellIndex,\n        cellCount = _a.cellCount,\n        fill = _a.fill,\n        x = _a.x,\n        y = _a.y,\n        style = _a.style,\n        className = _a.className,\n        rest = __rest(_a, [\"rx\", \"ry\", \"cursor\", \"tooltip\", \"onClick\", \"onMouseEnter\", \"onMouseLeave\", \"data\", \"animated\", \"cellIndex\", \"cellCount\", \"fill\", \"x\", \"y\", \"style\", \"className\"]);\n\n    var _react$useState55 = react.useState(false),\n        _react$useState56 = _slicedToArray(_react$useState55, 2),\n        active = _react$useState56[0],\n        setActive = _react$useState56[1];\n\n    var rect = react.useRef(null);\n\n    var onMouseEnterWrapper = function onMouseEnterWrapper(event) {\n      setActive(true);\n      onMouseEnter({\n        value: data,\n        nativeEvent: event\n      });\n    };\n\n    var onMouseLeaveWrapper = function onMouseLeaveWrapper(event) {\n      setActive(false);\n      onMouseLeave({\n        value: data,\n        nativeEvent: event\n      });\n    };\n\n    var onMouseClick = function onMouseClick(event) {\n      onClick({\n        value: data,\n        nativeEvent: event\n      });\n    };\n\n    var tooltipData = react.useMemo(function () {\n      return {\n        y: data.value,\n        x: \"\".concat(data.key, \" \\u2219 \").concat(data.x),\n        data: data\n      };\n    }, [data]);\n    var transition = react.useMemo(function () {\n      if (animated) {\n        return Object.assign(Object.assign({}, DEFAULT_TRANSITION), {\n          delay: cellIndex / cellCount * 0.005\n        });\n      } else {\n        return {\n          type: false,\n          delay: 0\n        };\n      }\n    }, [animated, cellIndex, cellCount]);\n    var extras = constructFunctionProps({\n      style: style,\n      className: className\n    }, data);\n    var isTransparent = fill === 'transparent';\n    var stroke = active && !isTransparent ? chroma__default['default'](fill).brighten(1) : fill;\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [jsxRuntime.jsx(\"g\", Object.assign({\n        ref: rect\n      }, {\n        children: jsxRuntime.jsx(framerMotion.motion.rect, Object.assign({}, rest, {\n          fill: fill,\n          stroke: stroke,\n          x: x,\n          y: y,\n          style: Object.assign(Object.assign({}, extras.style), {\n            cursor: cursor\n          }),\n          className: classNames__default['default'](css.cell, extras.className),\n          initial: {\n            opacity: 0\n          },\n          animate: {\n            opacity: 1\n          },\n          exit: {\n            opacity: 0\n          },\n          transition: transition,\n          onMouseEnter: onMouseEnterWrapper,\n          onMouseLeave: onMouseLeaveWrapper,\n          onClick: onMouseClick\n        }), void 0)\n      }), void 0), tooltip && !tooltip.props.disabled && !isTransparent && jsxRuntime.jsx(rdk.CloneElement, {\n        element: tooltip,\n        visible: active,\n        modifiers: tooltip.props.modifiers || modifiers,\n        reference: rect,\n        value: tooltipData\n      }, void 0)]\n    }, void 0);\n  };\n\n  HeatmapCell.defaultProps = {\n    rx: 2,\n    ry: 2,\n    cursor: 'auto',\n    tooltip: jsxRuntime.jsx(ChartTooltip, {}, void 0),\n    onClick: function onClick() {\n      return undefined;\n    },\n    onMouseEnter: function onMouseEnter() {\n      return undefined;\n    },\n    onMouseLeave: function onMouseLeave() {\n      return undefined;\n    }\n  };\n\n  var getValueScale = function getValueScale(data, colorScheme, emptyColor) {\n    var valueDomain = d3Array.extent(uniqueBy(data, function (d) {\n      return d.data;\n    }, function (d) {\n      return d.value;\n    }));\n    return function (point) {\n      // For 0 values, lets show a placeholder fill\n      if (point === undefined || point === null) {\n        return emptyColor;\n      }\n\n      return getColor({\n        scale: d3Scale.scaleQuantile,\n        domain: valueDomain,\n        key: point,\n        colorScheme: colorScheme\n      });\n    };\n  };\n\n  var HeatmapSeries = function HeatmapSeries(_ref85) {\n    var animated = _ref85.animated,\n        emptyColor = _ref85.emptyColor,\n        colorScheme = _ref85.colorScheme,\n        cellElement = _ref85.cell,\n        xScale = _ref85.xScale,\n        yScale = _ref85.yScale,\n        data = _ref85.data,\n        id = _ref85.id;\n    var valueScale = getValueScale(data, colorScheme, emptyColor);\n    var height = yScale.bandwidth();\n    var width = xScale.bandwidth();\n    var cellCount = d3Array.sum([].concat(_toConsumableArray(yScale.domain()), _toConsumableArray(xScale.domain())));\n\n    var renderCell = function renderCell(_ref86) {\n      var row = _ref86.row,\n          cell = _ref86.cell,\n          rowIndex = _ref86.rowIndex,\n          cellIndex = _ref86.cellIndex,\n          width = _ref86.width,\n          height = _ref86.height,\n          cellCount = _ref86.cellCount;\n      var x = xScale(row.key);\n      var y = yScale(cell.x);\n      var fill = valueScale(cell.value);\n      return jsxRuntime.jsx(rdk.CloneElement, {\n        element: cellElement,\n        animated: animated,\n        cellIndex: rowIndex + cellIndex,\n        cellCount: cellCount,\n        x: x,\n        y: y,\n        fill: fill,\n        width: width,\n        height: height,\n        data: cell\n      }, \"\".concat(id, \"-\").concat(rowIndex, \"-\").concat(cellIndex));\n    };\n\n    return jsxRuntime.jsx(react.Fragment, {\n      children: data.map(function (row, rowIndex) {\n        return row.data.map(function (cell, cellIndex) {\n          return renderCell({\n            height: height,\n            width: width,\n            valueScale: valueScale,\n            cellCount: cellCount,\n            row: row,\n            cell: cell,\n            rowIndex: rowIndex,\n            cellIndex: cellIndex\n          });\n        });\n      })\n    }, void 0);\n  };\n\n  HeatmapSeries.defaultProps = {\n    padding: 0.1,\n    animated: true,\n    emptyColor: 'rgba(200,200,200,0.08)',\n    colorScheme: ['rgba(28, 107, 86, 0.5)', '#2da283'],\n    cell: jsxRuntime.jsx(HeatmapCell, {}, void 0)\n  };\n\n  var Heatmap = function Heatmap(_ref87) {\n    var data = _ref87.data,\n        margins = _ref87.margins,\n        series = _ref87.series,\n        yAxis = _ref87.yAxis,\n        xAxis = _ref87.xAxis,\n        secondaryAxis = _ref87.secondaryAxis,\n        id = _ref87.id,\n        width = _ref87.width,\n        height = _ref87.height,\n        className = _ref87.className,\n        containerClassName = _ref87.containerClassName;\n    var getScalesData = react.useCallback(function (chartHeight, chartWidth) {\n      var nestedData = buildNestedChartData(data);\n      var xDomain = xAxis.props.domain || uniqueBy(nestedData, function (d) {\n        return d.key;\n      });\n      var xScale = d3Scale.scaleBand().range([0, chartWidth]).domain(xDomain).paddingInner(series.props.padding || 0.1);\n      var yDomain = yAxis.props.domain || uniqueBy(nestedData, function (d) {\n        return d.data;\n      }, function (d) {\n        return d.x;\n      });\n      var yScale = d3Scale.scaleBand().domain(yDomain).range([chartHeight, 0]).paddingInner(series.props.padding || 0.1);\n      return {\n        yScale: yScale,\n        xScale: xScale,\n        data: nestedData\n      };\n    }, [data, xAxis, yAxis, series]);\n\n    var renderChart = function renderChart(containerProps) {\n      var chartWidth = containerProps.chartWidth,\n          chartHeight = containerProps.chartHeight,\n          updateAxes = containerProps.updateAxes,\n          id = containerProps.id;\n\n      var _getScalesData = getScalesData(chartHeight, chartWidth),\n          xScale = _getScalesData.xScale,\n          yScale = _getScalesData.yScale,\n          scalesData = _getScalesData.data;\n\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [jsxRuntime.jsx(rdk.CloneElement, {\n          element: xAxis,\n          height: chartHeight,\n          width: chartWidth,\n          scale: xScale,\n          onDimensionsChange: function onDimensionsChange(event) {\n            return updateAxes('horizontal', event);\n          }\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: yAxis,\n          height: chartHeight,\n          width: chartWidth,\n          scale: yScale,\n          onDimensionsChange: function onDimensionsChange(event) {\n            return updateAxes('vertical', event);\n          }\n        }, void 0), secondaryAxis && secondaryAxis.map(function (axis, i) {\n          return jsxRuntime.jsx(rdk.CloneElement, {\n            element: axis,\n            height: chartHeight,\n            width: chartWidth,\n            onDimensionsChange: function onDimensionsChange(event) {\n              return updateAxes('horizontal', event);\n            }\n          }, i);\n        }), jsxRuntime.jsx(rdk.CloneElement, {\n          element: series,\n          id: \"heat-series-\".concat(id),\n          data: scalesData,\n          xScale: xScale,\n          yScale: yScale\n        }, void 0)]\n      }, void 0);\n    };\n\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      margins: margins,\n      containerClassName: containerClassName,\n      xAxisVisible: isAxisVisible(xAxis.props),\n      yAxisVisible: isAxisVisible(yAxis.props),\n      className: className\n    }, {\n      children: renderChart\n    }), void 0);\n  };\n\n  Heatmap.defaultProps = {\n    data: [],\n    margins: 10,\n    series: jsxRuntime.jsx(HeatmapSeries, {\n      padding: 0.1\n    }, void 0),\n    yAxis: jsxRuntime.jsx(LinearYAxis, {\n      type: \"category\",\n      axisLine: null,\n      tickSeries: jsxRuntime.jsx(LinearYAxisTickSeries, {\n        line: null,\n        label: jsxRuntime.jsx(LinearYAxisTickLabel, {\n          padding: 5\n        }, void 0)\n      }, void 0)\n    }, void 0),\n    xAxis: jsxRuntime.jsx(LinearXAxis, {\n      type: \"category\",\n      axisLine: null,\n      tickSeries: jsxRuntime.jsx(LinearXAxisTickSeries, {\n        line: null,\n        label: jsxRuntime.jsx(LinearXAxisTickLabel, {\n          padding: 5\n        }, void 0)\n      }, void 0)\n    }, void 0)\n  };\n\n  var getFirstOfMonth = function getFirstOfMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth(), 1);\n  };\n\n  var addWeeksToDate = function addWeeksToDate(date, weeks) {\n    var d = new Date(date.getTime());\n    d.setDate(d.getDate() + weeks * 7);\n    return d;\n  };\n\n  var getStartOfDay = function getStartOfDay(date) {\n    var d = new Date(date.getTime());\n    d.setHours(0, 0, 0, 0);\n    return d;\n  };\n\n  var getNewDayFromDay = function getNewDayFromDay(date, num) {\n    var d = new Date(date.getTime());\n    d.setDate(d.getDate() + num);\n    return d;\n  };\n\n  var weekDays = function () {\n    var base = new Date(Date.UTC(2017, 0, 2));\n    return d3Array.range(7).map(function () {\n      var name = base.toLocaleDateString('default', {\n        weekday: 'short'\n      });\n      base.setDate(base.getDate() + 1);\n      return name;\n    });\n  }();\n\n  var buildDataScales = function buildDataScales(rawData, view) {\n    var _a; // Get the most recent date to get the range from\n    // From the end date, lets find the start year/month of that\n    // From that start year/month, lets find the end year/month for our bounds\n\n\n    var startDate = d3Array.min(rawData, function (d) {\n      return d.key;\n    });\n    var start = getFirstOfMonth(startDate);\n    var endDomain = view === 'year' ? 53 : 5;\n    var end = addWeeksToDate(start, endDomain); // Base on the view type, swap out some ranges\n\n    var xDomainRange = view === 'year' ? 53 : 5; // Build our x/y domains for days of week + number of weeks in year\n\n    var yDomain = d3Array.range(7).reverse();\n    var xDomain = d3Array.range(xDomainRange); // Filter out dates that are not in the start/end ranges\n    // and turn them into something our chart can read\n\n    var dates = rawData.filter(function (d) {\n      return d.key.getTime() > start.getTime() || d.key.getTime() < end.getTime();\n    }).map(function (d) {\n      return {\n        key: getStartOfDay(d.key),\n        data: d.data\n      };\n    }); // Find the first day of the duration and subtract the delta\n\n    var firstDayOfStart = start.getDay();\n    var curDate = getNewDayFromDay(start, -firstDayOfStart);\n    var rows = []; // Build out the dataset for the n duration\n\n    for (var week = 0; week < xDomainRange; week++) {\n      var row = {\n        key: week,\n        data: []\n      };\n\n      for (var day = 0; day <= 6; day++) {\n        var dayValue = dates.find(function (d) {\n          return d.key.getTime() === curDate.getTime();\n        });\n        row.data.push({\n          key: day,\n          data: (_a = dayValue === null || dayValue === void 0 ? void 0 : dayValue.data) !== null && _a !== void 0 ? _a : undefined,\n          metadata: {\n            date: new Date(curDate.getTime()),\n            start: start,\n            end: end\n          }\n        });\n        curDate.setDate(curDate.getDate() + 1);\n      }\n\n      rows.push(row);\n    }\n\n    return {\n      data: rows,\n      yDomain: yDomain,\n      xDomain: xDomain,\n      start: start\n    };\n  }; // Format the xAxis label for the start + n week\n\n\n  var xAxisLabelFormat = function xAxisLabelFormat(start) {\n    return function (weeks) {\n      return addWeeksToDate(start, weeks).toLocaleString('default', {\n        month: 'long'\n      });\n    };\n  };\n\n  var CalendarHeatmap = function CalendarHeatmap(_a) {\n    var view = _a.view,\n        series = _a.series,\n        data = _a.data,\n        rest = __rest(_a, [\"view\", \"series\", \"data\"]);\n\n    var _react$useMemo6 = react.useMemo(function () {\n      return buildDataScales(data, view);\n    }, [data, view]),\n        domainData = _react$useMemo6.data,\n        yDomain = _react$useMemo6.yDomain,\n        xDomain = _react$useMemo6.xDomain,\n        start = _react$useMemo6.start; // For month, only pass 1 tick value\n\n\n    var xTickValues = view === 'year' ? undefined : [1]; // Get the yAxis label formatting based on view type\n\n    var yAxisLabelFormat = view === 'year' ? function (d) {\n      return weekDays[d];\n    } : function () {\n      return null;\n    };\n    return jsxRuntime.jsx(Heatmap, Object.assign({}, rest, {\n      data: domainData,\n      yAxis: jsxRuntime.jsx(LinearYAxis, {\n        type: \"category\",\n        axisLine: null,\n        domain: yDomain,\n        tickSeries: jsxRuntime.jsx(LinearYAxisTickSeries, {\n          tickSize: 20,\n          line: null,\n          label: jsxRuntime.jsx(LinearYAxisTickLabel, {\n            padding: 5,\n            format: yAxisLabelFormat\n          }, void 0)\n        }, void 0)\n      }, void 0),\n      xAxis: jsxRuntime.jsx(LinearXAxis, {\n        type: \"category\",\n        axisLine: null,\n        domain: xDomain,\n        tickSeries: jsxRuntime.jsx(LinearXAxisTickSeries, {\n          line: null,\n          tickValues: xTickValues,\n          label: jsxRuntime.jsx(LinearXAxisTickLabel, {\n            padding: 5,\n            align: \"end\",\n            format: xAxisLabelFormat(start)\n          }, void 0)\n        }, void 0)\n      }, void 0)\n    }), void 0);\n  };\n\n  CalendarHeatmap.defaultProps = {\n    view: 'year',\n    series: jsxRuntime.jsx(HeatmapSeries, {\n      padding: 0.3,\n      emptyColor: \"transparent\",\n      cell: jsxRuntime.jsx(HeatmapCell, {\n        tooltip: jsxRuntime.jsx(ChartTooltip, {\n          content: function content(d) {\n            return \"\".concat(formatValue(d.data.metadata.date), \" \\u2219 \").concat(formatValue(d.data.value));\n          }\n        }, void 0)\n      }, void 0)\n    }, void 0)\n  };\n\n  var LinearGaugeBar = function LinearGaugeBar(props) {\n    return jsxRuntime.jsx(Bar, Object.assign({}, props), void 0);\n  };\n\n  LinearGaugeBar.defaultProps = {\n    tooltip: jsxRuntime.jsx(ChartTooltip, {\n      placement: \"top\",\n      content: function content(data) {\n        return jsxRuntime.jsx(TooltipTemplate, {\n          value: {\n            y: data.value,\n            x: data.y\n          }\n        }, void 0);\n      }\n    }, void 0)\n  };\n\n  var LinearGaugeOuterBar = function LinearGaugeOuterBar(_a) {\n    var height = _a.height,\n        width = _a.width,\n        fill = _a.fill,\n        rest = __rest(_a, [\"height\", \"width\", \"fill\"]);\n\n    return jsxRuntime.jsx(\"rect\", Object.assign({}, rest, {\n      fill: fill,\n      width: Math.max(width, 0),\n      height: Math.max(height, 0)\n    }), void 0);\n  };\n\n  LinearGaugeOuterBar.defaultProps = {\n    fill: '#484848'\n  };\n\n  var LinearGaugeSeries = function LinearGaugeSeries(_a) {\n    var height = _a.height,\n        width = _a.width,\n        bar = _a.bar,\n        outerBar = _a.outerBar,\n        isMultiSeries = _a.isMultiSeries,\n        rest = __rest(_a, [\"height\", \"width\", \"bar\", \"outerBar\", \"isMultiSeries\"]);\n\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [!isMultiSeries && outerBar && jsxRuntime.jsx(rdk.CloneElement, {\n        element: outerBar,\n        height: height,\n        width: width\n      }, void 0), jsxRuntime.jsx(BarSeries, Object.assign({}, rest, {\n        layout: \"horizontal\",\n        tooltip: null,\n        bar: jsxRuntime.jsx(rdk.CloneElement, {\n          element: bar\n        }, void 0)\n      }), void 0)]\n    }, void 0);\n  };\n\n  LinearGaugeSeries.defaultProps = {\n    outerBar: jsxRuntime.jsx(LinearGaugeOuterBar, {}, void 0),\n    bar: jsxRuntime.jsx(LinearGaugeBar, {}, void 0)\n  };\n\n  var LinearGauge = function LinearGauge(_ref88) {\n    var id = _ref88.id,\n        width = _ref88.width,\n        height = _ref88.height,\n        margins = _ref88.margins,\n        className = _ref88.className,\n        containerClassName = _ref88.containerClassName,\n        series = _ref88.series,\n        data = _ref88.data,\n        minValue = _ref88.minValue,\n        maxValue = _ref88.maxValue;\n    var transformedData = react.useMemo(function () {\n      if (Array.isArray(data)) {\n        return buildBarStackData([{\n          key: 'default',\n          data: data\n        }], 'expand', 'horizontal');\n      } else {\n        return buildShallowChartData([data], 'horizontal');\n      }\n    }, [data]);\n    var getScales = react.useCallback(function (isMultiSeries, data, width, height, minValue, maxValue) {\n      var domain = !isMultiSeries ? [minValue, maxValue] : undefined;\n      var keyScale = getXScale({\n        width: width,\n        type: 'value',\n        data: data,\n        domain: domain,\n        isMultiSeries: isMultiSeries\n      });\n      var valueScale = getYScale({\n        type: 'category',\n        height: height,\n        data: data,\n        isMultiSeries: isMultiSeries\n      });\n      return {\n        keyScale: keyScale,\n        valueScale: valueScale\n      };\n    }, []);\n    var renderChart = react.useCallback(function (_ref89) {\n      var chartHeight = _ref89.chartHeight,\n          chartWidth = _ref89.chartWidth,\n          id = _ref89.id,\n          chartSized = _ref89.chartSized;\n      var isMultiSeries = Array.isArray(data);\n      var type = isMultiSeries ? 'stackedNormalized' : 'standard';\n\n      var _getScales6 = getScales(isMultiSeries, transformedData, chartWidth, chartHeight, minValue, maxValue),\n          keyScale = _getScales6.keyScale,\n          valueScale = _getScales6.valueScale;\n\n      return jsxRuntime.jsx(react.Fragment, {\n        children: chartSized && jsxRuntime.jsx(rdk.CloneElement, {\n          element: series,\n          id: \"linear-gauge-series-\".concat(id),\n          data: transformedData,\n          isCategorical: true,\n          xScale: keyScale,\n          yScale: valueScale,\n          type: type,\n          height: chartHeight,\n          width: chartWidth,\n          isMultiSeries: isMultiSeries\n        }, void 0)\n      }, void 0);\n    }, [data, getScales, maxValue, minValue, series, transformedData]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      margins: margins,\n      className: className,\n      containerClassName: containerClassName\n    }, {\n      children: renderChart\n    }), void 0);\n  };\n\n  LinearGauge.defaultProps = {\n    minValue: 0,\n    maxValue: 100,\n    series: jsxRuntime.jsx(LinearGaugeSeries, {}, void 0)\n  };\n\n  var useInterpolate = function useInterpolate(_ref90) {\n    var data = _ref90.data,\n        animated = _ref90.animated;\n    var transition = animated ? Object.assign({}, DEFAULT_TRANSITION) : {\n      delay: 0,\n      type: false\n    };\n    var d = framerMotion.useMotionValue(data.path);\n    var prevPath = framerMotion.useMotionValue(data.path);\n    var spring = framerMotion.useSpring(prevPath, {\n      from: 0,\n      to: 1\n    });\n    react.useEffect(function () {\n      var interpolator = d3Interpolate.interpolate(prevPath.get(), data.path);\n      spring.onChange(function (v) {\n        return d.set(interpolator(v));\n      });\n      prevPath.set(data.path);\n    });\n    return {\n      transition: transition,\n      d: d\n    };\n  };\n\n  var VennArc = function VennArc(_ref91) {\n    var data = _ref91.data,\n        fill = _ref91.fill,\n        disabled = _ref91.disabled,\n        animated = _ref91.animated,\n        stroke = _ref91.stroke,\n        mask = _ref91.mask,\n        id = _ref91.id,\n        style = _ref91.style,\n        active = _ref91.active,\n        inactiveStyle = _ref91.inactiveStyle,\n        activeStyle = _ref91.activeStyle,\n        initialStyle = _ref91.initialStyle,\n        strokeWidth = _ref91.strokeWidth,\n        gradient = _ref91.gradient,\n        tooltip = _ref91.tooltip,\n        _onClick5 = _ref91.onClick,\n        _onMouseEnter4 = _ref91.onMouseEnter,\n        _onMouseLeave4 = _ref91.onMouseLeave;\n\n    var _a, _b;\n\n    var _react$useState57 = react.useState(false),\n        _react$useState58 = _slicedToArray(_react$useState57, 2),\n        internalActive = _react$useState58[0],\n        setInternalActive = _react$useState58[1];\n\n    var arcRef = react.useRef(null);\n\n    var _useInterpolate = useInterpolate({\n      animated: animated,\n      data: data\n    }),\n        transition = _useInterpolate.transition,\n        d = _useInterpolate.d;\n\n    var currentStyle = active ? activeStyle : active === null ? inactiveStyle : initialStyle;\n    var arcFill = gradient && !mask ? \"url(#gradient-\".concat(id, \")\") : mask ? \"url(#mask-pattern-\".concat(id, \")\") : fill;\n    return jsxRuntime.jsxs(\"g\", Object.assign({\n      title: data.data.key,\n      onMouseEnter: function onMouseEnter(event) {\n        if (!disabled) {\n          setInternalActive(true);\n\n          _onMouseEnter4({\n            value: data.data,\n            nativeEvent: event\n          });\n        }\n      },\n      onMouseLeave: function onMouseLeave(event) {\n        if (!disabled) {\n          setInternalActive(false);\n\n          _onMouseLeave4({\n            value: data.data,\n            nativeEvent: event\n          });\n        }\n      },\n      onClick: function onClick(event) {\n        if (!disabled) {\n          _onClick5({\n            value: data.data,\n            nativeEvent: event\n          });\n        }\n      }\n    }, {\n      children: [jsxRuntime.jsx(framerMotion.motion.path, {\n        ref: arcRef,\n        fill: arcFill,\n        id: \"\".concat(id, \"-arc\"),\n        strokeWidth: strokeWidth,\n        stroke: stroke,\n        transition: transition,\n        d: d,\n        initial: initialStyle,\n        animate: currentStyle,\n        style: style\n      }, void 0), mask && jsxRuntime.jsxs(react.Fragment, {\n        children: [jsxRuntime.jsx(Mask, {\n          id: \"mask-\".concat(id),\n          fill: \"url(#gradient-\".concat(id, \")\")\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: mask,\n          id: \"mask-pattern-\".concat(id),\n          fill: fill\n        }, void 0)]\n      }, void 0), gradient && jsxRuntime.jsx(rdk.CloneElement, {\n        element: gradient,\n        id: \"gradient-\".concat(id),\n        color: fill\n      }, void 0), tooltip && !tooltip.props.disabled && jsxRuntime.jsx(rdk.CloneElement, {\n        element: tooltip,\n        visible: !!internalActive,\n        reference: arcRef,\n        value: {\n          y: data.data.size,\n          x: (_b = (_a = data.data) === null || _a === void 0 ? void 0 : _a.sets) === null || _b === void 0 ? void 0 : _b.join(' | ')\n        }\n      }, void 0)]\n    }), void 0);\n  };\n\n  VennArc.defaultProps = {\n    active: false,\n    inactiveStyle: {\n      opacity: 0.3\n    },\n    activeStyle: {\n      opacity: 0.8\n    },\n    initialStyle: {\n      opacity: 0.6\n    },\n    strokeWidth: 3,\n    gradient: jsxRuntime.jsx(Gradient, {}, void 0),\n    tooltip: jsxRuntime.jsx(ChartTooltip, {}, void 0),\n    onClick: function onClick() {\n      return undefined;\n    },\n    onMouseEnter: function onMouseEnter() {\n      return undefined;\n    },\n    onMouseLeave: function onMouseLeave() {\n      return undefined;\n    }\n  };\n\n  var VennLabel = function VennLabel(_ref92) {\n    var data = _ref92.data,\n        format = _ref92.format,\n        id = _ref92.id,\n        active = _ref92.active,\n        labelType = _ref92.labelType,\n        showAll = _ref92.showAll,\n        wrap = _ref92.wrap,\n        animated = _ref92.animated,\n        fill = _ref92.fill,\n        fontSize = _ref92.fontSize,\n        fontFamily = _ref92.fontFamily;\n\n    var _a, _b, _c, _d, _e; // If the text area is very large, then lets just skip showing the label\n\n\n    if (!showAll && !((_a = data.arcs) === null || _a === void 0 ? void 0 : _a.filter(function (a) {\n      return a.large;\n    }).length)) {\n      return null;\n    }\n\n    var key = labelType === 'key' ? (_c = (_b = data.data) === null || _b === void 0 ? void 0 : _b.sets) === null || _c === void 0 ? void 0 : _c.join(' | ') : data.data.size;\n    var transition = animated ? DEFAULT_TRANSITION : {\n      delay: 0,\n      type: false\n    };\n    var text = wrap ? wrapText({\n      key: key,\n      x: data.text.x,\n      fontFamily: fontFamily,\n      fontSize: fontSize,\n      width: (_e = (_d = data === null || data === void 0 ? void 0 : data.circles) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.radius\n    }) : key;\n    return jsxRuntime.jsx(framerMotion.motion.text, Object.assign({\n      id: \"\".concat(id, \"-text\"),\n      style: {\n        pointerEvents: 'none',\n        fontFamily: fontFamily,\n        fontSize: fontSize\n      },\n      fill: fill,\n      initial: {\n        attrX: data.text.x,\n        attrY: data.text.y,\n        opacity: 1\n      },\n      animate: {\n        attrX: data.text.x,\n        attrY: data.text.y,\n        opacity: active === null ? 0.3 : 1\n      },\n      transition: transition,\n      textAnchor: \"middle\"\n    }, {\n      children: format ? format(data) : text\n    }), void 0);\n  };\n\n  VennLabel.defaultProps = {\n    labelType: 'key',\n    showAll: false,\n    wrap: true,\n    animated: true,\n    fill: '#000',\n    fontSize: 11,\n    fontFamily: 'sans-serif'\n  };\n\n  var VennOuterLabel = function VennOuterLabel(_ref93) {\n    var data = _ref93.data,\n        format = _ref93.format,\n        animated = _ref93.animated,\n        fill = _ref93.fill,\n        fontSize = _ref93.fontSize,\n        fontFamily = _ref93.fontFamily;\n    var transition = animated ? DEFAULT_TRANSITION : {\n      delay: 0,\n      type: false\n    };\n    var text = data.set.data.key;\n    var label = format ? format(data) : text;\n    var isElement = react.isValidElement(label);\n    var showIcon = isElement && data.set.icon; // TODO: framer-motion doesn't seem to like the translates on the g\n    // initial={pos} animate={pos}\n\n    var pos = {\n      x: showIcon ? data.set.icon.x : data.set.text.x,\n      y: showIcon ? data.set.icon.y : data.set.text.y\n    };\n    return jsxRuntime.jsx(react.Fragment, {\n      children: isElement ? jsxRuntime.jsx(\"g\", Object.assign({\n        style: {\n          transform: \"translate(\".concat(pos.x, \"px, \").concat(pos.y, \"px)\")\n        }\n      }, {\n        children: label\n      }), void 0) : jsxRuntime.jsx(framerMotion.motion.text, Object.assign({\n        fill: fill,\n        style: {\n          pointerEvents: 'none',\n          fontFamily: fontFamily,\n          fontSize: fontSize\n        },\n        textAnchor: data.set.align === 'middle' ? 'center' : data.set.align,\n        alignmentBaseline: data.set.verticalAlign,\n        initial: {\n          attrX: pos.x,\n          attrY: pos.y\n        },\n        animate: {\n          attrX: pos.x,\n          attrY: pos.y\n        },\n        transition: transition\n      }, {\n        children: label\n      }), void 0)\n    }, void 0);\n  };\n\n  VennOuterLabel.defaultProps = {\n    animated: true,\n    fill: '#000',\n    fontSize: 14,\n    fontFamily: 'sans-serif'\n  };\n\n  var getSafeKey = function getSafeKey(d) {\n    var _a, _b;\n\n    return (_b = (_a = d.data) === null || _a === void 0 ? void 0 : _a.key) === null || _b === void 0 ? void 0 : _b.replace(' ', '');\n  };\n\n  var VennSeries = function VennSeries(_ref94) {\n    var data = _ref94.data,\n        id = _ref94.id,\n        selections = _ref94.selections,\n        animated = _ref94.animated,\n        disabled = _ref94.disabled,\n        colorScheme = _ref94.colorScheme,\n        outerLabel = _ref94.outerLabel,\n        arc = _ref94.arc,\n        label = _ref94.label;\n    var transition = animated ? DEFAULT_TRANSITION : {\n      type: false,\n      delay: 0\n    };\n\n    var _react$useState59 = react.useState([]),\n        _react$useState60 = _slicedToArray(_react$useState59, 2),\n        actives = _react$useState60[0],\n        setActives = _react$useState60[1];\n\n    var _react$useState61 = react.useState(null),\n        _react$useState62 = _slicedToArray(_react$useState61, 2),\n        hovered = _react$useState62[0],\n        setHovered = _react$useState62[1];\n\n    var onActivate = react.useCallback(function (point) {\n      setHovered(point);\n      setActives(data.filter(function (d) {\n        var _a;\n\n        return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.key.indexOf(point)) > -1;\n      }).map(function (d) {\n        var _a;\n\n        return (_a = d.data) === null || _a === void 0 ? void 0 : _a.key;\n      }));\n    }, [data]);\n    var renderArc = react.useCallback(function (d, index) {\n      var _a; // Get the colors of the fill\n\n\n      var fill = getColor({\n        data: data,\n        colorScheme: colorScheme,\n        point: d.data,\n        index: index\n      });\n      var textFill = fill ? invert__default['default'](chroma__default['default'](fill).darken(0.5).hex(), true) : 'white';\n      var arcFill = arc.props.fill || fill;\n      var key = (_a = d === null || d === void 0 ? void 0 : d.data) === null || _a === void 0 ? void 0 : _a.key;\n      var safeKey = getSafeKey(d);\n      var isSelected = selections === null || selections === void 0 ? void 0 : selections.includes(key); // Get the state of the arc\n\n      var isHovered = hovered === key || isSelected;\n      var isActive = isSelected || actives.includes(key) || (actives.length > 0 ? null : false); // Get the colors for the stroke\n\n      var stroke = typeof arc.props.stroke === 'function' ? // @ts-ignore\n      arc.props.stroke(data, index, isActive, isHovered) : arc.props.stroke;\n      var arcStroke = stroke || chroma__default['default'](arcFill).darken(isActive ? 0.8 : 0.5).hex();\n      return jsxRuntime.jsxs(react.Fragment, {\n        children: [jsxRuntime.jsx(rdk.CloneElement, {\n          element: arc,\n          id: \"\".concat(id, \"-\").concat(safeKey),\n          data: d,\n          fill: arcFill,\n          stroke: arcStroke,\n          disabled: disabled,\n          animated: animated,\n          active: isActive,\n          onMouseEnter: function onMouseEnter() {\n            return onActivate(key);\n          },\n          onMouseLeave: function onMouseLeave() {\n            setActives([]);\n            setHovered(null);\n          }\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: label,\n          data: d,\n          id: \"\".concat(id, \"-\").concat(safeKey),\n          active: isActive,\n          animated: animated,\n          fill: textFill\n        }, void 0), d.set && outerLabel && jsxRuntime.jsx(rdk.CloneElement, {\n          element: outerLabel,\n          data: d,\n          animated: animated\n        }, void 0)]\n      }, safeKey);\n    }, [colorScheme, data, arc, animated, label, outerLabel, hovered, selections, actives, onActivate]);\n    var topArcs = react.useMemo(function () {\n      var result = [];\n\n      if (actives.length > 0) {\n        result.push.apply(result, _toConsumableArray(actives.filter(function (s) {\n          return s !== hovered;\n        })));\n      }\n\n      if (selections === null || selections === void 0 ? void 0 : selections.length) {\n        result.push.apply(result, _toConsumableArray(selections.filter(function (s) {\n          return !actives.includes(s) && s !== hovered;\n        })));\n      }\n\n      if (hovered) {\n        result.push(hovered);\n      }\n\n      return result;\n    }, [hovered, actives, selections]);\n    return jsxRuntime.jsxs(framerMotion.motion.g, Object.assign({\n      initial: {\n        opacity: 0,\n        scale: 0\n      },\n      animate: {\n        opacity: 1,\n        scale: 1\n      },\n      transition: transition\n    }, {\n      children: [data.map(renderArc), topArcs.length > 0 && topArcs.map(function (a) {\n        return jsxRuntime.jsx(\"use\", {\n          xlinkHref: \"#\".concat(id, \"-\").concat(a, \"-arc\"),\n          style: {\n            pointerEvents: 'none'\n          }\n        }, a);\n      }), data.map(function (d, index) {\n        return jsxRuntime.jsx(\"use\", {\n          xlinkHref: \"#\".concat(id, \"-\").concat(getSafeKey(d), \"-text\"),\n          style: {\n            pointerEvents: 'none'\n          }\n        }, index);\n      })]\n    }), void 0);\n  };\n\n  VennSeries.defaultProps = {\n    animated: true,\n    disabled: false,\n    colorScheme: 'cybertron',\n    outerLabel: jsxRuntime.jsx(VennOuterLabel, {}, void 0),\n    arc: jsxRuntime.jsx(VennArc, {}, void 0),\n    label: jsxRuntime.jsx(VennLabel, {}, void 0)\n  };\n  var sets$5 = [];\n  var intersections$5 = [];\n  var bb$5 = {\n    x: 0,\n    y: 0,\n    width: 10,\n    height: 10\n  };\n  var venn0 = {\n    sets: sets$5,\n    intersections: intersections$5,\n    bb: bb$5\n  };\n  var sets$4 = [{\n    cx: 0,\n    cy: 0,\n    r: 5,\n    text: {\n      x: 3.5,\n      y: -4\n    },\n    align: \"start\",\n    verticalAlign: \"bottom\"\n  }];\n  var intersections$4 = [{\n    sets: [0],\n    x1: 0,\n    y1: 5,\n    arcs: [{\n      mode: \"i\",\n      ref: 0,\n      x2: 0,\n      y2: -5,\n      sweep: false,\n      large: false\n    }, {\n      mode: \"i\",\n      ref: 0,\n      x2: 0,\n      y2: 5,\n      sweep: false,\n      large: false\n    }],\n    text: {\n      x: 0,\n      y: 0\n    }\n  }];\n  var bb$4 = {\n    x: -5,\n    y: -5,\n    width: 10,\n    height: 10\n  };\n  var venn1 = {\n    sets: sets$4,\n    intersections: intersections$4,\n    bb: bb$4\n  };\n  var sets$3 = [{\n    cx: -4,\n    cy: 0,\n    r: 5,\n    text: {\n      x: -7.5,\n      y: 4\n    },\n    align: \"end\",\n    verticalAlign: \"top\"\n  }, {\n    cx: 4,\n    cy: 0,\n    r: 5,\n    text: {\n      x: 7.5,\n      y: -4\n    },\n    align: \"start\",\n    verticalAlign: \"bottom\"\n  }];\n  var intersections$3 = [{\n    sets: [0],\n    x1: 0,\n    y1: -3,\n    arcs: [{\n      mode: \"i\",\n      ref: 0,\n      x2: 0,\n      y2: 3,\n      sweep: false,\n      large: true\n    }, {\n      mode: \"o\",\n      ref: 1,\n      x2: 0,\n      y2: -3,\n      sweep: true,\n      large: false\n    }],\n    text: {\n      x: -4,\n      y: 0\n    }\n  }, {\n    sets: [1],\n    x1: 0,\n    y1: 3,\n    arcs: [{\n      mode: \"i\",\n      ref: 1,\n      x2: 0,\n      y2: -3,\n      sweep: false,\n      large: true\n    }, {\n      mode: \"o\",\n      ref: 0,\n      x2: 0,\n      y2: 3,\n      sweep: true,\n      large: false\n    }],\n    text: {\n      x: 4,\n      y: 0\n    }\n  }, {\n    sets: [0, 1],\n    x1: 0,\n    y1: 3,\n    arcs: [{\n      mode: \"i\",\n      ref: 0,\n      x2: 0,\n      y2: -3,\n      sweep: false,\n      large: false\n    }, {\n      mode: \"i\",\n      ref: 1,\n      x2: 0,\n      y2: 3,\n      sweep: false,\n      large: false\n    }],\n    text: {\n      x: 0,\n      y: 0\n    }\n  }];\n  var bb$3 = {\n    x: -9,\n    y: -5,\n    width: 18,\n    height: 10\n  };\n  var venn2 = {\n    sets: sets$3,\n    intersections: intersections$3,\n    bb: bb$3\n  };\n  var sets$2 = [{\n    cx: -3.464,\n    cy: -2,\n    r: 5,\n    text: {\n      x: -7,\n      y: -6\n    },\n    align: \"end\"\n  }, {\n    cx: 3.464,\n    cy: -2,\n    r: 5,\n    text: {\n      x: 7,\n      y: -6\n    },\n    align: \"start\"\n  }, {\n    cx: 0,\n    cy: 4,\n    r: 5,\n    text: {\n      x: 4,\n      y: 7.5\n    },\n    align: \"start\",\n    verticalAlign: \"top\"\n  }];\n  var intersections$2 = [{\n    sets: [0],\n    x1: -4.855,\n    y1: 2.803,\n    arcs: [{\n      mode: \"o\",\n      ref: 2,\n      x2: -1.39,\n      y2: -0.803,\n      sweep: true,\n      large: false\n    }, {\n      mode: \"o\",\n      ref: 1,\n      x2: 0,\n      y2: -5.606,\n      sweep: true,\n      large: false\n    }, {\n      mode: \"i\",\n      ref: 0,\n      x2: -4.855,\n      y2: 2.803,\n      sweep: false,\n      large: true\n    }],\n    text: {\n      x: -4.216,\n      y: -2.434\n    }\n  }, {\n    sets: [1],\n    x1: 0,\n    y1: -5.606,\n    arcs: [{\n      mode: \"o\",\n      ref: 0,\n      x2: 1.39,\n      y2: -0.803,\n      sweep: true,\n      large: false\n    }, {\n      mode: \"o\",\n      ref: 2,\n      x2: 4.855,\n      y2: 2.803,\n      sweep: true,\n      large: false\n    }, {\n      mode: \"i\",\n      ref: 1,\n      x2: 0,\n      y2: -5.606,\n      sweep: false,\n      large: true\n    }],\n    text: {\n      x: 4.216,\n      y: -2.434\n    }\n  }, {\n    sets: [2],\n    x1: -4.855,\n    y1: 2.803,\n    arcs: [{\n      mode: \"o\",\n      ref: 0,\n      x2: 0,\n      y2: 1.606,\n      sweep: false,\n      large: false\n    }, {\n      mode: \"o\",\n      ref: 1,\n      x2: 4.855,\n      y2: 2.803,\n      sweep: false,\n      large: false\n    }, {\n      mode: \"i\",\n      ref: 2,\n      x2: -4.855,\n      y2: 2.803,\n      sweep: true,\n      large: true\n    }],\n    text: {\n      x: 0,\n      y: 4.869\n    }\n  }, {\n    sets: [0, 1],\n    x1: 0,\n    y1: -5.606,\n    arcs: [{\n      mode: \"i\",\n      ref: 1,\n      x2: -1.39,\n      y2: -0.803,\n      sweep: false,\n      large: false\n    }, {\n      mode: \"o\",\n      ref: 2,\n      x2: 1.39,\n      y2: -0.803,\n      sweep: true,\n      large: false\n    }, {\n      mode: \"i\",\n      ref: 0,\n      x2: 0,\n      y2: -5.606,\n      sweep: false,\n      large: false\n    }],\n    text: {\n      x: 0,\n      y: -2.404\n    }\n  }, {\n    sets: [0, 2],\n    x1: -4.855,\n    y1: 2.803,\n    arcs: [{\n      mode: \"i\",\n      ref: 2,\n      x2: -1.39,\n      y2: -0.803,\n      sweep: true,\n      large: false\n    }, {\n      mode: \"o\",\n      ref: 1,\n      x2: 0,\n      y2: 1.606,\n      sweep: false,\n      large: false\n    }, {\n      mode: \"i\",\n      ref: 0,\n      x2: -4.855,\n      y2: 2.803,\n      sweep: true,\n      large: false\n    }],\n    text: {\n      x: -2.082,\n      y: 1.202\n    }\n  }, {\n    sets: [1, 2],\n    x1: 4.855,\n    y1: 2.803,\n    arcs: [{\n      mode: \"i\",\n      ref: 2,\n      x2: 1.39,\n      y2: -0.803,\n      sweep: false,\n      large: false\n    }, {\n      mode: \"o\",\n      ref: 0,\n      x2: 0,\n      y2: 1.606,\n      sweep: true,\n      large: false\n    }, {\n      mode: \"i\",\n      ref: 1,\n      x2: 4.855,\n      y2: 2.803,\n      sweep: false,\n      large: false\n    }],\n    text: {\n      x: 2.082,\n      y: 1.202\n    }\n  }, {\n    sets: [0, 1, 2],\n    x1: 1.39,\n    y1: -0.803,\n    arcs: [{\n      mode: \"i\",\n      ref: 0,\n      x2: 0,\n      y2: 1.606,\n      sweep: true,\n      large: false\n    }, {\n      mode: \"i\",\n      ref: 1,\n      x2: -1.39,\n      y2: -0.803,\n      sweep: true,\n      large: false\n    }, {\n      mode: \"i\",\n      ref: 2,\n      x2: 1.39,\n      y2: -0.803,\n      sweep: true,\n      large: false\n    }],\n    text: {\n      x: 0,\n      y: 0\n    }\n  }];\n  var bb$2 = {\n    x: -8.464,\n    y: -7,\n    width: 16.928,\n    height: 16\n  };\n  var venn3 = {\n    sets: sets$2,\n    intersections: intersections$2,\n    bb: bb$2\n  };\n  var sets$1 = [{\n    cx: 0.439,\n    cy: -1.061,\n    rx: 2.5,\n    ry: 5,\n    rotation: 45,\n    text: {\n      x: 4.5,\n      y: -4.5\n    },\n    align: \"start\",\n    verticalAlign: \"bottom\"\n  }, {\n    cx: 2.561,\n    cy: 1.061,\n    rx: 2.5,\n    ry: 5,\n    rotation: 45,\n    text: {\n      x: 4,\n      y: 3.75\n    },\n    align: \"start\",\n    verticalAlign: \"top\"\n  }, {\n    cx: -2.561,\n    cy: 1.061,\n    rx: 2.5,\n    ry: 5,\n    rotation: -45,\n    text: {\n      x: -4,\n      y: 3.7\n    },\n    align: \"end\",\n    verticalAlign: \"top\"\n  }, {\n    cx: -0.439,\n    cy: -1.061,\n    rx: 2.5,\n    ry: 5,\n    rotation: -45,\n    text: {\n      x: -4.5,\n      y: -4.5\n    },\n    align: \"end\",\n    verticalAlign: \"bottom\"\n  }];\n  var intersections$1 = [{\n    sets: [0],\n    x1: 0,\n    y1: -3.94,\n    arcs: [{\n      ref: 0,\n      mode: \"i\",\n      x2: 4.328,\n      y2: -2.828,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: 2.179,\n      y2: -1.858,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: 0,\n      y2: -3.94,\n      large: false\n    }],\n    text: {\n      x: 2.914,\n      y: -3.536\n    }\n  }, {\n    sets: [1],\n    x1: 4.328,\n    y1: -2.828,\n    arcs: [{\n      ref: 1,\n      mode: \"i\",\n      x2: 0,\n      y2: 5.006,\n      sweep: true,\n      large: true\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: 1.328,\n      y2: 2.828\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: 3.108,\n      y2: -0.328\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: 4.328,\n      y2: -2.828\n    }],\n    text: {\n      x: 5.036,\n      y: -1.414\n    }\n  }, {\n    sets: [2],\n    x1: 0,\n    y1: 5.006,\n    arcs: [{\n      ref: 2,\n      mode: \"i\",\n      x2: -4.328,\n      y2: -2.828,\n      sweep: true,\n      large: true\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: -3.108,\n      y2: -0.328\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: -1.328,\n      y2: 2.828\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: 0,\n      y2: 5.006\n    }],\n    text: {\n      x: -5.036,\n      y: -1.414\n    }\n  }, {\n    sets: [3],\n    x1: -4.328,\n    y1: -2.828,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: 0,\n      y2: -3.94,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: -2.179,\n      y2: -1.858,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: -4.328,\n      y2: -2.828,\n      large: false\n    }],\n    text: {\n      x: -2.914,\n      y: -3.536\n    }\n  }, {\n    sets: [0, 1],\n    x1: 4.328,\n    y1: -2.828,\n    arcs: [{\n      ref: 1,\n      mode: \"i\",\n      x2: 3.108,\n      y2: -0.328,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: 2.179,\n      y2: -1.858,\n      sweep: false,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: 4.328,\n      y2: -2.828,\n      sweep: true,\n      large: false\n    }],\n    text: {\n      x: 3.205,\n      y: -1.672\n    }\n  }, {\n    sets: [0, 2],\n    x1: -1.328,\n    y1: 2.828,\n    arcs: [{\n      ref: 0,\n      mode: \"i\",\n      x2: -3.108,\n      y2: -0.328,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: -0.969,\n      y2: 1.755,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: -1.328,\n      y2: 2.828,\n      large: false\n    }],\n    text: {\n      x: -2.212,\n      y: 1.591\n    }\n  }, {\n    sets: [0, 3],\n    x1: 0,\n    y1: -3.94,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: 2.179,\n      y2: -1.858,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: 0,\n      y2: 0.188,\n      sweep: false,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: -2.179,\n      y2: -1.858,\n      sweep: false,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: 0,\n      y2: -3.94,\n      sweep: true\n    }],\n    text: {\n      x: 0,\n      y: -1.87\n    }\n  }, {\n    sets: [1, 2],\n    x1: 1.328,\n    y1: 2.828,\n    arcs: [{\n      ref: 2,\n      mode: \"i\",\n      x2: 0,\n      y2: 5.006,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: -1.328,\n      y2: 2.828,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: 0,\n      y2: 2.346,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: 1.328,\n      y2: 2.828\n    }],\n    text: {\n      x: 0,\n      y: 3.393\n    }\n  }, {\n    sets: [1, 3],\n    x1: 3.108,\n    y1: -0.328,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: 1.328,\n      y2: 2.828,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: 0.969,\n      y2: 1.755,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: 3.108,\n      y2: -0.328,\n      large: false\n    }],\n    text: {\n      x: 2.212,\n      y: 1.591\n    }\n  }, {\n    sets: [2, 3],\n    x1: -3.108,\n    y1: -0.328,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: -4.328,\n      y2: -2.828,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"i\",\n      x2: -2.179,\n      y2: -1.858,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: -3.108,\n      y2: -0.328,\n      large: false\n    }],\n    text: {\n      x: -3.205,\n      y: -1.672\n    }\n  }, {\n    sets: [0, 1, 2],\n    x1: 0,\n    y1: 2.346,\n    arcs: [{\n      ref: 0,\n      mode: \"i\",\n      x2: -1.328,\n      y2: 2.828,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: -0.969,\n      y2: 1.755,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: 0,\n      y2: 2.346,\n      large: false\n    }],\n    text: {\n      x: -0.766,\n      y: 2.31\n    }\n  }, {\n    sets: [0, 1, 3],\n    x1: 2.179,\n    y1: -1.858,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: 3.108,\n      y2: -0.328,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: 0.969,\n      y2: 1.755,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: 0,\n      y2: 0.188,\n      sweep: false,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: 2.179,\n      y2: -1.858,\n      sweep: true\n    }],\n    text: {\n      x: 1.558,\n      y: -0.056\n    }\n  }, {\n    sets: [0, 2, 3],\n    x1: -0.969,\n    y1: 1.755,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: -3.108,\n      y2: -0.328,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: -2.179,\n      y2: -1.858,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"i\",\n      x2: 0,\n      y2: 0.188,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: -0.969,\n      y2: 1.755\n    }],\n    text: {\n      x: -1.558,\n      y: -0.056\n    }\n  }, {\n    sets: [1, 2, 3],\n    x1: 1.328,\n    y1: 2.828,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: 0,\n      y2: 2.346,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: 0.969,\n      y2: 1.755,\n      sweep: false,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"i\",\n      x2: 1.328,\n      y2: 2.828,\n      sweep: true,\n      large: false\n    }],\n    text: {\n      x: 0.766,\n      y: 2.31\n    }\n  }, {\n    sets: [0, 1, 2, 3],\n    x1: 0,\n    y1: 0.188,\n    arcs: [{\n      ref: 2,\n      mode: \"i\",\n      x2: 0.969,\n      y2: 1.755,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: 0,\n      y2: 2.346,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"i\",\n      x2: -0.969,\n      y2: 1.755,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: 0,\n      y2: 0.188,\n      sweep: true\n    }],\n    text: {\n      x: 0,\n      y: 1.43\n    }\n  }];\n  var bb$1 = {\n    x: -6.5,\n    y: -5,\n    width: 13,\n    height: 10\n  };\n  var venn4 = {\n    sets: sets$1,\n    intersections: intersections$1,\n    bb: bb$1\n  };\n  var sets = [{\n    cx: 0.5,\n    cy: -1,\n    rx: 2.5,\n    ry: 5,\n    rotation: 0,\n    text: {\n      x: 2.25,\n      y: -5\n    },\n    icon: {\n      x: 0,\n      y: -6.3\n    },\n    align: \"start\",\n    verticalAlign: \"bottom\"\n  }, {\n    cx: 1.106,\n    cy: 0.167,\n    rx: 2.5,\n    ry: 5,\n    rotation: 72,\n    text: {\n      x: 4.5,\n      y: 1.5\n    },\n    icon: {\n      x: 6.2,\n      y: -1.9\n    },\n    align: \"start\",\n    verticalAlign: \"top\"\n  }, {\n    cx: 0.183,\n    cy: 1.103,\n    rx: 2.5,\n    ry: 5,\n    rotation: 144,\n    icon: {\n      x: 3.2,\n      y: 6\n    },\n    text: {\n      x: 4,\n      y: 4\n    },\n    align: \"start\",\n    verticalAlign: \"bottom\"\n  }, {\n    cx: -0.992,\n    cy: 0.515,\n    rx: 2.5,\n    ry: 5,\n    rotation: 216,\n    icon: {\n      x: -4.4,\n      y: 5.2\n    },\n    text: {\n      x: -4.7,\n      y: 2\n    },\n    align: \"end\",\n    verticalAlign: \"bottom\"\n  }, {\n    cx: -0.797,\n    cy: -0.785,\n    rx: 2.5,\n    ry: 5,\n    rotation: 288,\n    icon: {\n      x: -6,\n      y: -2\n    },\n    text: {\n      x: -4,\n      y: -3.6\n    },\n    align: \"end\",\n    verticalAlign: \"bottom\"\n  }];\n  var intersections = [{\n    sets: [0],\n    x1: -1.653,\n    y1: -3.541,\n    arcs: [{\n      ref: 0,\n      mode: \"i\",\n      x2: 2.857,\n      y2: -2.666,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: 2.5,\n      y2: -2.648,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: -0.495,\n      y2: -3.303,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"o\",\n      x2: -1.653,\n      y2: -3.541\n    }],\n    text: {\n      x: 0.5,\n      y: -5\n    }\n  }, {\n    sets: [1],\n    x1: 2.857,\n    y1: -2.666,\n    arcs: [{\n      ref: 1,\n      mode: \"i\",\n      x2: 3.419,\n      y2: 1.893,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: 3.291,\n      y2: 1.559,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"o\",\n      x2: 2.988,\n      y2: -1.492,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: 2.857,\n      y2: -2.666\n    }],\n    text: {\n      x: 4.91,\n      y: -1.07\n    }\n  }, {\n    sets: [2],\n    x1: 3.419,\n    y1: 1.893,\n    arcs: [{\n      ref: 2,\n      mode: \"i\",\n      x2: -0.744,\n      y2: 3.837,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: -0.466,\n      y2: 3.612,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: 2.342,\n      y2: 2.381,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: 3.419,\n      y2: 1.893\n    }],\n    text: {\n      x: 2.534,\n      y: 4.339\n    }\n  }, {\n    sets: [3],\n    x1: -0.744,\n    y1: 3.837,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: -3.879,\n      y2: 0.478,\n      sweep: true,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"o\",\n      x2: -3.579,\n      y2: 0.673,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: -1.54,\n      y2: 2.963,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: -0.744,\n      y2: 3.837\n    }],\n    text: {\n      x: -3.343,\n      y: 3.751\n    }\n  }, {\n    sets: [4],\n    x1: -3.879,\n    y1: 0.478,\n    arcs: [{\n      ref: 4,\n      mode: \"i\",\n      x2: -1.653,\n      y2: -3.541,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: -1.746,\n      y2: -3.196,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: -3.294,\n      y2: -0.549,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: -3.879,\n      y2: 0.478\n    }],\n    text: {\n      x: -4.601,\n      y: -2.021\n    }\n  }, {\n    sets: [0, 1],\n    x1: 2.5,\n    y1: -2.648,\n    arcs: [{\n      ref: 1,\n      mode: \"i\",\n      x2: 2.857,\n      y2: -2.666,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: 2.988,\n      y2: -1.492,\n      sweep: true,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"o\",\n      x2: 2.572,\n      y2: -1.839,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: 2.5,\n      y2: -2.648\n    }],\n    text: {\n      x: 2.741,\n      y: -2.152\n    }\n  }, {\n    sets: [0, 2],\n    x1: 2.342,\n    y1: 2.381,\n    arcs: [{\n      ref: 0,\n      mode: \"i\",\n      x2: -0.466,\n      y2: 3.612,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: 0.257,\n      y2: 2.922,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: 2.342,\n      y2: 2.381,\n      large: false\n    }],\n    text: {\n      x: 0.5,\n      y: 3.5\n    }\n  }, {\n    sets: [0, 3],\n    x1: -0.495,\n    y1: -3.303,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: 2.5,\n      y2: -2.648,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: 1.51,\n      y2: -2.515,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"o\",\n      x2: -0.495,\n      y2: -3.303,\n      large: false\n    }],\n    text: {\n      x: 1.653,\n      y: -3.125\n    }\n  }, {\n    sets: [0, 4],\n    x1: -1.653,\n    y1: -3.541,\n    arcs: [{\n      ref: 4,\n      mode: \"i\",\n      x2: -0.495,\n      y2: -3.303,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: -0.954,\n      y2: -3.015,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: -1.746,\n      y2: -3.196,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: -1.653,\n      y2: -3.541\n    }],\n    text: {\n      x: -1.199,\n      y: -3.272\n    }\n  }, {\n    sets: [1, 2],\n    x1: 3.291,\n    y1: 1.559,\n    arcs: [{\n      ref: 2,\n      mode: \"i\",\n      x2: 3.419,\n      y2: 1.893,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: 2.342,\n      y2: 2.381,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: 2.544,\n      y2: 1.878,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"o\",\n      x2: 3.291,\n      y2: 1.559\n    }],\n    text: {\n      x: 2.894,\n      y: 1.942\n    }\n  }, {\n    sets: [1, 3],\n    x1: -1.54,\n    y1: 2.963,\n    arcs: [{\n      ref: 1,\n      mode: \"i\",\n      x2: -3.579,\n      y2: 0.673,\n      sweep: true,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"o\",\n      x2: -2.7,\n      y2: 1.147,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: -1.54,\n      y2: 2.963,\n      large: false\n    }],\n    text: {\n      x: -3.174,\n      y: 1.557\n    }\n  }, {\n    sets: [1, 4],\n    x1: 2.988,\n    y1: -1.492,\n    arcs: [{\n      ref: 4,\n      mode: \"i\",\n      x2: 3.291,\n      y2: 1.559,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: 2.858,\n      y2: 0.659,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: 2.988,\n      y2: -1.492,\n      large: false\n    }],\n    text: {\n      x: 3.483,\n      y: 0.606\n    }\n  }, {\n    sets: [2, 3],\n    x1: -0.466,\n    y1: 3.612,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: -0.744,\n      y2: 3.837,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"i\",\n      x2: -1.54,\n      y2: 2.963,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: -1,\n      y2: 3,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: -0.466,\n      y2: 3.612\n    }],\n    text: {\n      x: -0.953,\n      y: 3.352\n    }\n  }, {\n    sets: [2, 4],\n    x1: -3.294,\n    y1: -0.549,\n    arcs: [{\n      ref: 2,\n      mode: \"i\",\n      x2: -1.746,\n      y2: -3.196,\n      sweep: true\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: -1.925,\n      y2: -2.213\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: -3.294,\n      y2: -0.549\n    }],\n    text: {\n      x: -2.462,\n      y: -2.538\n    }\n  }, {\n    sets: [3, 4],\n    x1: -3.579,\n    y1: 0.673,\n    arcs: [{\n      ref: 4,\n      mode: \"i\",\n      x2: -3.879,\n      y2: 0.478,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"i\",\n      x2: -3.294,\n      y2: -0.549,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: -3.162,\n      y2: -0.024,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: -3.579,\n      y2: 0.673\n    }],\n    text: {\n      x: -3.483,\n      y: 0.13\n    }\n  }, {\n    sets: [0, 1, 2],\n    x1: 2.544,\n    y1: 1.878,\n    arcs: [{\n      ref: 0,\n      mode: \"i\",\n      x2: 2.342,\n      y2: 2.381,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: 0.257,\n      y2: 2.922,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: 0.983,\n      y2: 2.049,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"o\",\n      x2: 2.544,\n      y2: 1.878\n    }],\n    text: {\n      x: 1.457,\n      y: 2.331\n    }\n  }, {\n    sets: [0, 1, 3],\n    x1: 1.51,\n    y1: -2.515,\n    arcs: [{\n      ref: 1,\n      mode: \"i\",\n      x2: 2.5,\n      y2: -2.648,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"i\",\n      x2: 2.572,\n      y2: -1.839,\n      sweep: true,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"o\",\n      x2: 1.51,\n      y2: -2.515,\n      large: false\n    }],\n    text: {\n      x: 2.194,\n      y: -2.334\n    }\n  }, {\n    sets: [0, 1, 4],\n    x1: 2.572,\n    y1: -1.839,\n    arcs: [{\n      ref: 4,\n      mode: \"i\",\n      x2: 2.988,\n      y2: -1.492,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: 2.858,\n      y2: 0.659,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: 2.253,\n      y2: -0.302,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: 2.572,\n      y2: -1.839\n    }],\n    text: {\n      x: 2.667,\n      y: -0.665\n    }\n  }, {\n    sets: [0, 2, 3],\n    x1: 0.257,\n    y1: 2.922,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: -0.466,\n      y2: 3.612,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: -1,\n      y2: 3,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: 0.257,\n      y2: 2.922,\n      large: false\n    }],\n    text: {\n      x: -0.403,\n      y: 3.178\n    }\n  }, {\n    sets: [0, 2, 4],\n    x1: -1.746,\n    y1: -3.196,\n    arcs: [{\n      ref: 2,\n      mode: \"i\",\n      x2: -0.954,\n      y2: -3.015,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: -1.925,\n      y2: -2.213,\n      sweep: false,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: -1.746,\n      y2: -3.196,\n      sweep: true,\n      large: false\n    }],\n    text: {\n      x: -1.542,\n      y: -2.808\n    }\n  }, {\n    sets: [0, 3, 4],\n    x1: -0.495,\n    y1: -3.303,\n    arcs: [{\n      ref: 4,\n      mode: \"i\",\n      x2: 1.51,\n      y2: -2.515,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: 0.409,\n      y2: -2.236,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: -0.954,\n      y2: -3.015,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"i\",\n      x2: -0.495,\n      y2: -3.303\n    }],\n    text: {\n      x: 0.192,\n      y: -2.742\n    }\n  }, {\n    sets: [1, 2, 3],\n    x1: -1.54,\n    y1: 2.963,\n    arcs: [{\n      ref: 2,\n      mode: \"i\",\n      x2: -2.7,\n      y2: 1.147,\n      sweep: true,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"o\",\n      x2: -1.645,\n      y2: 1.568,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: -1,\n      y2: 3,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: -1.54,\n      y2: 2.963\n    }],\n    text: {\n      x: -1.767,\n      y: 2.106\n    }\n  }, {\n    sets: [1, 2, 4],\n    x1: 2.858,\n    y1: 0.659,\n    arcs: [{\n      ref: 2,\n      mode: \"i\",\n      x2: 3.291,\n      y2: 1.559,\n      sweep: true,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"i\",\n      x2: 2.544,\n      y2: 1.878,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: 2.858,\n      y2: 0.659,\n      large: false\n    }],\n    text: {\n      x: 2.898,\n      y: 1.365\n    }\n  }, {\n    sets: [1, 3, 4],\n    x1: -2.7,\n    y1: 1.147,\n    arcs: [{\n      ref: 4,\n      mode: \"i\",\n      x2: -3.579,\n      y2: 0.673,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: -3.162,\n      y2: -0.024,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: -2.7,\n      y2: 1.147,\n      large: false\n    }],\n    text: {\n      x: -3.147,\n      y: 0.599\n    }\n  }, {\n    sets: [2, 3, 4],\n    x1: -3.294,\n    y1: -0.549,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: -1.925,\n      y2: -2.213,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: -2,\n      y2: -1.08,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: -3.162,\n      y2: -0.024,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"i\",\n      x2: -3.294,\n      y2: -0.549\n    }],\n    text: {\n      x: -2.548,\n      y: -1.029\n    }\n  }, {\n    sets: [0, 1, 2, 3],\n    x1: 0.983,\n    y1: 2.049,\n    arcs: [{\n      ref: 3,\n      mode: \"i\",\n      x2: 0.257,\n      y2: 2.922,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: -1,\n      y2: 3,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: -1.645,\n      y2: 1.568,\n      sweep: true,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"o\",\n      x2: 0.983,\n      y2: 2.049\n    }],\n    text: {\n      x: -0.407,\n      y: 2.31\n    }\n  }, {\n    sets: [0, 1, 2, 4],\n    x1: 2.253,\n    y1: -0.302,\n    arcs: [{\n      ref: 2,\n      mode: \"i\",\n      x2: 2.858,\n      y2: 0.659,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: 2.544,\n      y2: 1.878,\n      sweep: true,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"i\",\n      x2: 0.983,\n      y2: 2.049,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"o\",\n      x2: 2.253,\n      y2: -0.302\n    }],\n    text: {\n      x: 2.071,\n      y: 1.101\n    }\n  }, {\n    sets: [0, 1, 3, 4],\n    x1: 1.51,\n    y1: -2.515,\n    arcs: [{\n      ref: 4,\n      mode: \"i\",\n      x2: 2.572,\n      y2: -1.839,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"i\",\n      x2: 2.253,\n      y2: -0.302,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"o\",\n      x2: 0.409,\n      y2: -2.236,\n      sweep: false,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: 1.51,\n      y2: -2.515,\n      sweep: true\n    }],\n    text: {\n      x: 1.687,\n      y: -1.63\n    }\n  }, {\n    sets: [0, 2, 3, 4],\n    x1: -2,\n    y1: -1.08,\n    arcs: [{\n      ref: 0,\n      mode: \"i\",\n      x2: -1.925,\n      y2: -2.213,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"i\",\n      x2: -0.954,\n      y2: -3.015,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"i\",\n      x2: 0.409,\n      y2: -2.236,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"o\",\n      x2: -2,\n      y2: -1.08\n    }],\n    text: {\n      x: -1.028,\n      y: -2.108\n    }\n  }, {\n    sets: [1, 2, 3, 4],\n    x1: -1.645,\n    y1: 1.568,\n    arcs: [{\n      ref: 4,\n      mode: \"i\",\n      x2: -2.7,\n      y2: 1.147,\n      sweep: true,\n      large: false\n    }, {\n      ref: 2,\n      mode: \"i\",\n      x2: -3.162,\n      y2: -0.024,\n      sweep: true,\n      large: false\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: -2,\n      y2: -1.08,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"o\",\n      x2: -1.645,\n      y2: 1.568\n    }],\n    text: {\n      x: -2.323,\n      y: 0.327\n    }\n  }, {\n    sets: [0, 1, 2, 3, 4],\n    x1: 0.409,\n    y1: -2.236,\n    arcs: [{\n      ref: 2,\n      mode: \"i\",\n      x2: 2.253,\n      y2: -0.302,\n      sweep: true,\n      large: false\n    }, {\n      ref: 3,\n      mode: \"i\",\n      x2: 0.983,\n      y2: 2.049,\n      sweep: true,\n      large: false\n    }, {\n      ref: 4,\n      mode: \"i\",\n      x2: -1.645,\n      y2: 1.568,\n      sweep: true,\n      large: false\n    }, {\n      ref: 0,\n      mode: \"i\",\n      x2: -2,\n      y2: -1.08,\n      sweep: true\n    }, {\n      ref: 1,\n      mode: \"i\",\n      x2: 0.409,\n      y2: -2.236,\n      sweep: true\n    }],\n    text: {\n      x: 0,\n      y: 0\n    }\n  }];\n  var bb = {\n    x: -5.5,\n    y: -6,\n    width: 11.6,\n    height: 11.8\n  };\n  var venn5 = {\n    sets: sets,\n    intersections: intersections,\n    bb: bb\n  }; // Static shapes for rendering\n\n  var shapes = [venn0, venn1, venn2, venn3, venn4, venn5];\n  /**\r\n   * Sort helper.\r\n   * Reference: https://stackoverflow.com/a/64449554/1288340\r\n   */\n\n  var upto = function upto(limit) {\n    return Array.from({\n      length: limit\n    }, function (_, i) {\n      return i;\n    });\n  };\n  /**\r\n   * Detect ellipse.\r\n   * Reference: https://github.com/upsetjs/chartjs-chart-venn/blob/master/src/model/generate.ts#L4\r\n   */\n\n\n  function isEllipse(d) {\n    return typeof d.rx === 'number';\n  }\n  /**\r\n   * Generate all combinations of a given array.\r\n   * Reference: https://stackoverflow.com/questions/5752002/find-all-possible-subset-combos-in-an-array\r\n   */\n\n\n  function combinations(array) {\n    return new Array(1 << array.length).fill().map(function (_e1, i) {\n      return array.filter(function (_e2, j) {\n        return i & 1 << j;\n      });\n    });\n  }\n  /**\r\n   * Given a array set, lookup the data.\r\n   */\n\n\n  function lookup(combo, data) {\n    var key = combo.join('|');\n    var found = data.find(function (d) {\n      return d.key === key;\n    });\n    return {\n      key: key,\n      sets: combo,\n      size: (found === null || found === void 0 ? void 0 : found.size) || 0\n    };\n  }\n  /**\r\n   * Build the data combinations for the layout.\r\n   */\n\n\n  function buildData(data) {\n    // Collect all unique sets and sort by size\n    var uniqueSets = data.filter(function (d) {\n      return d.sets.length === 1;\n    }).sort(function (a, b) {\n      return b.size - a.size;\n    }); // Map our unique sets\n\n    var uniqueSetKeys = uniqueSets.map(function (u) {\n      return u.key;\n    }); // Build all combos and return 1+ combos\n\n    var sets = combinations(uniqueSetKeys);\n    var filteredSets = sets.slice(1, sets.length); // Sort the child sets based on the parent\n\n    var result = filteredSets.map(function (d) {\n      return _toConsumableArray(d).sort(function (a, b) {\n        return uniqueSetKeys.indexOf(a) - uniqueSetKeys.indexOf(b);\n      });\n    }); // Sort the data based on index of keys and length\n    // Reference: https://stackoverflow.com/a/64449554/1288340\n\n    result.sort(function (a, b) {\n      return a.length - b.length || upto(a.length).reduce(function (diff, i) {\n        return diff || uniqueSetKeys.indexOf(a[i]) - uniqueSetKeys.indexOf(b[i]);\n      }, 0);\n    }); // reshape the data key so they will match combos\n\n    var keyedData = data.map(function (d) {\n      var sets = _toConsumableArray(d.sets).sort(function (a, b) {\n        return uniqueSetKeys.indexOf(a) - uniqueSetKeys.indexOf(b);\n      });\n\n      var key = sets.join('|');\n      return {\n        size: d.size,\n        sets: sets,\n        key: key\n      };\n    });\n    return {\n      uniqueCount: uniqueSets.length,\n      data: result.map(function (r) {\n        return lookup(r, keyedData);\n      })\n    };\n  }\n  /**\r\n   * Generate the arc slice path.\r\n   * Reference: https://github.com/upsetjs/chartjs-chart-venn/blob/master/src/model/generate.ts#L4\r\n   */\n\n\n  function generateArcSlicePath(s, refs) {\n    return \"M \".concat(s.x1, \",\").concat(s.y1, \" \").concat(s.arcs.map(function (arc) {\n      var ref = refs[arc.ref];\n      var rx = isEllipse(ref) ? ref.rx : ref.r;\n      var ry = isEllipse(ref) ? ref.ry : ref.r;\n      var rot = isEllipse(ref) ? ref.rotation : 0;\n      return \"A \".concat(rx, \" \").concat(ry, \" \").concat(rot, \" \").concat(arc.large ? 1 : 0, \" \").concat(arc.sweep ? 1 : 0, \" \").concat(arc.x2, \" \").concat(arc.y2);\n    }).join(' '));\n  }\n  /**\r\n   * Build the layout for the given chart.\r\n   * Reference: https://github.com/upsetjs/chartjs-chart-venn/blob/master/src/model/generate.ts#L4\r\n   */\n\n\n  function buildLayout(_ref95, box) {\n    var data = _ref95.data,\n        uniqueCount = _ref95.uniqueCount;\n    var shape = shapes[Math.min(shapes.length - 1, uniqueCount)];\n    var f = Math.min(box.width / shape.bb.width, box.height / shape.bb.height);\n    var x = f * -shape.bb.x + (box.width - f * shape.bb.width) / 2 + 0;\n    var y = f * -shape.bb.y + (box.height - f * shape.bb.height) / 2 + 0;\n\n    var mx = function mx(v) {\n      return x + f * v;\n    };\n\n    var my = function my(v) {\n      return y + f * v;\n    };\n\n    var shapeSets = shape.sets.map(function (c, i) {\n      return Object.assign(Object.assign(Object.assign({}, c), Object.assign({\n        data: data[i],\n        cx: mx(c.cx),\n        cy: my(c.cy),\n        text: {\n          x: mx(c.text.x),\n          y: my(c.text.y)\n        }\n      }, c.icon ? {\n        icon: {\n          x: mx(c.icon.x),\n          y: my(c.icon.y)\n        }\n      } : {})), isEllipse(c) ? {\n        rx: c.rx * f,\n        ry: c.ry * f\n      } : {\n        r: c.r * f\n      });\n    });\n    var intersections = shape.intersections.map(function (c, i) {\n      return {\n        text: {\n          x: mx(c.text.x),\n          y: my(c.text.y)\n        },\n        x1: mx(c.x1),\n        y1: my(c.y1),\n        data: data[i],\n        set: shapeSets[i],\n        arcs: c.arcs.map(function (a) {\n          return Object.assign(Object.assign({}, a), {\n            x2: mx(a.x2),\n            y2: my(a.y2)\n          });\n        })\n      };\n    });\n    return intersections.map(function (i) {\n      return Object.assign(Object.assign({}, i), {\n        path: generateArcSlicePath(i, shapeSets)\n      });\n    });\n  }\n  /**\r\n   * Generate the star euler layout.\r\n   * Adapted from: https://github.com/upsetjs/chartjs-chart-venn\r\n   */\n\n\n  function starEulerLayout(data, bb) {\n    return buildLayout(buildData(data), bb);\n  }\n\n  var VennDiagram = function VennDiagram(_ref96) {\n    var id = _ref96.id,\n        type = _ref96.type,\n        width = _ref96.width,\n        height = _ref96.height,\n        margins = _ref96.margins,\n        className = _ref96.className,\n        containerClassName = _ref96.containerClassName,\n        data = _ref96.data,\n        disabled = _ref96.disabled,\n        series = _ref96.series;\n    var renderChart = react.useCallback(function (containerProps) {\n      var normalized = data.map(function (d) {\n        return {\n          key: d.key.join('|'),\n          sets: d.key,\n          size: d.data\n        };\n      });\n      var layoutData;\n\n      if (type === 'starEuler') {\n        layoutData = starEulerLayout(normalized, {\n          height: containerProps.height,\n          width: containerProps.width\n        });\n      } else {\n        layoutData = venn_js.layout(normalized, {\n          height: containerProps.height,\n          width: containerProps.width,\n          distinct: type !== 'euler'\n        });\n      }\n\n      return jsxRuntime.jsx(rdk.CloneElement, {\n        element: series,\n        data: layoutData,\n        disabled: disabled,\n        id: containerProps.id\n      }, void 0);\n    }, [data, disabled, series, type]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      margins: margins,\n      containerClassName: containerClassName,\n      xAxisVisible: false,\n      yAxisVisible: false,\n      center: false,\n      className: className\n    }, {\n      children: renderChart\n    }), void 0);\n  };\n\n  VennDiagram.defaultProps = {\n    type: 'venn',\n    series: jsxRuntime.jsx(VennSeries, {}, void 0)\n  };\n\n  var Bubble = function Bubble(_ref97) {\n    var id = _ref97.id,\n        data = _ref97.data,\n        fill = _ref97.fill,\n        mask = _ref97.mask,\n        gradient = _ref97.gradient,\n        onClick = _ref97.onClick,\n        _onMouseEnter5 = _ref97.onMouseEnter,\n        _onMouseLeave5 = _ref97.onMouseLeave,\n        animated = _ref97.animated,\n        _ref97$tooltip = _ref97.tooltip,\n        tooltip = _ref97$tooltip === void 0 ? jsxRuntime.jsx(ChartTooltip, {}, void 0) : _ref97$tooltip;\n\n    var _react$useState63 = react.useState(false),\n        _react$useState64 = _slicedToArray(_react$useState63, 2),\n        internalActive = _react$useState64[0],\n        setInternalActive = _react$useState64[1];\n\n    var bubbleRef = react.useRef(null);\n    var transition = animated ? DEFAULT_TRANSITION : {\n      type: false,\n      delay: 0\n    };\n    var arcFill = gradient && !mask ? \"url(#gradient-\".concat(id, \")\") : mask ? \"url(#mask-pattern-\".concat(id, \")\") : fill;\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [jsxRuntime.jsx(framerMotion.motion.circle, {\n        id: \"\".concat(id, \"-bubble\"),\n        ref: bubbleRef,\n        fill: arcFill,\n        initial: {\n          r: data.r,\n          cx: data.x,\n          cy: data.y\n        },\n        animate: {\n          r: data.r,\n          cx: data.x,\n          cy: data.y\n        },\n        transition: transition,\n        onClick: onClick,\n        onMouseEnter: function onMouseEnter(event) {\n          setInternalActive(true);\n          _onMouseEnter5 === null || _onMouseEnter5 === void 0 ? void 0 : _onMouseEnter5(event);\n        },\n        onMouseLeave: function onMouseLeave(event) {\n          setInternalActive(false);\n          _onMouseLeave5 === null || _onMouseLeave5 === void 0 ? void 0 : _onMouseLeave5(event);\n        }\n      }, void 0), mask && jsxRuntime.jsxs(react.Fragment, {\n        children: [jsxRuntime.jsx(Mask, {\n          id: \"mask-\".concat(id),\n          fill: \"url(#gradient-\".concat(id, \")\")\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: mask,\n          id: \"mask-pattern-\".concat(id),\n          fill: fill\n        }, void 0)]\n      }, void 0), gradient && jsxRuntime.jsx(rdk.CloneElement, {\n        element: gradient,\n        id: \"gradient-\".concat(id),\n        color: fill\n      }, void 0), tooltip && !tooltip.props.disabled && jsxRuntime.jsx(rdk.CloneElement, {\n        element: tooltip,\n        visible: !!internalActive,\n        reference: bubbleRef,\n        value: {\n          y: data.data.data,\n          x: data.data.key\n        }\n      }, void 0)]\n    }, void 0);\n  };\n\n  var BubbleLabel = function BubbleLabel(_ref98) {\n    var id = _ref98.id,\n        data = _ref98.data,\n        format = _ref98.format,\n        _ref98$wrap = _ref98.wrap,\n        wrap = _ref98$wrap === void 0 ? true : _ref98$wrap,\n        _ref98$fill = _ref98.fill,\n        fill = _ref98$fill === void 0 ? '#000' : _ref98$fill,\n        _ref98$fontSize = _ref98.fontSize,\n        fontSize = _ref98$fontSize === void 0 ? 14 : _ref98$fontSize,\n        _ref98$fontFamily = _ref98.fontFamily,\n        fontFamily = _ref98$fontFamily === void 0 ? 'sans-serif' : _ref98$fontFamily,\n        animated = _ref98.animated;\n    var transition = animated ? DEFAULT_TRANSITION : {\n      type: false,\n      delay: 0\n    };\n    var isElement = false;\n    var label;\n\n    if (format) {\n      label = format(data);\n      isElement = react.isValidElement(label);\n    }\n\n    if (!isElement) {\n      var text = wrap ? wrapText({\n        key: data.data.key,\n        fontFamily: fontFamily,\n        fontSize: fontSize,\n        width: data.r\n      }) : data.data.key;\n      return jsxRuntime.jsx(framerMotion.motion.text, Object.assign({\n        initial: {\n          x: data.x,\n          y: data.y\n        },\n        animate: {\n          x: data.x,\n          y: data.y\n        },\n        transition: transition,\n        id: \"\".concat(id, \"-text\"),\n        style: {\n          pointerEvents: 'none',\n          fontFamily: fontFamily,\n          fontSize: fontSize\n        },\n        fill: fill,\n        textAnchor: \"middle\"\n      }, {\n        children: text\n      }), void 0);\n    }\n\n    return jsxRuntime.jsx(\"g\", Object.assign({\n      style: {\n        transform: \"translate(\".concat(data.x, \"px, \").concat(data.y, \"px)\")\n      }\n    }, {\n      children: label\n    }), void 0);\n  };\n\n  var BubbleSeries = function BubbleSeries(_ref99) {\n    var id = _ref99.id,\n        data = _ref99.data,\n        _ref99$colorScheme = _ref99.colorScheme,\n        colorScheme = _ref99$colorScheme === void 0 ? 'cybertron' : _ref99$colorScheme,\n        _ref99$animated = _ref99.animated,\n        animated = _ref99$animated === void 0 ? true : _ref99$animated,\n        _ref99$bubble = _ref99.bubble,\n        bubble = _ref99$bubble === void 0 ? jsxRuntime.jsx(Bubble, {}, void 0) : _ref99$bubble,\n        _ref99$label = _ref99.label,\n        label = _ref99$label === void 0 ? jsxRuntime.jsx(BubbleLabel, {}, void 0) : _ref99$label;\n    var transition = animated ? DEFAULT_TRANSITION : {\n      type: false,\n      delay: 0\n    };\n\n    var renderBubble = function renderBubble(item, index) {\n      var fill = getColor({\n        data: data,\n        colorScheme: colorScheme,\n        point: item.data,\n        index: index\n      });\n      var textFill = fill ? invert__default['default'](chroma__default['default'](fill).darken(0.5).hex(), true) : 'white';\n      return jsxRuntime.jsxs(framerMotion.motion.g, Object.assign({\n        initial: {\n          scale: 0.5,\n          opacity: 0\n        },\n        animate: {\n          scale: 1,\n          opacity: 1\n        },\n        transition: transition\n      }, {\n        children: [jsxRuntime.jsx(rdk.CloneElement, {\n          element: bubble,\n          id: \"\".concat(id, \"-bubble\"),\n          animated: animated,\n          data: item,\n          fill: fill\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: label,\n          id: \"\".concat(id, \"-label\"),\n          animated: animated,\n          data: item,\n          fill: textFill\n        }, void 0)]\n      }), item.data.key);\n    };\n\n    return jsxRuntime.jsx(react.Fragment, {\n      children: data.map(renderBubble)\n    }, void 0);\n  };\n\n  var BubbleChart = function BubbleChart(_ref100) {\n    var _ref100$data = _ref100.data,\n        data = _ref100$data === void 0 ? [] : _ref100$data,\n        id = _ref100.id,\n        width = _ref100.width,\n        height = _ref100.height,\n        className = _ref100.className,\n        containerClassName = _ref100.containerClassName,\n        _ref100$margins = _ref100.margins,\n        margins = _ref100$margins === void 0 ? 10 : _ref100$margins,\n        _ref100$series = _ref100.series,\n        series = _ref100$series === void 0 ? jsxRuntime.jsx(BubbleSeries, {}, void 0) : _ref100$series;\n    var getData = react.useCallback(function (cw, ch) {\n      var bubble = d3Hierarchy.pack().size([cw, ch]).padding(3);\n      var root = d3Hierarchy.hierarchy({\n        children: data\n      }).sum(function (d) {\n        return d.data;\n      }).sort(function (a, b) {\n        return b.data - a.data;\n      });\n      return bubble(root).leaves();\n    }, [data]);\n    var renderChart = react.useCallback(function (_a) {\n      var chartWidth = _a.chartWidth,\n          chartHeight = _a.chartHeight,\n          rest = __rest(_a, [\"chartWidth\", \"chartHeight\"]);\n\n      var circles = getData(chartWidth, chartHeight);\n      return jsxRuntime.jsx(rdk.CloneElement, {\n        element: series,\n        id: \"\".concat(rest.id, \"-series\"),\n        data: circles\n      }, void 0);\n    }, [series, getData]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      containerClassName: containerClassName,\n      margins: margins,\n      xAxisVisible: false,\n      yAxisVisible: false,\n      className: className\n    }, {\n      children: renderChart\n    }), void 0);\n  };\n\n  var TreeMapLabel = function TreeMapLabel(_ref101) {\n    var id = _ref101.id,\n        data = _ref101.data,\n        fill = _ref101.fill,\n        wrap = _ref101.wrap,\n        fontSize = _ref101.fontSize,\n        fontFamily = _ref101.fontFamily;\n    var key = data.data.key;\n    var text = wrap ? wrapText({\n      key: key,\n      fontFamily: fontFamily,\n      fontSize: fontSize,\n      paddingX: 10,\n      paddingY: 10,\n      width: data.x1 - data.x0,\n      height: data.y1 - data.y0\n    }) : key;\n    return jsxRuntime.jsx(\"g\", Object.assign({\n      style: {\n        transform: 'translate(10px, 15px)'\n      }\n    }, {\n      children: jsxRuntime.jsx(\"text\", Object.assign({\n        id: \"\".concat(id, \"-text\"),\n        style: {\n          pointerEvents: 'none',\n          fontFamily: fontFamily,\n          fontSize: fontSize\n        },\n        fill: fill\n      }, {\n        children: text\n      }), void 0)\n    }), void 0);\n  };\n\n  TreeMapLabel.defaultProps = {\n    fill: '#FFF',\n    wrap: true,\n    fontSize: 14,\n    fontFamily: 'sans-serif'\n  };\n\n  var TreeMapRect = function TreeMapRect(_ref102) {\n    var data = _ref102.data,\n        fill = _ref102.fill,\n        animated = _ref102.animated,\n        cursor = _ref102.cursor,\n        tooltip = _ref102.tooltip,\n        _onMouseEnter6 = _ref102.onMouseEnter,\n        _onMouseLeave6 = _ref102.onMouseLeave,\n        _onClick6 = _ref102.onClick;\n\n    var _react$useState65 = react.useState(false),\n        _react$useState66 = _slicedToArray(_react$useState65, 2),\n        internalActive = _react$useState66[0],\n        setInternalActive = _react$useState66[1];\n\n    var rectRef = react.useRef(null);\n    var transition = animated ? DEFAULT_TRANSITION : {\n      type: false,\n      delay: 0\n    };\n    var currentFill = internalActive ? chroma__default['default'](fill).darken(0.8).hex() : fill;\n    return jsxRuntime.jsxs(react.Fragment, {\n      children: [jsxRuntime.jsx(framerMotion.motion.rect, {\n        ref: rectRef,\n        initial: {\n          fill: currentFill,\n          width: data.x1 - data.x0,\n          height: data.y1 - data.y0\n        },\n        animate: {\n          fill: currentFill,\n          width: data.x1 - data.x0,\n          height: data.y1 - data.y0\n        },\n        style: {\n          cursor: cursor\n        },\n        transition: transition,\n        onClick: function onClick(event) {\n          _onClick6 === null || _onClick6 === void 0 ? void 0 : _onClick6(event, data);\n        },\n        onMouseEnter: function onMouseEnter(event) {\n          setInternalActive(true);\n          _onMouseEnter6 === null || _onMouseEnter6 === void 0 ? void 0 : _onMouseEnter6(event, data);\n        },\n        onMouseLeave: function onMouseLeave(event) {\n          setInternalActive(false);\n          _onMouseLeave6 === null || _onMouseLeave6 === void 0 ? void 0 : _onMouseLeave6(event, data);\n        }\n      }, void 0), tooltip && !tooltip.props.disabled && jsxRuntime.jsx(rdk.CloneElement, {\n        element: tooltip,\n        visible: !!internalActive,\n        reference: rectRef,\n        value: {\n          y: data.data.data,\n          x: data.data.key\n        }\n      }, void 0)]\n    }, void 0);\n  };\n\n  TreeMapRect.defaultProps = {\n    cursor: 'pointer',\n    tooltip: jsxRuntime.jsx(ChartTooltip, {}, void 0)\n  };\n\n  var TreeMapSeries = function TreeMapSeries(_ref103) {\n    var id = _ref103.id,\n        data = _ref103.data,\n        colorScheme = _ref103.colorScheme,\n        animated = _ref103.animated,\n        rect = _ref103.rect,\n        label = _ref103.label;\n    var transition = animated ? DEFAULT_TRANSITION : {\n      type: false,\n      delay: 0\n    };\n\n    var renderItem = function renderItem(item, index) {\n      var fill = getColor({\n        data: data,\n        colorScheme: colorScheme,\n        point: item.data,\n        index: index\n      });\n      var textFill = fill ? invert__default['default'](chroma__default['default'](fill).darken(0.5).hex(), true) : 'white';\n      return jsxRuntime.jsxs(framerMotion.motion.g, Object.assign({\n        initial: {\n          scale: 0.5,\n          opacity: 0,\n          x: item.x0,\n          y: item.y0\n        },\n        animate: {\n          scale: 1,\n          opacity: 1,\n          x: item.x0,\n          y: item.y0\n        },\n        transition: transition\n      }, {\n        children: [jsxRuntime.jsx(rdk.CloneElement, {\n          element: rect,\n          id: \"\".concat(id, \"-rect\"),\n          animated: animated,\n          data: item,\n          fill: fill\n        }, void 0), jsxRuntime.jsx(rdk.CloneElement, {\n          element: label,\n          id: \"\".concat(id, \"-label\"),\n          data: item,\n          fill: textFill\n        }, void 0)]\n      }), item.data.key);\n    };\n\n    return jsxRuntime.jsx(react.Fragment, {\n      children: data.map(function (d, index) {\n        return renderItem(d, index);\n      })\n    }, void 0);\n  };\n\n  TreeMapSeries.defaultProps = {\n    colorScheme: 'cybertron',\n    animated: true,\n    rect: jsxRuntime.jsx(TreeMapRect, {}, void 0),\n    label: jsxRuntime.jsx(TreeMapLabel, {}, void 0)\n  };\n\n  var TreeMap = function TreeMap(_ref104) {\n    var data = _ref104.data,\n        id = _ref104.id,\n        containerClassName = _ref104.containerClassName,\n        width = _ref104.width,\n        height = _ref104.height,\n        className = _ref104.className,\n        margins = _ref104.margins,\n        series = _ref104.series;\n    var getData = react.useCallback(function (cw, ch) {\n      var root = d3Hierarchy.hierarchy({\n        children: data\n      }).sum(function (d) {\n        return d.data;\n      }).sort(function (a, b) {\n        return b.data - a.data;\n      });\n      var t = d3Hierarchy.treemap().size([cw, ch]).tile(d3Hierarchy.treemapSquarify).round(true).padding(1);\n      return t(root).leaves();\n    }, [data]);\n    var renderChart = react.useCallback(function (_a) {\n      var chartWidth = _a.chartWidth,\n          chartHeight = _a.chartHeight,\n          rest = __rest(_a, [\"chartWidth\", \"chartHeight\"]);\n\n      var datas = getData(chartWidth, chartHeight);\n      return jsxRuntime.jsx(rdk.CloneElement, Object.assign({\n        element: series\n      }, rest, {\n        id: \"\".concat(id, \"-series\"),\n        data: datas\n      }), void 0);\n    }, [series, getData, id]);\n    return jsxRuntime.jsx(ChartContainer, Object.assign({\n      id: id,\n      width: width,\n      height: height,\n      containerClassName: containerClassName,\n      margins: margins,\n      xAxisVisible: false,\n      yAxisVisible: false,\n      className: className\n    }, {\n      children: renderChart\n    }), void 0);\n  };\n\n  TreeMap.defaultProps = {\n    margins: 0,\n    series: jsxRuntime.jsx(TreeMapSeries, {}, void 0),\n    data: []\n  };\n  exports.Area = Area;\n  exports.AreaChart = AreaChart;\n  exports.AreaSeries = AreaSeries;\n  exports.AreaSparklineChart = AreaSparklineChart;\n  exports.Bar = Bar;\n  exports.BarChart = BarChart;\n  exports.BarLabel = BarLabel;\n  exports.BarSeries = BarSeries;\n  exports.BarSparklineChart = BarSparklineChart;\n  exports.Brush = Brush;\n  exports.BrushSlice = BrushSlice;\n  exports.Bubble = Bubble;\n  exports.BubbleChart = BubbleChart;\n  exports.BubbleLabel = BubbleLabel;\n  exports.BubbleSeries = BubbleSeries;\n  exports.COUNT_DEFAULTS = COUNT_DEFAULTS;\n  exports.CalendarHeatmap = CalendarHeatmap;\n  exports.ChartBrush = ChartBrush;\n  exports.ChartContainer = ChartContainer;\n  exports.ChartTooltip = ChartTooltip;\n  exports.ChartZoomPan = ChartZoomPan;\n  exports.Count = Count;\n  exports.DEFAULT_TRANSITION = DEFAULT_TRANSITION;\n  exports.DiscreteLegend = DiscreteLegend;\n  exports.DiscreteLegendEntry = DiscreteLegendEntry;\n  exports.DiscreteLegendSymbol = DiscreteLegendSymbol;\n  exports.Gradient = Gradient;\n  exports.GradientStop = GradientStop;\n  exports.GridStripe = GridStripe;\n  exports.Gridline = Gridline;\n  exports.GridlineSeries = GridlineSeries;\n  exports.GuideBar = GuideBar;\n  exports.Heatmap = Heatmap;\n  exports.HeatmapCell = HeatmapCell;\n  exports.HeatmapSeries = HeatmapSeries;\n  exports.HistogramBarChart = HistogramBarChart;\n  exports.HistogramBarSeries = HistogramBarSeries;\n  exports.HivePlot = HivePlot;\n  exports.Line = Line;\n  exports.LineChart = LineChart;\n  exports.LineSeries = LineSeries;\n  exports.LinearAxis = LinearAxis;\n  exports.LinearAxisLine = LinearAxisLine;\n  exports.LinearAxisTickLabel = LinearAxisTickLabel;\n  exports.LinearAxisTickLine = LinearAxisTickLine;\n  exports.LinearAxisTickSeries = LinearAxisTickSeries;\n  exports.LinearGauge = LinearGauge;\n  exports.LinearGaugeBar = LinearGaugeBar;\n  exports.LinearGaugeOuterBar = LinearGaugeOuterBar;\n  exports.LinearGaugeSeries = LinearGaugeSeries;\n  exports.LinearXAxis = LinearXAxis;\n  exports.LinearXAxisTickLabel = LinearXAxisTickLabel;\n  exports.LinearXAxisTickLine = LinearXAxisTickLine;\n  exports.LinearXAxisTickSeries = LinearXAxisTickSeries;\n  exports.LinearYAxis = LinearYAxis;\n  exports.LinearYAxisTickLabel = LinearYAxisTickLabel;\n  exports.LinearYAxisTickLine = LinearYAxisTickLine;\n  exports.LinearYAxisTickSeries = LinearYAxisTickSeries;\n  exports.Map = Map$1;\n  exports.MapMarker = MapMarker;\n  exports.MarimekkoBarSeries = MarimekkoBarSeries;\n  exports.MarimekkoChart = MarimekkoChart;\n  exports.MarkLine = MarkLine;\n  exports.Mask = Mask;\n  exports.MotionPath = MotionPath;\n  exports.Move = Move;\n  exports.Pan = Pan;\n  exports.PieArc = PieArc;\n  exports.PieArcLabel = PieArcLabel;\n  exports.PieArcSeries = PieArcSeries;\n  exports.PieChart = PieChart;\n  exports.PointSeries = PointSeries;\n  exports.RadialArea = RadialArea;\n  exports.RadialAreaChart = RadialAreaChart;\n  exports.RadialAreaSeries = RadialAreaSeries;\n  exports.RadialAxis = RadialAxis;\n  exports.RadialAxisArc = RadialAxisArc;\n  exports.RadialAxisArcSeries = RadialAxisArcSeries;\n  exports.RadialAxisTick = RadialAxisTick;\n  exports.RadialAxisTickLabel = RadialAxisTickLabel;\n  exports.RadialAxisTickLine = RadialAxisTickLine;\n  exports.RadialAxisTickSeries = RadialAxisTickSeries;\n  exports.RadialBar = RadialBar;\n  exports.RadialBarChart = RadialBarChart;\n  exports.RadialBarSeries = RadialBarSeries;\n  exports.RadialGauge = RadialGauge;\n  exports.RadialGaugeArc = RadialGaugeArc;\n  exports.RadialGaugeLabel = RadialGaugeLabel;\n  exports.RadialGaugeOuterArc = RadialGaugeOuterArc;\n  exports.RadialGaugeSeries = RadialGaugeSeries;\n  exports.RadialGaugeValueLabel = RadialGaugeValueLabel;\n  exports.RadialGradient = RadialGradient;\n  exports.RadialGuideBar = RadialGuideBar;\n  exports.RadialLine = RadialLine;\n  exports.RadialPointSeries = RadialPointSeries;\n  exports.RadialScatterPlot = RadialScatterPlot;\n  exports.RadialScatterPoint = RadialScatterPoint;\n  exports.RadialScatterSeries = RadialScatterSeries;\n  exports.RangeLines = RangeLines;\n  exports.Sankey = Sankey;\n  exports.SankeyLabel = SankeyLabel;\n  exports.SankeyLink = SankeyLink;\n  exports.SankeyNode = SankeyNode;\n  exports.ScatterPlot = ScatterPlot;\n  exports.ScatterPoint = ScatterPoint;\n  exports.ScatterSeries = ScatterSeries;\n  exports.SequentialLegend = SequentialLegend;\n  exports.SonarChart = SonarChart;\n  exports.SparklineChart = SparklineChart;\n  exports.StackedAreaChart = StackedAreaChart;\n  exports.StackedAreaSeries = StackedAreaSeries;\n  exports.StackedBarChart = StackedBarChart;\n  exports.StackedBarSeries = StackedBarSeries;\n  exports.StackedNormalizedAreaChart = StackedNormalizedAreaChart;\n  exports.StackedNormalizedAreaSeries = StackedNormalizedAreaSeries;\n  exports.StackedNormalizedBarChart = StackedNormalizedBarChart;\n  exports.StackedNormalizedBarSeries = StackedNormalizedBarSeries;\n  exports.StackedRadialGaugeSeries = StackedRadialGaugeSeries;\n  exports.StackedRadialGaugeValueLabel = StackedRadialGaugeValueLabel;\n  exports.Stripes = Stripes;\n  exports.TooltipArea = TooltipArea;\n  exports.TooltipTemplate = TooltipTemplate;\n  exports.TreeMap = TreeMap;\n  exports.TreeMapLabel = TreeMapLabel;\n  exports.TreeMapRect = TreeMapRect;\n  exports.TreeMapSeries = TreeMapSeries;\n  exports.VennArc = VennArc;\n  exports.VennDiagram = VennDiagram;\n  exports.VennLabel = VennLabel;\n  exports.VennOuterLabel = VennOuterLabel;\n  exports.VennSeries = VennSeries;\n  exports.Zoom = Zoom;\n  exports.ZoomPan = ZoomPan;\n  exports.addWeeksToDate = addWeeksToDate;\n  exports.bigIntegerToLocaleString = bigIntegerToLocaleString;\n  exports.buildBarStackData = buildBarStackData;\n  exports.buildBins = buildBins;\n  exports.buildDataScales = buildDataScales;\n  exports.buildMarimekkoData = buildMarimekkoData;\n  exports.buildNestedChartData = buildNestedChartData;\n  exports.buildShallowChartData = buildShallowChartData;\n  exports.buildStackData = buildStackData;\n  exports.buildWaterfall = buildWaterfall;\n  exports.calculateDimensions = calculateDimensions;\n  exports.calculateShowStroke = calculateShowStroke;\n  exports.constrainMatrix = constrainMatrix;\n  exports.constructFunctionProps = constructFunctionProps;\n  exports.extent = extent;\n  exports.formatValue = formatValue;\n  exports.functionProps = functionProps;\n  exports.getClosestPoint = getClosestPoint;\n  exports.getColor = getColor;\n  exports.getDegrees = getDegrees;\n  exports.getDimension = getDimension;\n  exports.getDurationTicks = getDurationTicks;\n  exports.getLimitMatrix = getLimitMatrix;\n  exports.getMaxBigIntegerForNested = getMaxBigIntegerForNested;\n  exports.getMaxBigIntegerForShallow = getMaxBigIntegerForShallow;\n  exports.getMaxTicks = getMaxTicks;\n  exports.getParentSVG = getParentSVG;\n  exports.getPointFromMatrix = getPointFromMatrix;\n  exports.getPositionForTarget = getPositionForTarget;\n  exports.getTicks = _getTicks;\n  exports.getXDomain = getXDomain;\n  exports.getYDomain = getYDomain;\n  exports.humanFormatBigInteger = humanFormatBigInteger;\n  exports.interpolate = interpolate;\n  exports.isAxisVisible = isAxisVisible;\n  exports.isZoomLevelGoingOutOfBounds = isZoomLevelGoingOutOfBounds;\n  exports.normalizeValue = normalizeValue;\n  exports.normalizeValueForFormatting = normalizeValueForFormatting;\n  exports.reduceTicks = reduceTicks;\n  exports.schemes = schemes;\n  exports.toggleTextSelection = toggleTextSelection;\n  exports.uniqueBy = uniqueBy;\n  exports.useCount = useCount;\n  exports.weekDays = weekDays;\n  exports.wrapText = wrapText;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}